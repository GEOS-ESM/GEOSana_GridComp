#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fvcore_tl
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use fvcore

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine fvcore_do_tl( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, ps_tm, pe, pe_tm, delp, delp_tm, u, u_tm, v, v_tm, pt, &
&pt_tm, q, q_tm, pk, pk_tm, pkz, pkz_tm, phis, ptop, om, cp, rg, ae, iord, jord, kord, umax, omga, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use mapz_module_tl, only : te_map_tl
use cd_core, only : cd_core_do, cd_core_initialize
use cd_core_tl, only : cd_core_do_tl, cd_core_initialize_tl
use benergy, only : benergy_do
use benergy_tl, only : benergy_do_tl
use cd_core, only : cd_core_tape_rec
use precision
#ifdef TIMING
use timingmodule
#endif

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical, intent(in) :: convt
real(kind=r8), intent(in) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: delp_tm(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(in) :: om
real(kind=r8), intent(out) :: omga(im,km,jfirst:jlast)
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(inout) :: pe_tm(im,km+1,jfirst:jlast)
real(kind=r8), intent(out) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pk_tm(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: pkz_tm(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: ps_tm(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(inout) :: pt_tm(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: q_tm(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(in) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(inout) :: u_tm(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8), intent(inout) :: v_tm(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cx_tl(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: cy_tl(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: delpf_tl(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dp0_tl(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dptp_tl(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
real(kind=r8), allocatable :: dwzp_tl(:,:,:)
logical :: fill
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfx_tl(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
real(kind=r8), allocatable :: mfy_tl(:,:,:)
integer :: n
real(kind=r8) :: pelnh_tl(im,km+1,jfirst:jlast)
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8), allocatable :: pkcp_tl(:,:,:)
real(kind=r8) :: te0
real(kind=r8) :: te0_tl
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: ucp_tl(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: vcp_tl(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: workap_tl(:,:,:)
real(kind=r8), allocatable :: workas_tl(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)
real(kind=r8), allocatable :: wzp_tl(:,:,:)

!==============================================
! declare data
!==============================================
data fill/ .true. /

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0_tl(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx_tl(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy_tl(im,jfirst:jlast+1,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx_tl(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy_tl(im,jfirst:jlast+1,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf_tl(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
delpf_tl = 0.
delpf = 0.
te0_tl = 0.d0
te0 = 0.
if (km .gt. 1) then
  if (consv) then
#ifdef TIMING
    call g_timing_on( 'BENERGY' )
#endif
    call benergy_do_tl( im,jm,km,u,u_tm,v,v_tm,pt,pt_tm,delp,delp_tm,pe,pe_tm,pk,pk_tm,pkz,pkz_tm,phis,ng_d,ng_s,cp,te0,te0_tl,mfx,&
&mfx_tl,dp0,dp0_tl,jfirst,jlast )
#ifdef TIMING
    call g_timing_off( 'BENERGY' )
#endif
  endif
endif
do n = 1, n2
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          dp0_tl(i,j,k) = delp_tm(i,j,k)
          dp0(i,j,k) = delp(i,j,k)
          cx_tl(i,j,k) = 0.
          cx(i,j,k) = 0.
          cy_tl(i,j,k) = 0.
          cy(i,j,k) = 0.
          mfx_tl(i,j,k) = 0.
          mfx(i,j,k) = 0.
          mfy_tl(i,j,k) = 0.
          mfy(i,j,k) = 0.
        end do
      end do
    end do
  endif
  call cd_core_initialize_tl( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp )
  do it = 1, nsplit
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
#ifdef TIMING
    call g_timing_on( 'CD_CORE' )
#endif
    allocate( wzp_tl(1:size(wz,1),1:size(wz,2),1:size(wz,3)) )
    allocate( pkcp_tl(1:size(pkc,1),1:size(pkc,2),1:size(pkc,3)) )
    allocate( dwzp_tl(1:size(dwz,1),1:size(dwz,2),1:size(dwz,3)) )
    allocate( workas_tl(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    allocate( dptp_tl(1:size(dpt,1),1:size(dpt,2),1:size(dpt,3)) )
    allocate( vcp_tl(1:size(vc,1),1:size(vc,2),1:size(vc,3)) )
    allocate( ucp_tl(1:size(uc,1),1:size(uc,2),1:size(uc,3)) )
    call cd_core_do_tl( im,jm,km,nq,nx,jfirst,jlast,u,u_tm,v,v_tm,pt,pt_tm,delp,delp_tm,pe,pe_tm,pk,pk_tm,ns,ptop,rcap,cp,cappa,&
&icd,jcd,iord,jord,ng_c,ng_d,ng_s,ipe,phis,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx,cx_tl,cy,cy_tl,mfx,mfx_tl,mfy,mfy_tl,&
&delpf,delpf_tl,uc,ucp_tl,vc,vcp_tl,pkz,pkz_tm,dpt,dptp_tl,worka,workas_tl,dwz,dwzp_tl,pkc,pkcp_tl,wz,wzp_tl )
    deallocate( ucp_tl )
    deallocate( vcp_tl )
    deallocate( dptp_tl )
    deallocate( workas_tl )
    deallocate( dwzp_tl )
    deallocate( pkcp_tl )
    deallocate( wzp_tl )
#ifdef TIMING
    call g_timing_off( 'CD_CORE' )
#endif
  end do
  if (nq .ne. 0) then
#ifdef TIMING
    call g_timing_on( 'TRAC2D' )
#endif
    allocate( workap_tl(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    call trac2d_tl( dp0,dp0_tl,q,q_tm,nq,cx,cx_tl,cy,cy_tl,mfx,mfx_tl,mfy,mfy_tl,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,&
&jm,km,jfirst,jlast,pkz,pkz_tm,worka,workap_tl,cd_tape_rec_n )
    deallocate( workap_tl )
#ifdef TIMING
    call g_timing_off( 'TRAC2D' )
#endif
  endif
end do
if (km .gt. 1) then
#ifdef TIMING
  call g_timing_on( 'TE_MAP' )
#endif
  call te_map_tl( consv,convt,ps,ps_tm,omga,pe,pe_tm,delp,delp_tm,pkz,pkz_tm,pk,pk_tm,im,jm,km,nx,jfirst,jlast,nq,u,u_tm,v,v_tm,pt,&
&pt_tm,q,q_tm,phis,cp,cappa,kord,peln,pelnh_tl,te0,te0_tl,ng_d,ng_s )
#ifdef TIMING
  call g_timing_off( 'TE_MAP' )
#endif
endif
deallocate( mfy_tl )
deallocate( mfy )
deallocate( mfx_tl )
deallocate( mfx )
deallocate( cy_tl )
deallocate( cy )
deallocate( cx_tl )
deallocate( cx )
deallocate( dp0_tl )
deallocate( dp0 )
deallocate( delpf_tl )
deallocate( delpf )

end subroutine fvcore_do_tl


end module     fvcore_tl


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fvcore_tl
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use fvcore

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine fvcore_do_tl( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, ps_tm, pe, pe_tm, delp, delp_tm, u, u_tm, v, v_tm, pt, &
&pt_tm, q, q_tm, pk, pk_tm, pkz, pkz_tm, phis, ptop, om, cp, rg, ae, iord, jord, kord, umax, omga, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use mapz_module_tl, only : te_map_tl
use cd_core, only : cd_core_do, cd_core_initialize
use cd_core_tl, only : cd_core_do_tl, cd_core_initialize_tl
use benergy, only : benergy_do
use benergy_tl, only : benergy_do_tl
use cd_core, only : cd_core_tape_rec
use precision
#ifdef TIMING
use timingmodule
#endif

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical, intent(in) :: convt
real(kind=r8), intent(in) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: delp_tm(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(in) :: om
real(kind=r8), intent(out) :: omga(im,km,jfirst:jlast)
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(inout) :: pe_tm(im,km+1,jfirst:jlast)
real(kind=r8), intent(out) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pk_tm(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: pkz_tm(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: ps_tm(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(inout) :: pt_tm(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: q_tm(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(in) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(inout) :: u_tm(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8), intent(inout) :: v_tm(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cx_tl(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: cy_tl(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: delpf_tl(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dp0_tl(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dptp_tl(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
real(kind=r8), allocatable :: dwzp_tl(:,:,:)
logical :: fill
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfx_tl(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
real(kind=r8), allocatable :: mfy_tl(:,:,:)
integer :: n
real(kind=r8) :: pelnh_tl(im,km+1,jfirst:jlast)
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8), allocatable :: pkcp_tl(:,:,:)
real(kind=r8) :: te0
real(kind=r8) :: te0_tl
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: ucp_tl(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: vcp_tl(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: workap_tl(:,:,:)
real(kind=r8), allocatable :: workas_tl(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)
real(kind=r8), allocatable :: wzp_tl(:,:,:)

!==============================================
! declare data
!==============================================
data fill/ .true. /

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0_tl(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx_tl(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy_tl(im,jfirst:jlast+1,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx_tl(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy_tl(im,jfirst:jlast+1,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf_tl(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
delpf_tl = 0.
delpf = 0.
te0_tl = 0.d0
te0 = 0.
if (km .gt. 1) then
  if (consv) then
#ifdef TIMING
    call g_timing_on( 'BENERGY' )
#endif
    call benergy_do_tl( im,jm,km,u,u_tm,v,v_tm,pt,pt_tm,delp,delp_tm,pe,pe_tm,pk,pk_tm,pkz,pkz_tm,phis,ng_d,ng_s,cp,te0,te0_tl,mfx,&
&mfx_tl,dp0,dp0_tl,jfirst,jlast )
#ifdef TIMING
    call g_timing_off( 'BENERGY' )
#endif
  endif
endif
do n = 1, n2
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          dp0_tl(i,j,k) = delp_tm(i,j,k)
          dp0(i,j,k) = delp(i,j,k)
          cx_tl(i,j,k) = 0.
          cx(i,j,k) = 0.
          cy_tl(i,j,k) = 0.
          cy(i,j,k) = 0.
          mfx_tl(i,j,k) = 0.
          mfx(i,j,k) = 0.
          mfy_tl(i,j,k) = 0.
          mfy(i,j,k) = 0.
        end do
      end do
    end do
  endif
  call cd_core_initialize_tl( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp )
  do it = 1, nsplit
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
#ifdef TIMING
    call g_timing_on( 'CD_CORE' )
#endif
    allocate( wzp_tl(1:size(wz,1),1:size(wz,2),1:size(wz,3)) )
    allocate( pkcp_tl(1:size(pkc,1),1:size(pkc,2),1:size(pkc,3)) )
    allocate( dwzp_tl(1:size(dwz,1),1:size(dwz,2),1:size(dwz,3)) )
    allocate( workas_tl(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    allocate( dptp_tl(1:size(dpt,1),1:size(dpt,2),1:size(dpt,3)) )
    allocate( vcp_tl(1:size(vc,1),1:size(vc,2),1:size(vc,3)) )
    allocate( ucp_tl(1:size(uc,1),1:size(uc,2),1:size(uc,3)) )
    call cd_core_do_tl( im,jm,km,nq,nx,jfirst,jlast,u,u_tm,v,v_tm,pt,pt_tm,delp,delp_tm,pe,pe_tm,pk,pk_tm,ns,ptop,rcap,cp,cappa,&
&icd,jcd,iord,jord,ng_c,ng_d,ng_s,ipe,phis,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx,cx_tl,cy,cy_tl,mfx,mfx_tl,mfy,mfy_tl,&
&delpf,delpf_tl,uc,ucp_tl,vc,vcp_tl,pkz,pkz_tm,dpt,dptp_tl,worka,workas_tl,dwz,dwzp_tl,pkc,pkcp_tl,wz,wzp_tl )
    deallocate( ucp_tl )
    deallocate( vcp_tl )
    deallocate( dptp_tl )
    deallocate( workas_tl )
    deallocate( dwzp_tl )
    deallocate( pkcp_tl )
    deallocate( wzp_tl )
#ifdef TIMING
    call g_timing_off( 'CD_CORE' )
#endif
  end do
  if (nq .ne. 0) then
#ifdef TIMING
    call g_timing_on( 'TRAC2D' )
#endif
    allocate( workap_tl(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    call trac2d_tl( dp0,dp0_tl,q,q_tm,nq,cx,cx_tl,cy,cy_tl,mfx,mfx_tl,mfy,mfy_tl,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,&
&jm,km,jfirst,jlast,pkz,pkz_tm,worka,workap_tl,cd_tape_rec_n )
    deallocate( workap_tl )
#ifdef TIMING
    call g_timing_off( 'TRAC2D' )
#endif
  endif
end do
if (km .gt. 1) then
#ifdef TIMING
  call g_timing_on( 'TE_MAP' )
#endif
  call te_map_tl( consv,convt,ps,ps_tm,omga,pe,pe_tm,delp,delp_tm,pkz,pkz_tm,pk,pk_tm,im,jm,km,nx,jfirst,jlast,nq,u,u_tm,v,v_tm,pt,&
&pt_tm,q,q_tm,phis,cp,cappa,kord,peln,pelnh_tl,te0,te0_tl,ng_d,ng_s )
#ifdef TIMING
  call g_timing_off( 'TE_MAP' )
#endif
endif
deallocate( mfy_tl )
deallocate( mfy )
deallocate( mfx_tl )
deallocate( mfx )
deallocate( cy_tl )
deallocate( cy )
deallocate( cx_tl )
deallocate( cx )
deallocate( dp0_tl )
deallocate( dp0 )
deallocate( delpf_tl )
deallocate( delpf )

end subroutine fvcore_do_tl


end module     fvcore_tl


#endif /* SPMD */
