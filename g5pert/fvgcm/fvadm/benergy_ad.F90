#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     benergy_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use benergy

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine benergy_do_ad( im, jm, km, u, u_ae, v, v_ae, pt, pt_ae, delp, delp_ae, pe, pe_ae, pk, pk_ae, pkz, pkz_ae, phis, ng_d, &
&ng_s, cp, te0_ad, te, te_ad, dz, dz_ad, jfirst, jlast )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use mod_comm, only : mp_barrier, mp_recv_n, mp_recv_n_ad, mp_send_s, mp_send_s_ad

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: cp
integer :: im
integer :: jfirst
integer :: jlast
integer :: km
real(kind=r8) :: delp(im,jfirst:jlast,km)
real(kind=r8) :: delp_ae(im,jfirst:jlast,km)
real(kind=r8) :: dz(im,jfirst:jlast,km)
real(kind=r8) :: dz_ad(im,jfirst:jlast,km)
integer :: jm
integer :: ng_d
integer :: ng_s
real(kind=r8) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8) :: phis(im,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8) :: pkz(im,jfirst:jlast,km)
real(kind=r8) :: pkz_ae(im,jfirst:jlast,km)
real(kind=r8) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: pt_ae(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: te(im,jfirst:jlast,km)
real(kind=r8) :: te0_ad
real(kind=r8) :: te_ad(im,jfirst:jlast,km)
real(kind=r8) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: u_ae(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: v_ae(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: bte_ad(im)
real(kind=r8) :: gztop(im)
real(kind=r8) :: gztop_ad(im)
integer :: i
integer :: j
integer :: jn2g0
integer :: js2g0
integer :: k
#ifdef USE_OPENMP
real(kind=r8) :: pe_aeh(im,km+1,jfirst:jlast)
real(kind=r8) :: pk_aeh(im,jfirst:jlast,km+1)
real(kind=r8) :: te_adh(im,jfirst:jlast,km)
#endif /* ! USE_OPENMP */
real(kind=r8) :: te_np
real(kind=r8) :: te_np_ad
real(kind=r8) :: te_sp
real(kind=r8) :: te_sp_ad
real(kind=r8) :: tte_ad(jfirst:jlast)
real(kind=r8) :: u2(im,jfirst:jlast+1)
real(kind=r8) :: u2_ad(im,jfirst:jlast+1)
real(kind=r8) :: v2(im,jfirst:jlast)
real(kind=r8) :: v2_ad(im,jfirst:jlast)
real(kind=r8) :: xsum_ad

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
bte_ad(:) = 0.d0
gztop_ad(:) = 0.d0
te_np_ad = 0.d0
te_sp_ad = 0.d0
tte_ad(:) = 0.d0
u2_ad(:,:) = 0.d0
v2_ad(:,:) = 0.d0
xsum_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
js2g0 = max(2,jfirst)
jn2g0 = min(jm-1,jlast)
call mp_send_s( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u )
call mp_recv_n( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u )
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = jfirst, jlast
    do i = 1, im
      dz(i,j,k) = cp*pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
    end do
  end do
end do
call par_vecsum_ad( jm,jfirst,jlast,tte_ad,te0_ad )
#ifdef USE_OPENMP
pe_aeh(:,:,:) = pe_ae(:,:,:)
te_adh(:,:,:) = te_ad(:,:,:)
!$omp parallel do shared(acap,cosp,dz,dz_ad,im,jfirst,jlast,jm,km,pe,pe_aeh,phis,te_adh,tte_ad) private(bte_ad,gztop,gztop_ad,i,j,&
!$omp& k,pe_ae,te_ad,xsum_ad)
#endif /* ! USE_OPENMP */
do j = jfirst, jlast
#ifdef USE_OPENMP
!AOO  pe_ae(:,:,:) = 0.d0
!AOO  te_ad(:,:,:) = 0.d0
  pe_ae(:,:,j) = 0.d0
  te_ad(:,j,:) = 0.d0
#endif /* ! USE_OPENMP */
  bte_ad(:) = 0.d0
  gztop_ad(:) = 0.d0
  xsum_ad = 0.d0
  do i = 1, im
    gztop(i) = phis(i,j)
    do k = 1, km
      gztop(i) = gztop(i)+dz(i,j,k)
    end do
  end do
  if (j .eq. 1) then
    tte_ad(1) = tte_ad(1)*acap
    do k = 1, km
      te_ad(1,1,k) = te_ad(1,1,k)+tte_ad(1)
    end do
    gztop_ad(1) = gztop_ad(1)-tte_ad(1)*pe(1,1,1)
    pe_ae(1,km+1,1) = pe_ae(1,km+1,1)+tte_ad(1)*phis(1,1)
    pe_ae(1,1,1) = pe_ae(1,1,1)-tte_ad(1)*gztop(1)
    tte_ad(1) = 0.d0
  else if (j .eq. jm) then
    tte_ad(jm) = tte_ad(jm)*acap
    do k = 1, km
      te_ad(1,jm,k) = te_ad(1,jm,k)+tte_ad(jm)
    end do
    gztop_ad(1) = gztop_ad(1)-tte_ad(jm)*pe(1,1,jm)
    pe_ae(1,km+1,jm) = pe_ae(1,km+1,jm)+tte_ad(jm)*phis(1,jm)
    pe_ae(1,1,jm) = pe_ae(1,1,jm)-tte_ad(jm)*gztop(1)
    tte_ad(jm) = 0.d0
  else
    xsum_ad = xsum_ad+tte_ad(j)*cosp(j)
    tte_ad(j) = 0.d0
    do i = 1, im
      bte_ad(i) = bte_ad(i)+xsum_ad
    end do
    xsum_ad = 0.d0
    do k = km, 1, -1
      do i = 1, im
        te_ad(i,j,k) = te_ad(i,j,k)+bte_ad(i)
      end do
    end do
    do i = 1, im
      gztop_ad(i) = gztop_ad(i)-bte_ad(i)*pe(i,1,j)
      pe_ae(i,km+1,j) = pe_ae(i,km+1,j)+bte_ad(i)*phis(i,j)
      pe_ae(i,1,j) = pe_ae(i,1,j)-bte_ad(i)*gztop(i)
      bte_ad(i) = 0.d0
    end do
  endif
  do i = 1, im
    do k = 1, km
      dz_ad(i,j,k) = dz_ad(i,j,k)+gztop_ad(i)
    end do
    gztop_ad(i) = 0.d0
  end do
#ifdef USE_OPENMP
!AOO  !$omp critical  (adtaf)
!AOO  pe_aeh(:,:,:) = pe_aeh(:,:,:)+pe_ae(:,:,:)
!AOO  te_adh(:,:,:) = te_adh(:,:,:)+te_ad(:,:,:)
  pe_aeh(:,:,j) = pe_aeh(:,:,j)+pe_ae(:,:,j)
  te_adh(:,j,:) = te_adh(:,j,:)+te_ad(:,j,:)
!AOO  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
pe_ae(:,:,:) = pe_aeh(:,:,:)
te_ad(:,:,:) = te_adh(:,:,:)
pk_aeh(:,:,:) = pk_ae(:,:,:)
!AOO!$omp parallel do shared(cp,delp,delp_ae,dz_ad,im,jfirst,jlast,jm,jn2g0,js2g0,km,pk,pk_aeh,pkz,pkz_ae,pt,pt_ae,te,te_ad,u,u_ae,v,&
!AOO!$omp& v_ae) private(i,j,k,pk_ae,te_np,te_np_ad,te_sp,te_sp_ad,u2,u2_ad,v2,v2_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
#ifdef USE_OPENMP
!AOO  pk_ae(:,:,:) = 0.d0
  pk_ae(:,:,k  ) = 0.d0
  pk_ae(:,:,k+1) = 0.d0
#endif /* ! USE_OPENMP */
  te_np_ad = 0.d0
  te_sp_ad = 0.d0
  u2_ad(:,:) = 0.d0
  v2_ad(:,:) = 0.d0
  do j = js2g0, min(jlast+1,jm)
    do i = 1, im
      u2(i,j) = u(i,j,k)**2
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      v2(i,j) = v(i,j,k)**2
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im-1
      te(i,j,k) = 0.25*(u2(i,j)+u2(i,j+1)+v2(i,j)+v2(i+1,j))
    end do
    te(im,j,k) = 0.25*(u2(im,j)+u2(im,j+1)+v2(im,j)+v2(1,j))
  end do
  do j = jfirst, jlast
    do i = 1, im
      pk_ae(i,j,k+1) = pk_ae(i,j,k+1)+dz_ad(i,j,k)*cp*pt(i,j,k)
      pk_ae(i,j,k) = pk_ae(i,j,k)-dz_ad(i,j,k)*cp*pt(i,j,k)
      pt_ae(i,j,k) = pt_ae(i,j,k)+dz_ad(i,j,k)*cp*(pk(i,j,k+1)-pk(i,j,k))
      dz_ad(i,j,k) = 0.d0
    end do
  end do
  if (jlast .eq. jm) then
    te_np = 0.
    do i = 1, im
      te_np = te_np+u2(i,jm)+v2(i,jm-1)
    end do
    do i = 1, im
      te_np_ad = te_np_ad+te_ad(i,jm,k)
      te_ad(i,jm,k) = 0.d0
    end do
    delp_ae(1,jm,k) = delp_ae(1,jm,k)+te_np_ad*(0.5*te_np/float(im)+cp*pt(1,jm,k)*pkz(1,jm,k))
    pkz_ae(1,jm,k) = pkz_ae(1,jm,k)+te_np_ad*delp(1,jm,k)*cp*pt(1,jm,k)
    pt_ae(1,jm,k) = pt_ae(1,jm,k)+te_np_ad*delp(1,jm,k)*cp*pkz(1,jm,k)
    te_np_ad = te_np_ad*delp(1,jm,k)*(0.5/float(im))
    do i = 1, im
      u2_ad(i,jm) = u2_ad(i,jm)+te_np_ad
      v2_ad(i,jm-1) = v2_ad(i,jm-1)+te_np_ad
    end do
    te_np_ad = 0.d0
  endif
  if (jfirst .eq. 1) then
    te_sp = 0.
    do i = 1, im
      te_sp = te_sp+u2(i,2)+v2(i,2)
    end do
    do i = 1, im
      te_sp_ad = te_sp_ad+te_ad(i,1,k)
      te_ad(i,1,k) = 0.d0
    end do
    delp_ae(1,1,k) = delp_ae(1,1,k)+te_sp_ad*(0.5*te_sp/float(im)+cp*pt(1,1,k)*pkz(1,1,k))
    pkz_ae(1,1,k) = pkz_ae(1,1,k)+te_sp_ad*delp(1,1,k)*cp*pt(1,1,k)
    pt_ae(1,1,k) = pt_ae(1,1,k)+te_sp_ad*delp(1,1,k)*cp*pkz(1,1,k)
    te_sp_ad = te_sp_ad*delp(1,1,k)*(0.5/float(im))
    do i = 1, im
      u2_ad(i,2) = u2_ad(i,2)+te_sp_ad
      v2_ad(i,2) = v2_ad(i,2)+te_sp_ad
    end do
    te_sp_ad = 0.d0
  endif
  do j = js2g0, jn2g0
    do i = 1, im
      delp_ae(i,j,k) = delp_ae(i,j,k)+te_ad(i,j,k)*(te(i,j,k)+cp*pt(i,j,k)*pkz(i,j,k))
      pkz_ae(i,j,k) = pkz_ae(i,j,k)+te_ad(i,j,k)*delp(i,j,k)*cp*pt(i,j,k)
      pt_ae(i,j,k) = pt_ae(i,j,k)+te_ad(i,j,k)*delp(i,j,k)*cp*pkz(i,j,k)
      te_ad(i,j,k) = te_ad(i,j,k)*delp(i,j,k)
    end do
  end do
  do j = js2g0, jn2g0
    u2_ad(im,j+1) = u2_ad(im,j+1)+0.25*te_ad(im,j,k)
    u2_ad(im,j) = u2_ad(im,j)+0.25*te_ad(im,j,k)
    v2_ad(im,j) = v2_ad(im,j)+0.25*te_ad(im,j,k)
    v2_ad(1,j) = v2_ad(1,j)+0.25*te_ad(im,j,k)
    te_ad(im,j,k) = 0.d0
    do i = 1, im-1
      u2_ad(i,j+1) = u2_ad(i,j+1)+0.25*te_ad(i,j,k)
      u2_ad(i,j) = u2_ad(i,j)+0.25*te_ad(i,j,k)
      v2_ad(i+1,j) = v2_ad(i+1,j)+0.25*te_ad(i,j,k)
      v2_ad(i,j) = v2_ad(i,j)+0.25*te_ad(i,j,k)
      te_ad(i,j,k) = 0.d0
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      v_ae(i,j,k) = v_ae(i,j,k)+2*v2_ad(i,j)*v(i,j,k)
      v2_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, min(jlast+1,jm)
    do i = 1, im
      u_ae(i,j,k) = u_ae(i,j,k)+2*u2_ad(i,j)*u(i,j,k)
      u2_ad(i,j) = 0.d0
    end do
  end do
#ifdef USE_OPENMP
!AOO  !$omp critical  (adtaf)
!AOO  pk_aeh(:,:,:) = pk_aeh(:,:,:)+pk_ae(:,:,:)
  pk_aeh(:,:,k  ) = pk_aeh(:,:,k  )+pk_ae(:,:,k  )
  pk_aeh(:,:,k+1) = pk_aeh(:,:,k+1)+pk_ae(:,:,k+1)
!AOO  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
pk_ae(:,:,:) = pk_aeh(:,:,:)
#endif /* ! USE_OPENMP */
call mp_recv_n_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u_ae )
call mp_send_s_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u_ae )

end subroutine benergy_do_ad


end module     benergy_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     benergy_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use benergy

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine benergy_do_ad( im, jm, km, u, u_ae, v, v_ae, pt, pt_ae, delp, delp_ae, pe, pe_ae, pk, pk_ae, pkz, pkz_ae, phis, ng_d, &
&ng_s, cp, te0_ad, te, te_ad, dz, dz_ad, jfirst, jlast )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: cp
integer :: im
integer :: jfirst
integer :: jlast
integer :: km
real(kind=r8) :: delp(im,jfirst:jlast,km)
real(kind=r8) :: delp_ae(im,jfirst:jlast,km)
real(kind=r8) :: dz(im,jfirst:jlast,km)
real(kind=r8) :: dz_ad(im,jfirst:jlast,km)
integer :: jm
integer :: ng_d
integer :: ng_s
real(kind=r8) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8) :: phis(im,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8) :: pkz(im,jfirst:jlast,km)
real(kind=r8) :: pkz_ae(im,jfirst:jlast,km)
real(kind=r8) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: pt_ae(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: te(im,jfirst:jlast,km)
real(kind=r8) :: te0_ad
real(kind=r8) :: te_ad(im,jfirst:jlast,km)
real(kind=r8) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: u_ae(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: v_ae(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: bte_ad(im)
real(kind=r8) :: gztop(im)
real(kind=r8) :: gztop_ad(im)
integer :: i
integer :: j
integer :: jn2g0
integer :: js2g0
integer :: k
#ifdef USE_OPENMP
real(kind=r8) :: pe_aeh(im,km+1,jfirst:jlast)
real(kind=r8) :: pk_aeh(im,jfirst:jlast,km+1)
real(kind=r8) :: te_adh(im,jfirst:jlast,km)
#endif /* ! USE_OPENMP */
real(kind=r8) :: te_np
real(kind=r8) :: te_np_ad
real(kind=r8) :: te_sp
real(kind=r8) :: te_sp_ad
real(kind=r8) :: tte_ad(jfirst:jlast)
real(kind=r8) :: u2(im,jfirst:jlast+1)
real(kind=r8) :: u2_ad(im,jfirst:jlast+1)
real(kind=r8) :: v2(im,jfirst:jlast)
real(kind=r8) :: v2_ad(im,jfirst:jlast)
real(kind=r8) :: xsum_ad

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
bte_ad(:) = 0.d0
gztop_ad(:) = 0.d0
te_np_ad = 0.d0
te_sp_ad = 0.d0
tte_ad(:) = 0.d0
u2_ad(:,:) = 0.d0
v2_ad(:,:) = 0.d0
xsum_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
js2g0 = max(2,jfirst)
jn2g0 = min(jm-1,jlast)
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = jfirst, jlast
    do i = 1, im
      dz(i,j,k) = cp*pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
    end do
  end do
end do
call par_vecsum_ad( jm,jfirst,jlast,tte_ad,te0_ad )
#ifdef USE_OPENMP
pe_aeh(:,:,:) = pe_ae(:,:,:)
te_adh(:,:,:) = te_ad(:,:,:)
!$omp parallel do shared(acap,cosp,dz,dz_ad,im,jfirst,jlast,jm,km,pe,pe_aeh,phis,te_adh,tte_ad) private(bte_ad,gztop,gztop_ad,i,j,&
!$omp& k,pe_ae,te_ad,xsum_ad)
#endif /* ! USE_OPENMP */
do j = jfirst, jlast
#ifdef USE_OPENMP
!AOO  pe_ae(:,:,:) = 0.d0
!AOO  te_ad(:,:,:) = 0.d0
  pe_ae(:,:,j) = 0.d0
  te_ad(:,j,:) = 0.d0
#endif /* ! USE_OPENMP */
  bte_ad(:) = 0.d0
  gztop_ad(:) = 0.d0
  xsum_ad = 0.d0
  do i = 1, im
    gztop(i) = phis(i,j)
    do k = 1, km
      gztop(i) = gztop(i)+dz(i,j,k)
    end do
  end do
  if (j .eq. 1) then
    tte_ad(1) = tte_ad(1)*acap
    do k = 1, km
      te_ad(1,1,k) = te_ad(1,1,k)+tte_ad(1)
    end do
    gztop_ad(1) = gztop_ad(1)-tte_ad(1)*pe(1,1,1)
    pe_ae(1,km+1,1) = pe_ae(1,km+1,1)+tte_ad(1)*phis(1,1)
    pe_ae(1,1,1) = pe_ae(1,1,1)-tte_ad(1)*gztop(1)
    tte_ad(1) = 0.d0
  else if (j .eq. jm) then
    tte_ad(jm) = tte_ad(jm)*acap
    do k = 1, km
      te_ad(1,jm,k) = te_ad(1,jm,k)+tte_ad(jm)
    end do
    gztop_ad(1) = gztop_ad(1)-tte_ad(jm)*pe(1,1,jm)
    pe_ae(1,km+1,jm) = pe_ae(1,km+1,jm)+tte_ad(jm)*phis(1,jm)
    pe_ae(1,1,jm) = pe_ae(1,1,jm)-tte_ad(jm)*gztop(1)
    tte_ad(jm) = 0.d0
  else
    xsum_ad = xsum_ad+tte_ad(j)*cosp(j)
    tte_ad(j) = 0.d0
    do i = 1, im
      bte_ad(i) = bte_ad(i)+xsum_ad
    end do
    xsum_ad = 0.d0
    do k = km, 1, -1
      do i = 1, im
        te_ad(i,j,k) = te_ad(i,j,k)+bte_ad(i)
      end do
    end do
    do i = 1, im
      gztop_ad(i) = gztop_ad(i)-bte_ad(i)*pe(i,1,j)
      pe_ae(i,km+1,j) = pe_ae(i,km+1,j)+bte_ad(i)*phis(i,j)
      pe_ae(i,1,j) = pe_ae(i,1,j)-bte_ad(i)*gztop(i)
      bte_ad(i) = 0.d0
    end do
  endif
  do i = 1, im
    do k = 1, km
      dz_ad(i,j,k) = dz_ad(i,j,k)+gztop_ad(i)
    end do
    gztop_ad(i) = 0.d0
  end do
#ifdef USE_OPENMP
!AOO  !$omp critical  (adtaf)
!AOO  pe_aeh(:,:,:) = pe_aeh(:,:,:)+pe_ae(:,:,:)
!AOO  te_adh(:,:,:) = te_adh(:,:,:)+te_ad(:,:,:)
  pe_aeh(:,:,j) = pe_aeh(:,:,j)+pe_ae(:,:,j)
  te_adh(:,j,:) = te_adh(:,j,:)+te_ad(:,j,:)
!AOO  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
pe_ae(:,:,:) = pe_aeh(:,:,:)
te_ad(:,:,:) = te_adh(:,:,:)
pk_aeh(:,:,:) = pk_ae(:,:,:)
!AOO!$omp parallel do shared(cp,delp,delp_ae,dz_ad,im,jfirst,jlast,jm,jn2g0,js2g0,km,pk,pk_aeh,pkz,pkz_ae,pt,pt_ae,te,te_ad,u,u_ae,v,&
!AOO!$omp& v_ae) private(i,j,k,pk_ae,te_np,te_np_ad,te_sp,te_sp_ad,u2,u2_ad,v2,v2_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
#ifdef USE_OPENMP
!AOO  pk_ae(:,:,:) = 0.d0
  pk_ae(:,:,k  ) = 0.d0
  pk_ae(:,:,k+1) = 0.d0
#endif /* ! USE_OPENMP */
  te_np_ad = 0.d0
  te_sp_ad = 0.d0
  u2_ad(:,:) = 0.d0
  v2_ad(:,:) = 0.d0
  do j = js2g0, min(jlast+1,jm)
    do i = 1, im
      u2(i,j) = u(i,j,k)**2
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      v2(i,j) = v(i,j,k)**2
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im-1
      te(i,j,k) = 0.25*(u2(i,j)+u2(i,j+1)+v2(i,j)+v2(i+1,j))
    end do
    te(im,j,k) = 0.25*(u2(im,j)+u2(im,j+1)+v2(im,j)+v2(1,j))
  end do
  do j = jfirst, jlast
    do i = 1, im
      pk_ae(i,j,k+1) = pk_ae(i,j,k+1)+dz_ad(i,j,k)*cp*pt(i,j,k)
      pk_ae(i,j,k) = pk_ae(i,j,k)-dz_ad(i,j,k)*cp*pt(i,j,k)
      pt_ae(i,j,k) = pt_ae(i,j,k)+dz_ad(i,j,k)*cp*(pk(i,j,k+1)-pk(i,j,k))
      dz_ad(i,j,k) = 0.d0
    end do
  end do
  if (jlast .eq. jm) then
    te_np = 0.
    do i = 1, im
      te_np = te_np+u2(i,jm)+v2(i,jm-1)
    end do
    do i = 1, im
      te_np_ad = te_np_ad+te_ad(i,jm,k)
      te_ad(i,jm,k) = 0.d0
    end do
    delp_ae(1,jm,k) = delp_ae(1,jm,k)+te_np_ad*(0.5*te_np/float(im)+cp*pt(1,jm,k)*pkz(1,jm,k))
    pkz_ae(1,jm,k) = pkz_ae(1,jm,k)+te_np_ad*delp(1,jm,k)*cp*pt(1,jm,k)
    pt_ae(1,jm,k) = pt_ae(1,jm,k)+te_np_ad*delp(1,jm,k)*cp*pkz(1,jm,k)
    te_np_ad = te_np_ad*delp(1,jm,k)*(0.5/float(im))
    do i = 1, im
      u2_ad(i,jm) = u2_ad(i,jm)+te_np_ad
      v2_ad(i,jm-1) = v2_ad(i,jm-1)+te_np_ad
    end do
    te_np_ad = 0.d0
  endif
  if (jfirst .eq. 1) then
    te_sp = 0.
    do i = 1, im
      te_sp = te_sp+u2(i,2)+v2(i,2)
    end do
    do i = 1, im
      te_sp_ad = te_sp_ad+te_ad(i,1,k)
      te_ad(i,1,k) = 0.d0
    end do
    delp_ae(1,1,k) = delp_ae(1,1,k)+te_sp_ad*(0.5*te_sp/float(im)+cp*pt(1,1,k)*pkz(1,1,k))
    pkz_ae(1,1,k) = pkz_ae(1,1,k)+te_sp_ad*delp(1,1,k)*cp*pt(1,1,k)
    pt_ae(1,1,k) = pt_ae(1,1,k)+te_sp_ad*delp(1,1,k)*cp*pkz(1,1,k)
    te_sp_ad = te_sp_ad*delp(1,1,k)*(0.5/float(im))
    do i = 1, im
      u2_ad(i,2) = u2_ad(i,2)+te_sp_ad
      v2_ad(i,2) = v2_ad(i,2)+te_sp_ad
    end do
    te_sp_ad = 0.d0
  endif
  do j = js2g0, jn2g0
    do i = 1, im
      delp_ae(i,j,k) = delp_ae(i,j,k)+te_ad(i,j,k)*(te(i,j,k)+cp*pt(i,j,k)*pkz(i,j,k))
      pkz_ae(i,j,k) = pkz_ae(i,j,k)+te_ad(i,j,k)*delp(i,j,k)*cp*pt(i,j,k)
      pt_ae(i,j,k) = pt_ae(i,j,k)+te_ad(i,j,k)*delp(i,j,k)*cp*pkz(i,j,k)
      te_ad(i,j,k) = te_ad(i,j,k)*delp(i,j,k)
    end do
  end do
  do j = js2g0, jn2g0
    u2_ad(im,j+1) = u2_ad(im,j+1)+0.25*te_ad(im,j,k)
    u2_ad(im,j) = u2_ad(im,j)+0.25*te_ad(im,j,k)
    v2_ad(im,j) = v2_ad(im,j)+0.25*te_ad(im,j,k)
    v2_ad(1,j) = v2_ad(1,j)+0.25*te_ad(im,j,k)
    te_ad(im,j,k) = 0.d0
    do i = 1, im-1
      u2_ad(i,j+1) = u2_ad(i,j+1)+0.25*te_ad(i,j,k)
      u2_ad(i,j) = u2_ad(i,j)+0.25*te_ad(i,j,k)
      v2_ad(i+1,j) = v2_ad(i+1,j)+0.25*te_ad(i,j,k)
      v2_ad(i,j) = v2_ad(i,j)+0.25*te_ad(i,j,k)
      te_ad(i,j,k) = 0.d0
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      v_ae(i,j,k) = v_ae(i,j,k)+2*v2_ad(i,j)*v(i,j,k)
      v2_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, min(jlast+1,jm)
    do i = 1, im
      u_ae(i,j,k) = u_ae(i,j,k)+2*u2_ad(i,j)*u(i,j,k)
      u2_ad(i,j) = 0.d0
    end do
  end do
#ifdef USE_OPENMP
!AOO  !$omp critical  (adtaf)
!AOO  pk_aeh(:,:,:) = pk_aeh(:,:,:)+pk_ae(:,:,:)
  pk_aeh(:,:,k  ) = pk_aeh(:,:,k  )+pk_ae(:,:,k  )
  pk_aeh(:,:,k+1) = pk_aeh(:,:,k+1)+pk_ae(:,:,k+1)
!AOO  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
pk_ae(:,:,:) = pk_aeh(:,:,:)
#endif /* ! USE_OPENMP */

end subroutine benergy_do_ad


end module     benergy_ad


#endif /* SPMD */
