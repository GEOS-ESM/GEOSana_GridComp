#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine upol5_ad( u_ae, v_ae, im, jm, coslon, sinlon, cosl5, sinl5, jfirst, jlast )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
real(kind=r8) :: cosl5(im)
real(kind=r8) :: coslon(im)
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: sinl5(im)
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u_ae(im,jfirst:jlast)
real(kind=r8) :: v_ae(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: imh
real(kind=r8) :: r2im
real(kind=r8) :: uanp_ad(im)
real(kind=r8) :: uasp_ad(im)
real(kind=r8) :: un_ad
real(kind=r8) :: us_ad
real(kind=r8) :: vanp_ad(im)
real(kind=r8) :: vasp_ad(im)
real(kind=r8) :: vn_ad
real(kind=r8) :: vs_ad

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
uanp_ad(:) = 0.d0
uasp_ad(:) = 0.d0
un_ad = 0.d0
us_ad = 0.d0
vanp_ad(:) = 0.d0
vasp_ad(:) = 0.d0
vn_ad = 0.d0
vs_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
imh = im/2
r2im = 0.5d0/dble(im)
if (jlast .eq. jm) then
  do i = 1, imh
    u_ae(i,jm) = u_ae(i,jm)-u_ae(i+imh,jm)
    u_ae(i+imh,jm) = 0.d0
    un_ad = un_ad-u_ae(i,jm)*sinl5(i)
    vn_ad = vn_ad+u_ae(i,jm)*cosl5(i)
    u_ae(i,jm) = 0.d0
  end do
  vn_ad = vn_ad*r2im
  un_ad = un_ad*r2im
  do i = 1, imh
    uanp_ad(i+imh) = uanp_ad(i+imh)-vn_ad*coslon(i)
    uanp_ad(i) = uanp_ad(i)+vn_ad*coslon(i)
    vanp_ad(i+imh) = vanp_ad(i+imh)+vn_ad*sinlon(i)
    vanp_ad(i) = vanp_ad(i)-vn_ad*sinlon(i)
    uanp_ad(i+imh) = uanp_ad(i+imh)+un_ad*sinlon(i)
    uanp_ad(i) = uanp_ad(i)-un_ad*sinlon(i)
    vanp_ad(i+imh) = vanp_ad(i+imh)+un_ad*coslon(i)
    vanp_ad(i) = vanp_ad(i)-un_ad*coslon(i)
  end do
  do i = 1, im
    v_ae(i,jm-1) = v_ae(i,jm-1)+vanp_ad(i)
    v_ae(i,jm) = v_ae(i,jm)+vanp_ad(i)
    vanp_ad(i) = 0.d0
  end do
  u_ae(im,jm-1) = u_ae(im,jm-1)+uanp_ad(im)
  u_ae(1,jm-1) = u_ae(1,jm-1)+uanp_ad(im)
  uanp_ad(im) = 0.d0
  do i = 1, im-1
    u_ae(i+1,jm-1) = u_ae(i+1,jm-1)+uanp_ad(i)
    u_ae(i,jm-1) = u_ae(i,jm-1)+uanp_ad(i)
    uanp_ad(i) = 0.d0
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, imh
    u_ae(i,1) = u_ae(i,1)-u_ae(i+imh,1)
    u_ae(i+imh,1) = 0.d0
    us_ad = us_ad-u_ae(i,1)*sinl5(i)
    vs_ad = vs_ad-u_ae(i,1)*cosl5(i)
    u_ae(i,1) = 0.d0
  end do
  vs_ad = vs_ad*r2im
  us_ad = us_ad*r2im
  do i = 1, imh
    uasp_ad(i+imh) = uasp_ad(i+imh)+vs_ad*coslon(i)
    uasp_ad(i) = uasp_ad(i)-vs_ad*coslon(i)
    vasp_ad(i+imh) = vasp_ad(i+imh)+vs_ad*sinlon(i)
    vasp_ad(i) = vasp_ad(i)-vs_ad*sinlon(i)
    uasp_ad(i+imh) = uasp_ad(i+imh)+us_ad*sinlon(i)
    uasp_ad(i) = uasp_ad(i)-us_ad*sinlon(i)
    vasp_ad(i+imh) = vasp_ad(i+imh)-us_ad*coslon(i)
    vasp_ad(i) = vasp_ad(i)+us_ad*coslon(i)
  end do
  do i = 1, im
    v_ae(i,3) = v_ae(i,3)+vasp_ad(i)
    v_ae(i,2) = v_ae(i,2)+vasp_ad(i)
    vasp_ad(i) = 0.d0
  end do
  u_ae(im,2) = u_ae(im,2)+uasp_ad(im)
  u_ae(1,2) = u_ae(1,2)+uasp_ad(im)
  uasp_ad(im) = 0.d0
  do i = 1, im-1
    u_ae(i+1,2) = u_ae(i+1,2)+uasp_ad(i)
    u_ae(i,2) = u_ae(i,2)+uasp_ad(i)
    uasp_ad(i) = 0.d0
  end do
endif

end subroutine upol5_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine upol5_ad( u_ae, v_ae, im, jm, coslon, sinlon, cosl5, sinl5, jfirst, jlast )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
real(kind=r8) :: cosl5(im)
real(kind=r8) :: coslon(im)
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: sinl5(im)
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u_ae(im,jfirst:jlast)
real(kind=r8) :: v_ae(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: imh
real(kind=r8) :: r2im
real(kind=r8) :: uanp_ad(im)
real(kind=r8) :: uasp_ad(im)
real(kind=r8) :: un_ad
real(kind=r8) :: us_ad
real(kind=r8) :: vanp_ad(im)
real(kind=r8) :: vasp_ad(im)
real(kind=r8) :: vn_ad
real(kind=r8) :: vs_ad

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
uanp_ad(:) = 0.d0
uasp_ad(:) = 0.d0
un_ad = 0.d0
us_ad = 0.d0
vanp_ad(:) = 0.d0
vasp_ad(:) = 0.d0
vn_ad = 0.d0
vs_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
imh = im/2
r2im = 0.5d0/dble(im)
if (jlast .eq. jm) then
  do i = 1, imh
    u_ae(i,jm) = u_ae(i,jm)-u_ae(i+imh,jm)
    u_ae(i+imh,jm) = 0.d0
    un_ad = un_ad-u_ae(i,jm)*sinl5(i)
    vn_ad = vn_ad+u_ae(i,jm)*cosl5(i)
    u_ae(i,jm) = 0.d0
  end do
  vn_ad = vn_ad*r2im
  un_ad = un_ad*r2im
  do i = 1, imh
    uanp_ad(i+imh) = uanp_ad(i+imh)-vn_ad*coslon(i)
    uanp_ad(i) = uanp_ad(i)+vn_ad*coslon(i)
    vanp_ad(i+imh) = vanp_ad(i+imh)+vn_ad*sinlon(i)
    vanp_ad(i) = vanp_ad(i)-vn_ad*sinlon(i)
    uanp_ad(i+imh) = uanp_ad(i+imh)+un_ad*sinlon(i)
    uanp_ad(i) = uanp_ad(i)-un_ad*sinlon(i)
    vanp_ad(i+imh) = vanp_ad(i+imh)+un_ad*coslon(i)
    vanp_ad(i) = vanp_ad(i)-un_ad*coslon(i)
  end do
  do i = 1, im
    v_ae(i,jm-1) = v_ae(i,jm-1)+vanp_ad(i)
    v_ae(i,jm) = v_ae(i,jm)+vanp_ad(i)
    vanp_ad(i) = 0.d0
  end do
  u_ae(im,jm-1) = u_ae(im,jm-1)+uanp_ad(im)
  u_ae(1,jm-1) = u_ae(1,jm-1)+uanp_ad(im)
  uanp_ad(im) = 0.d0
  do i = 1, im-1
    u_ae(i+1,jm-1) = u_ae(i+1,jm-1)+uanp_ad(i)
    u_ae(i,jm-1) = u_ae(i,jm-1)+uanp_ad(i)
    uanp_ad(i) = 0.d0
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, imh
    u_ae(i,1) = u_ae(i,1)-u_ae(i+imh,1)
    u_ae(i+imh,1) = 0.d0
    us_ad = us_ad-u_ae(i,1)*sinl5(i)
    vs_ad = vs_ad-u_ae(i,1)*cosl5(i)
    u_ae(i,1) = 0.d0
  end do
  vs_ad = vs_ad*r2im
  us_ad = us_ad*r2im
  do i = 1, imh
    uasp_ad(i+imh) = uasp_ad(i+imh)+vs_ad*coslon(i)
    uasp_ad(i) = uasp_ad(i)-vs_ad*coslon(i)
    vasp_ad(i+imh) = vasp_ad(i+imh)+vs_ad*sinlon(i)
    vasp_ad(i) = vasp_ad(i)-vs_ad*sinlon(i)
    uasp_ad(i+imh) = uasp_ad(i+imh)+us_ad*sinlon(i)
    uasp_ad(i) = uasp_ad(i)-us_ad*sinlon(i)
    vasp_ad(i+imh) = vasp_ad(i+imh)-us_ad*coslon(i)
    vasp_ad(i) = vasp_ad(i)+us_ad*coslon(i)
  end do
  do i = 1, im
    v_ae(i,3) = v_ae(i,3)+vasp_ad(i)
    v_ae(i,2) = v_ae(i,2)+vasp_ad(i)
    vasp_ad(i) = 0.d0
  end do
  u_ae(im,2) = u_ae(im,2)+uasp_ad(im)
  u_ae(1,2) = u_ae(1,2)+uasp_ad(im)
  uasp_ad(im) = 0.d0
  do i = 1, im-1
    u_ae(i+1,2) = u_ae(i+1,2)+uasp_ad(i)
    u_ae(i,2) = u_ae(i,2)+uasp_ad(i)
    uasp_ad(i) = 0.d0
  end do
endif

end subroutine upol5_ad


#endif /* SPMD */
