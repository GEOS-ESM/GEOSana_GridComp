#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine pft2d_ad( p_ad, s, damp, im, jp, ifax, trigs, q1_ad, q2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: jp
real(kind=r8) :: damp(im,jp)
integer :: ifax(13)
real(kind=r8) :: p_ad(im,jp)
real(kind=r8) :: q1_ad(im+2,*)
real(kind=r8) :: q2(*)
real(kind=r8) :: s(jp)
real(kind=r8) :: trigs(3*im/2+1)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: bt
integer :: help_h
integer :: help_i
integer :: help_j
integer :: i
integer :: j
integer :: jf(jp)
integer :: n
integer :: nj
real(kind=r8) :: ptmp_ad(0:im+1)
real(kind=r8) :: rsc

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
ptmp_ad(:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
nj = 0
do j = 1, jp
  if (s(j) .gt. 1.01 .and. s(j) .le. 4.) then
  else if (s(j) .gt. 4.) then
    nj = nj+1
    jf(nj) = j
  endif
end do
if (nj .ne. 0) then
  help_h = im+2
  help_i = -1
  help_j = im+2
  do n = 1, nj
    do i = 1, im
      q1_ad(i,n) = q1_ad(i,n)+p_ad(i,jf(n))
      p_ad(i,jf(n)) = 0.d0
    end do
  end do
  call adrfftmlt( q1_ad,q2,trigs,ifax,1,help_j,im,nj,1 )
  do n = 1, nj
    do i = 5, im+2
      q1_ad(i,n) = q1_ad(i,n)*damp(i-2,jf(n))
    end do
  end do
  call adrfftmlt( q1_ad,q2,trigs,ifax,1,help_h,im,nj,help_i )
endif
nj = 0
do j = 1, jp
  if (s(j) .gt. 1.01 .and. s(j) .le. 4.) then
    rsc = 1./s(j)
    bt = 0.5*(s(j)-1.)
    do i = 1, im
      ptmp_ad(i-1) = ptmp_ad(i-1)+p_ad(i,j)*rsc*bt
      ptmp_ad(i+1) = ptmp_ad(i+1)+p_ad(i,j)*rsc*bt
      ptmp_ad(i) = ptmp_ad(i)+p_ad(i,j)*rsc
      p_ad(i,j) = 0.d0
    end do
    p_ad(im,j) = p_ad(im,j)+ptmp_ad(0)
    ptmp_ad(0) = 0.d0
    p_ad(1,j) = p_ad(1,j)+ptmp_ad(im+1)
    ptmp_ad(im+1) = 0.d0
    do i = 1, im
      p_ad(i,j) = p_ad(i,j)+ptmp_ad(i)
      ptmp_ad(i) = 0.d0
    end do
  else if (s(j) .gt. 4.) then
    nj = nj+1
    q1_ad(im+2,nj) = 0.d0
    q1_ad(im+1,nj) = 0.d0
    do i = 1, im
      p_ad(i,j) = p_ad(i,j)+q1_ad(i,nj)
      q1_ad(i,nj) = 0.d0
    end do
  endif
end do

end subroutine pft2d_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine pft2d_ad( p_ad, s, damp, im, jp, ifax, trigs, q1_ad, q2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: jp
real(kind=r8) :: damp(im,jp)
integer :: ifax(13)
real(kind=r8) :: p_ad(im,jp)
real(kind=r8) :: q1_ad(im+2,*)
real(kind=r8) :: q2(*)
real(kind=r8) :: s(jp)
real(kind=r8) :: trigs(3*im/2+1)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: bt
integer :: help_h
integer :: help_i
integer :: help_j
integer :: i
integer :: j
integer :: jf(jp)
integer :: n
integer :: nj
real(kind=r8) :: ptmp_ad(0:im+1)
real(kind=r8) :: rsc

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
ptmp_ad(:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
nj = 0
do j = 1, jp
  if (s(j) .gt. 1.01 .and. s(j) .le. 4.) then
  else if (s(j) .gt. 4.) then
    nj = nj+1
    jf(nj) = j
  endif
end do
if (nj .ne. 0) then
  help_h = im+2
  help_i = -1
  help_j = im+2
  do n = 1, nj
    do i = 1, im
      q1_ad(i,n) = q1_ad(i,n)+p_ad(i,jf(n))
      p_ad(i,jf(n)) = 0.d0
    end do
  end do
  call adrfftmlt( q1_ad,q2,trigs,ifax,1,help_j,im,nj,1 )
  do n = 1, nj
    do i = 5, im+2
      q1_ad(i,n) = q1_ad(i,n)*damp(i-2,jf(n))
    end do
  end do
  call adrfftmlt( q1_ad,q2,trigs,ifax,1,help_h,im,nj,help_i )
endif
nj = 0
do j = 1, jp
  if (s(j) .gt. 1.01 .and. s(j) .le. 4.) then
    rsc = 1./s(j)
    bt = 0.5*(s(j)-1.)
    do i = 1, im
      ptmp_ad(i-1) = ptmp_ad(i-1)+p_ad(i,j)*rsc*bt
      ptmp_ad(i+1) = ptmp_ad(i+1)+p_ad(i,j)*rsc*bt
      ptmp_ad(i) = ptmp_ad(i)+p_ad(i,j)*rsc
      p_ad(i,j) = 0.d0
    end do
    p_ad(im,j) = p_ad(im,j)+ptmp_ad(0)
    ptmp_ad(0) = 0.d0
    p_ad(1,j) = p_ad(1,j)+ptmp_ad(im+1)
    ptmp_ad(im+1) = 0.d0
    do i = 1, im
      p_ad(i,j) = p_ad(i,j)+ptmp_ad(i)
      ptmp_ad(i) = 0.d0
    end do
  else if (s(j) .gt. 4.) then
    nj = nj+1
    q1_ad(im+2,nj) = 0.d0
    q1_ad(im+1,nj) = 0.d0
    do i = 1, im
      p_ad(i,j) = p_ad(i,j)+q1_ad(i,nj)
      q1_ad(i,nj) = 0.d0
    end do
  endif
end do

end subroutine pft2d_ad


#endif /* SPMD */
