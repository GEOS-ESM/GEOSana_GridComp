#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     cd_core_do_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: cd_core_tape_cd_core_do
real(kind=8), allocatable :: cd_core_tape_delp_17h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_delp_4h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_delpf_3h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_10h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_21h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_23h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_8h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pt_16h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pt_18h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pt_5h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_ptc_6h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_ptk_7h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_u_12h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_u_1h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_uc_14h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_v_13h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_v_2h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_vc_15h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz3_25h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_11h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_22h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_24h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_9h(:,:,:,:)

end module     cd_core_do_ad_store


module     cd_core_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use cd_core

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine cd_core_do_ad( im, jm, km, nq, nx, jfirst, jlast, u, u_ae, v, v_ae, pt, pt_ae, delp, delp_ae, pe_ae, pk_ae, ns, ptop, &
&rcap, cp, akap, iord_c, jord_c, iord_d, jord_d, ng_c, ng_d, ng_s, ipe, cosp, cose, acosp, sinlon, coslon, cosl5, sinl5, cx3_ad, &
&cy3_ad, mfx_ad, mfy_ad, delpf, delpf_ad, uc, uc_ad, vc, vc_ad, ptc, ptc_ad, dpt, dpt_ad, ptk, ptk_ad, wz3, wz3_ad, pkc, pkc_ad, &
&wz, wz_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use sw_core
use sw_core_ad
use tp_core
use tp_core_ad
#ifdef TIMING
use timingmodule
#endif
use mod_comm, only : gid,gsize,mp_barrier, mp_recv2_ns, mp_recv2_ns_ad, mp_recv2_s, mp_recv2_s_ad, mp_recv3d_ns, mp_recv3d_ns2, &
&mp_recv3d_ns_ad, mp_recv_n, mp_recv_n_ad, mp_send2_n, mp_send2_n_ad, mp_send2_ns, mp_send2_ns_ad, mp_send3d_ns, mp_send3d_ns2, &
&mp_send3d_ns_ad, mp_send_s, mp_send_s_ad
use cd_core_do_ad_store, only : cd_core_tape_cd_core_do,cd_core_tape_delp_17h,cd_core_tape_delp_4h,cd_core_tape_delpf_3h,&
&cd_core_tape_pkc_10h,cd_core_tape_pkc_21h,cd_core_tape_pkc_23h,cd_core_tape_pkc_8h,cd_core_tape_pt_16h,cd_core_tape_pt_18h,&
&cd_core_tape_pt_5h,cd_core_tape_ptc_6h,cd_core_tape_ptk_7h,cd_core_tape_u_12h,cd_core_tape_u_1h,cd_core_tape_uc_14h,&
&cd_core_tape_v_13h,cd_core_tape_v_2h,cd_core_tape_vc_15h,cd_core_tape_wz3_25h,cd_core_tape_wz_11h,cd_core_tape_wz_22h,&
&cd_core_tape_wz_24h,cd_core_tape_wz_9h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real(kind=r8), parameter :: tiny = 1.e-10

!==============================================
! declare arguments
!==============================================
integer :: jm
real(kind=r8) :: acosp(jm)
real(kind=r8) :: akap
real(kind=r8) :: cose(jm)
integer :: im
real(kind=r8) :: cosl5(im)
real(kind=r8) :: coslon(im)
real(kind=r8) :: cosp(jm)
real(kind=r8) :: cp
integer :: jfirst
integer :: jlast
integer :: km
integer :: ng_d
real(kind=r8) :: cx3_ad(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: cy3_ad(im,jfirst:jlast+1,km)
real(kind=r8) :: delp(im,jfirst:jlast,km)
real(kind=r8) :: delp_ae(im,jfirst:jlast,km)
real(kind=r8) :: delpf(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: delpf_ad(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: dpt(im,jfirst-1:jlast+1,km)
real(kind=r8) :: dpt_ad(im,jfirst-1:jlast+1,km)
integer :: iord_c
integer :: iord_d
integer :: ipe
integer :: jord_c
integer :: jord_d
real(kind=r8) :: mfx_ad(im,jfirst:jlast,km)
real(kind=r8) :: mfy_ad(im,jfirst:jlast+1,km)
integer :: ng_c
integer :: ng_s
integer :: nq
integer :: ns
integer :: nx
real(kind=r8) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8) :: pkc(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: pkc_ad(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: pt_ae(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: ptc(im,jfirst:jlast,km)
real(kind=r8) :: ptc_ad(im,jfirst:jlast,km)
real(kind=r8) :: ptk(im,jfirst:jlast,km)
real(kind=r8) :: ptk_ad(im,jfirst:jlast,km)
real(kind=r8) :: ptop
real(kind=r8) :: rcap
real(kind=r8) :: sinl5(im)
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: u_ae(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: uc(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: uc_ad(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: v_ae(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: vc(im,jfirst-2:jlast+2,km)
real(kind=r8) :: vc_ad(im,jfirst-2:jlast+2,km)
real(kind=r8) :: wz(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: wz3(im,jfirst-1:jlast,km+1)
real(kind=r8) :: wz3_ad(im,jfirst-1:jlast,km+1)
real(kind=r8) :: wz_ad(im,jfirst-1:jlast+1,km+1)

!==============================================
! declare local variables
!==============================================
integer :: c_sw_tape_rec
integer :: d_sw_tape_rec
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_l
integer :: help_m
integer :: help_n
integer :: help_o
integer :: help_p
integer :: help_q
integer :: i
integer :: iord
integer :: j
integer :: jn1g1
integer :: jn1gc
integer :: jn2g0
integer :: jord
integer :: js1g1
integer :: js2g0
integer :: js2g1
integer :: js2gc
integer :: k
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1d_ad(im)
#ifdef USE_OPENMP
real(kind=r8) :: pkc_adh(im,jfirst-1:jlast+1,km+1)
#endif /* ! USE_OPENMP */
real(kind=r8) :: pkchelp_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: wk(im,jfirst:jlast+2)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: wk1_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: wk2(im,jfirst:jlast+1)
real(kind=r8) :: wk2_ad(im,jfirst:jlast+1)
real(kind=r8) :: wk3_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: wk_ad(im,jfirst:jlast+2)
#ifdef USE_OPENMP
real(kind=r8) :: wz_adh(im,jfirst-1:jlast+1,km+1)
#endif /* ! USE_OPENMP */

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
p1d_ad(:) = 0.d0
pkchelp_ad(:,:) = 0.d0
wk1_ad(:,:) = 0.d0
wk2_ad(:,:) = 0.d0
wk3_ad(:,:) = 0.d0
wk_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
js1g1 = max(1,jfirst-1)
js2g0 = max(2,jfirst)
js2g1 = max(2,jfirst-1)
jn2g0 = min(jm-1,jlast)
jn1g1 = min(jm,jlast+1)
js2gc = max(2,jfirst-ng_c)
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc = max(2,jfirst-2)
endif
jn1gc = min(jm,jlast+ng_c)
ptc = cd_core_tape_ptc_6h(:,:,:,cd_core_tape_rec+1)
ptk = cd_core_tape_ptk_7h(:,:,:,cd_core_tape_rec+1)
help_i = km+1
help_k = km+1
u = cd_core_tape_u_12h(:,:,:,cd_core_tape_rec+1)
v = cd_core_tape_v_13h(:,:,:,cd_core_tape_rec+1)
uc = cd_core_tape_uc_14h(:,:,:,cd_core_tape_rec+1)
vc = cd_core_tape_vc_15h(:,:,:,cd_core_tape_rec+1)
delp = cd_core_tape_delp_17h(:,:,:,cd_core_tape_rec+1)
pt = cd_core_tape_pt_18h(:,:,:,cd_core_tape_rec+1)
help_m = km+1
help_o = km+1
pkc = cd_core_tape_pkc_21h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_22h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js1g1, jn1g1
    do i = 1, im
      dpt(i,j,k) = (wz(i,j,k+1)+wz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j,k))
    end do
  end do
end do
pkc = cd_core_tape_pkc_23h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_24h(:,:,:,cd_core_tape_rec+1)
wz3 = cd_core_tape_wz3_25h(:,:,:,cd_core_tape_rec+1)
if (ipe .ne. 1) then
#ifdef TIMING
  call adtiming_off( 'Recv_pt&delpf' )
#endif
  call mp_recv3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf_ad,2 )
  call mp_recv3d_ns_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt_ae,1 )
#ifdef TIMING
  call adtiming_on( 'Recv_pt&delpf' )
#endif
endif
#ifdef TIMING
call adtiming_off( 'D-6000' )
#endif
#ifdef USE_OPENMP
!$omp parallel do shared(dc,de,dpt,dpt_ad,dtdxe,dtdy,ifax,im,jfirst,jlast,jm,jn1g1,jn2g0,js2g0,km,pkc,pkc_ad,sc,se,trigs,u_ae,&
!$omp& uc_ad,v_ae,vc_ad,wz,wz3,wz3_ad,wz_ad) private(help_p,help_q,i,j,k,wk,wk1,wk1_ad,wk2,wk2_ad,wk3_ad,wk_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
  wk1_ad(:,:) = 0.d0
  wk2_ad(:,:) = 0.d0
  wk3_ad(:,:) = 0.d0
  wk_ad(:,:) = 0.d0
  do j = js2g0, jn1g1
    do i = 1, im
      wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  help_p = jlast-js2g0+1
  help_q = jn2g0-js2g0+1
  do j = js2g0, jn2g0
    do i = 1, im
      wk1_ad(i,j) = wk1_ad(i,j)+v_ae(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      wk3_ad(i,j) = wk3_ad(i,j)+u_ae(i,j,k)
    end do
  end do
  call pft2d_ad( wk1_ad(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_q,ifax,trigs,wk_ad,wk2 )
  call pft2d_ad( wk3_ad(1,js2g0),se(js2g0),de(1,js2g0),im,help_p,ifax,trigs,wk_ad,wk2 )
  call avgc( dpt(1,jfirst-1,k),wk2(1,jfirst),im,jm,jfirst,jlast,wk1 )
  do j = js2g0, jn2g0
    do i = 1, im
      vc_ad(i,j,k) = vc_ad(i,j,k)+wk1_ad(i,j)
      wk_ad(i,j+1) = wk_ad(i,j+1)-wk1_ad(i,j)*dtdy/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*(wk2(i,j)-wk2(i,j+1)+wz(i,j,k+1)-wz(i,&
&j,k))
      wk_ad(i,j) = wk_ad(i,j)-wk1_ad(i,j)*dtdy/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*(wk2(i,j)-wk2(i,j+1)+wz(i,j,k+1)-wz(i,j,k))
      wk2_ad(i,j+1) = wk2_ad(i,j+1)-wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      wk2_ad(i,j) = wk2_ad(i,j)+wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      wz_ad(i,j,k+1) = wz_ad(i,j,k+1)+wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      wz_ad(i,j,k) = wz_ad(i,j,k)-wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      wk1_ad(i,j) = 0.d0
    end do
  end do
  call avgc( dpt(1,jfirst-1,k),wk2(1,jfirst),im,jm,jfirst,jlast,wk1 )
  do j = js2g0, jlast
    uc_ad(im,j,k) = uc_ad(im,j,k)+wk3_ad(im,j)
    wk_ad(im,j) = wk_ad(im,j)-wk3_ad(im,j)*dtdxe(j)/((wk(im,j)+wk(1,j))*(wk(im,j)+wk(1,j)))*(wk2(im,j)-wk2(1,j)+wz3(im,j,k+1)-&
&wz3(im,j,k))
    wk_ad(1,j) = wk_ad(1,j)-wk3_ad(im,j)*dtdxe(j)/((wk(im,j)+wk(1,j))*(wk(im,j)+wk(1,j)))*(wk2(im,j)-wk2(1,j)+wz3(im,j,k+1)-wz3(im,&
&j,k))
    wk2_ad(im,j) = wk2_ad(im,j)+wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    wk2_ad(1,j) = wk2_ad(1,j)-wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    wz3_ad(im,j,k+1) = wz3_ad(im,j,k+1)+wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    wz3_ad(im,j,k) = wz3_ad(im,j,k)-wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    wk3_ad(im,j) = 0.d0
    do i = 1, im-1
      uc_ad(i,j,k) = uc_ad(i,j,k)+wk3_ad(i,j)
      wk_ad(i+1,j) = wk_ad(i+1,j)-wk3_ad(i,j)*dtdxe(j)/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*(wk2(i,j)-wk2(i+1,j)+wz3(i,j,k+1)-&
&wz3(i,j,k))
      wk_ad(i,j) = wk_ad(i,j)-wk3_ad(i,j)*dtdxe(j)/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*(wk2(i,j)-wk2(i+1,j)+wz3(i,j,k+1)-&
&wz3(i,j,k))
      wk2_ad(i+1,j) = wk2_ad(i+1,j)-wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      wk2_ad(i,j) = wk2_ad(i,j)+wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      wz3_ad(i,j,k+1) = wz3_ad(i,j,k+1)+wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      wz3_ad(i,j,k) = wz3_ad(i,j,k)-wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      wk3_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, jn1g1
    do i = 1, im
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+wk_ad(i,j)
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-wk_ad(i,j)
      wk_ad(i,j) = 0.d0
    end do
  end do
  call avgc_ad( dpt_ad(1,jfirst-1,k),wk2_ad(1,jfirst),im,jm,jfirst,jlast,wk1_ad )
end do
#ifdef TIMING
call adtiming_on( 'D-6000' )
#endif
do j = js2g0, jn1g1
  do i = 1, im
    pkc_ad(i,j,1) = 0.d0
  end do
end do
do j = js2g0, jlast
  do i = 1, im
    wz_ad(i,j,1) = 0.d0
    wz3_ad(i,j,1) = 0.d0
  end do
end do
#ifdef TIMING
call adtiming_off( 'D-4500' )
#endif
pkc = cd_core_tape_pkc_21h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_22h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!$omp parallel do shared(im,jfirst,jlast,jm,jn1g1,jn2g0,js2g0,js2g1,km,pkc,pkc_ad,wz,wz3_ad,wz_ad) private(i,j,k,pkchelp_ad,wk1_ad,&
!$omp& wk3_ad)
#endif /* ! USE_OPENMP */
do k = 2, km+1
  pkchelp_ad(:,:) = 0.d0
  wk1_ad(:,:) = 0.d0
  wk3_ad(:,:) = 0.d0
  call avgc_ad( pkchelp_ad,pkc_ad(1,jfirst,k),im,jm,jfirst,jlast,wk1_ad )
  do j = jfirst-1, jlast+1
    do i = 1, im
      pkc_ad(i,j,k) = pkc_ad(i,j,k)+pkchelp_ad(i,j)
      pkchelp_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      wk3_ad(i,j+1) = wk3_ad(i,j+1)+wz_ad(i,j,k)
      wk3_ad(i,j) = wk3_ad(i,j)+wz_ad(i,j,k)
      wz_ad(i,j,k) = 0.d0
    end do
  end do
  do j = js2g0, jn1g1
    do i = 2, im
      wk1_ad(i-1,j) = wk1_ad(i-1,j)+wk3_ad(i,j)
      wk1_ad(i,j) = wk1_ad(i,j)+wk3_ad(i,j)
      wk3_ad(i,j) = 0.d0
    end do
    wk1_ad(im,j) = wk1_ad(im,j)+wk3_ad(1,j)
    wk1_ad(1,j) = wk1_ad(1,j)+wk3_ad(1,j)
    wk3_ad(1,j) = 0.d0
  end do
  do j = js2g0, jn1g1
    do i = 1, im
      pkc_ad(i,j-1,k) = pkc_ad(i,j-1,k)-wk1_ad(i,j)*(wz(i,j,k)+wz(i,j-1,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)+wk1_ad(i,j)*(wz(i,j,k)+wz(i,j-1,k))
      wz_ad(i,j-1,k) = wz_ad(i,j-1,k)+wk1_ad(i,j)*(pkc(i,j,k)-pkc(i,j-1,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)+wk1_ad(i,j)*(pkc(i,j,k)-pkc(i,j-1,k))
      wk1_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      wk1_ad(i,j-1) = wk1_ad(i,j-1)+wz3_ad(i,j,k)
      wk1_ad(i,j) = wk1_ad(i,j)+wz3_ad(i,j,k)
      wz3_ad(i,j,k) = 0.d0
    end do
  end do
  if (jlast .eq. jm) then
    do i = 1, im
      wk1_ad(i,jm) = 0.d0
    end do
  endif
  if (jfirst .eq. 1) then
    do i = 1, im
      wk1_ad(i,1) = 0.d0
    end do
  endif
  do j = js2g1, jn2g0
    wk3_ad(im,j) = wk3_ad(im,j)+wk1_ad(im,j)
    wk3_ad(1,j) = wk3_ad(1,j)+wk1_ad(im,j)
    wk1_ad(im,j) = 0.d0
    do i = 1, im-1
      wk3_ad(i+1,j) = wk3_ad(i+1,j)+wk1_ad(i,j)
      wk3_ad(i,j) = wk3_ad(i,j)+wk1_ad(i,j)
      wk1_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g1, jn2g0
    do i = 2, im
      pkc_ad(i-1,j,k) = pkc_ad(i-1,j,k)-wk3_ad(i,j)*(wz(i,j,k)+wz(i-1,j,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)+wk3_ad(i,j)*(wz(i,j,k)+wz(i-1,j,k))
      wz_ad(i-1,j,k) = wz_ad(i-1,j,k)+wk3_ad(i,j)*(pkc(i,j,k)-pkc(i-1,j,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)+wk3_ad(i,j)*(pkc(i,j,k)-pkc(i-1,j,k))
      wk3_ad(i,j) = 0.d0
    end do
    pkc_ad(im,j,k) = pkc_ad(im,j,k)-wk3_ad(1,j)*(wz(1,j,k)+wz(im,j,k))
    pkc_ad(1,j,k) = pkc_ad(1,j,k)+wk3_ad(1,j)*(wz(1,j,k)+wz(im,j,k))
    wz_ad(im,j,k) = wz_ad(im,j,k)+wk3_ad(1,j)*(pkc(1,j,k)-pkc(im,j,k))
    wz_ad(1,j,k) = wz_ad(1,j,k)+wk3_ad(1,j)*(pkc(1,j,k)-pkc(im,j,k))
    wk3_ad(1,j) = 0.d0
  end do
end do
#ifdef TIMING
call adtiming_on( 'D-4500' )
#endif
pkc = cd_core_tape_pkc_21h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_22h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
pkc_adh(:,:,:) = pkc_ad(:,:,:)
wz_adh(:,:,:) = wz_ad(:,:,:)
!AOO!$omp parallel do shared(dpt_ad,im,jn1g1,js1g1,km,pkc,pkc_adh,wz,wz_adh) private(i,j,k,pkc_ad,wz_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
#ifdef USE_OPENMP
!AOO  pkc_ad(:,:,:) = 0.d0
!AOO  wz_ad(:,:,:) = 0.d0
  pkc_ad(:,:,k) = 0.d0
  pkc_ad(:,:,k+1) = 0.d0
  wz_ad(:,:,k) = 0.d0
  wz_ad(:,:,k+1) = 0.d0
#endif /* ! USE_OPENMP */
  do j = js1g1, jn1g1
    do i = 1, im
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+dpt_ad(i,j,k)*(wz(i,j,k+1)+wz(i,j,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-dpt_ad(i,j,k)*(wz(i,j,k+1)+wz(i,j,k))
      wz_ad(i,j,k+1) = wz_ad(i,j,k+1)+dpt_ad(i,j,k)*(pkc(i,j,k+1)-pkc(i,j,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)+dpt_ad(i,j,k)*(pkc(i,j,k+1)-pkc(i,j,k))
      dpt_ad(i,j,k) = 0.d0
    end do
  end do
#ifdef USE_OPENMP
!AOO  !$omp critical  (adtaf)
!AOO  pkc_adh(:,:,:) = pkc_adh(:,:,:)+pkc_ad(:,:,:)
!AOO  wz_adh(:,:,:) = wz_adh(:,:,:)+wz_ad(:,:,:)
  pkc_adh(:,:,k) = pkc_adh(:,:,k)+pkc_ad(:,:,k)
  pkc_adh(:,:,k+1) = pkc_adh(:,:,k+1)+pkc_ad(:,:,k+1)
  wz_adh(:,:,k) = wz_adh(:,:,k)+wz_ad(:,:,k)
  wz_adh(:,:,k+1) = wz_adh(:,:,k+1)+wz_ad(:,:,k+1)
!AOO  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
pkc_ad(:,:,:) = pkc_adh(:,:,:)
wz_ad(:,:,:) = wz_adh(:,:,:)
#endif /* ! USE_OPENMP */
if (ipe .ne. 1) then
#ifdef TIMING
  call adtiming_off( 'Send_pt&delpf' )
#endif
  call mp_send3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf_ad,2 )
  call mp_send3d_ns_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt_ae,1 )
#ifdef TIMING
  call adtiming_on( 'Send_pt&delpf' )
#endif
endif
#ifdef TIMING
call adtiming_off( 'Recv_pkc_wz' )
#endif
call mp_recv2_ns_ad( im,jm,jfirst,jlast,1,help_o,1,pkc_ad,wz_ad )
#ifdef TIMING
call adtiming_on( 'Recv_pkc_wz' )
#endif
if (ipe .ne. 1) then
#ifdef USE_OPENMP
  !$omp parallel do shared(dc,delp_ae,delpf_ad,ifax,im,jfirst,jlast,jn2g0,js2g0,km,sc,trigs) private(help_n,i,j,k,wk2,wk_ad)
#endif /* ! USE_OPENMP */
  do k = 1, km
    wk2_ad(:,:) = 0.d0
    wk_ad(:,:) = 0.d0
    help_n = jn2g0-js2g0+1
    call pft2d_ad( delpf_ad(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_n,ifax,trigs,wk_ad,wk2 )
    do j = jfirst, jlast
      do i = 1, im
        delp_ae(i,j,k) = delp_ae(i,j,k)+delpf_ad(i,j,k)
        delpf_ad(i,j,k) = 0.d0
      end do
    end do
  end do
else
#ifdef USE_OPENMP
  !$omp parallel do shared(im,jfirst,jlast,km,pk_ae,pkc_ad) private(i,j,k)
#endif /* ! USE_OPENMP */
  do k = 1, km+1
    do j = jfirst, jlast
      do i = 1, im
        pkc_ad(i,j,k) = pkc_ad(i,j,k)+pk_ae(i,j,k)
        pk_ae(i,j,k) = 0.d0
      end do
    end do
  end do
endif
#ifdef TIMING
call adtiming_off( 'Send_pkc_wz' )
#endif
call mp_send2_ns_ad( im,jm,jfirst,jlast,1,help_m,1,pkc_ad,wz_ad )
#ifdef TIMING
call adtiming_on( 'Send_pkc_wz' )
call adtiming_off( 'D_GEOP' )
#endif
call geopk_ad( ptop,pe_ae,delp,delp_ae,pkc,pkc_ad,wz_ad,pt,pt_ae,im,km,jfirst,jlast,ng_d,cp,akap,nx,ipe, .true.  )
#ifdef TIMING
call adtiming_on( 'D_GEOP' )
call adtiming_off( 'D_CORE' )
#endif
pt = cd_core_tape_pt_16h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!$omp parallel do shared(acosp,cd_core_tape_rec,cdx,cdy,cose,cosl5,coslon,cosp,cx3_ad,cy3_ad,cyy,delp,delp_ae,delpf,delpf_ad,dtdx,&
!$omp& dtdxe,dtdy,dtdy5,dtxe5,dx,dyce,im,iord_d,jfirst,jlast,jm,jn1g1,jord_d,js2g0,km,mfx_ad,mfy_ad,ng_d,ng_s,nq,pt,pt_ae,rcap,rdx,&
!$omp& rdy,sinl5,sinlon,tdy5,txe5,u,u_ae,uc,uc_ad,v,v_ae,vc,vc_ad,zt_d) private(d_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    if (k .eq. 1) then
      iord = 1
      jord = 1
    else
      iord = min(2,iord_d)
      jord = min(2,jord_d)
    endif
  else
    iord = iord_d
    jord = jord_d
  endif
  d_sw_tape_rec = k-1+cd_core_tape_rec*km
  call d_sw_ad( u(1,jfirst-ng_d,k),u_ae(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),v_ae(1,jfirst-ng_s,k),uc(1,jfirst-ng_d,k),uc_ad(1,&
&jfirst-ng_d,k),vc(1,jfirst-2,k),vc_ad(1,jfirst-2,k),pt(1,jfirst-ng_d,k),pt_ae(1,jfirst-ng_d,k),delp(1,jfirst,k),delp_ae(1,&
&jfirst,k),delpf(1,jfirst-ng_d,k),delpf_ad(1,jfirst-ng_d,k),cx3_ad(1,jfirst-ng_d,k),cy3_ad(1,jfirst,k),mfx_ad(1,jfirst,k),&
&mfy_ad(1,jfirst,k),cdx(js2g0,k),cdy(js2g0,k),dtdx,dtdxe,dtxe5,txe5,dyce,rdx,cyy,dx,js2g0,jn1g1,im,jm,jfirst,jlast,ng_d,ng_s,nq,&
&iord,jord,zt_d,rcap,tiny,dtdy,dtdy5,tdy5,rdy,cosp,acosp,cose,coslon,sinlon,cosl5,sinl5,d_sw_tape_rec )
end do
#ifdef TIMING
call adtiming_on( 'D_CORE' )
call adtiming_off( 'Ghost_vc' )
#endif
call mp_recv_n_ad( im,jm,jfirst,jlast,1,km,2,2,vc_ad )
call mp_send_s_ad( im,jm,jfirst,jlast,1,km,2,2,vc_ad )
#ifdef TIMING
call adtiming_on( 'Ghost_vc' )
call adtiming_off( 'Recv_uc' )
#endif
call mp_recv3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,uc_ad,2 )
#ifdef TIMING
call adtiming_on( 'Recv_uc' )
call adtiming_off( 'C_V_LOOP' )
#endif
pkc = cd_core_tape_pkc_10h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_11h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!AOO!$omp parallel do shared(de,dtdy5,ifax,im,jlast,js1g1,js2g0,km,pkc,pkc_ad,se,trigs,vc_ad,wz,wz_ad) private(help_l,i,j,k,wk1,wk1_ad,&
!AOO!$omp& wk_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
  wk1_ad(:,:) = 0.d0
  wk_ad(:,:) = 0.d0
  help_l = jlast-js2g0+1
  call pft2d_ad( vc_ad(1,js2g0,k),se(js2g0),de(1,js2g0),im,help_l,ifax,trigs,wk_ad,wk1 )
  do j = js1g1, jlast
    do i = 1, im
      wk1(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      pkc_ad(i,j-1,k+1) = pkc_ad(i,j-1,k+1)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k)-wz(i,j,k+1))
      pkc_ad(i,j-1,k) = pkc_ad(i,j-1,k)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k+1)-wz(i,j,k))
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k+1)-wz(i,j,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k)-wz(i,j,k+1))
      wk1_ad(i,j-1) = wk1_ad(i,j-1)-vc_ad(i,j,k)*dtdy5/((wk1(i,j)+wk1(i,j-1))*(wk1(i,j)+wk1(i,j-1)))*((wz(i,j-1,k+1)-wz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i,j-1,k))+(wz(i,j-1,k)-wz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      wk1_ad(i,j) = wk1_ad(i,j)-vc_ad(i,j,k)*dtdy5/((wk1(i,j)+wk1(i,j-1))*(wk1(i,j)+wk1(i,j-1)))*((wz(i,j-1,k+1)-wz(i,j,k))*(pkc(i,&
&j,k+1)-pkc(i,j-1,k))+(wz(i,j-1,k)-wz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      wz_ad(i,j-1,k+1) = wz_ad(i,j-1,k+1)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j,k+1)-pkc(i,j-1,k))
      wz_ad(i,j-1,k) = wz_ad(i,j-1,k)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j-1,k+1)-pkc(i,j,k))
      wz_ad(i,j,k+1) = wz_ad(i,j,k+1)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j-1,k+1)-pkc(i,j,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j,k+1)-pkc(i,j-1,k))
    end do
  end do
  do j = js1g1, jlast
    do i = 1, im
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+wk1_ad(i,j)
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-wk1_ad(i,j)
      wk1_ad(i,j) = 0.d0
    end do
  end do
end do
#ifdef TIMING
call adtiming_on( 'C_V_LOOP' )
call adtiming_off( 'Send_uc' )
#endif
call mp_send3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,uc_ad,2 )
#ifdef TIMING
call adtiming_on( 'Send_uc' )
call adtiming_off( 'Recv_pkc_wz' )
#endif
call mp_recv2_s_ad( im,jm,jfirst,jlast,1,help_k,1,1,pkc_ad,wz_ad )
#ifdef TIMING
call adtiming_on( 'Recv_pkc_wz' )
call adtiming_off( 'C_U_LOOP' )
#endif
pkc = cd_core_tape_pkc_8h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_9h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!AOO!$omp parallel do shared(dc,dtdx2,ifax,im,jn2g0,js2g0,km,pkc,pkc_ad,sc,trigs,uc_ad,wz,wz_ad) private(help_j,i,j,k,p1d,p1d_ad,wk2,&
!AOO!$omp& wk_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
  p1d_ad(:) = 0.d0
  wk2_ad(:,:) = 0.d0
  wk_ad(:,:) = 0.d0
  help_j = jn2g0-js2g0+1
  call pft2d_ad( uc_ad(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_j,ifax,trigs,wk_ad,wk2 )
  do j = js2g0, jn2g0
    do i = 1, im
      p1d(i) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
    do i = 2, im
      p1d_ad(i-1) = p1d_ad(i-1)-uc_ad(i,j,k)*(dtdx2(j)*((wz(i-1,j,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(wz(i-1,j,k)-wz(i,j,&
&k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))/((p1d(i)+p1d(i-1))*(p1d(i)+p1d(i-1))))
      p1d_ad(i) = p1d_ad(i)-uc_ad(i,j,k)*(dtdx2(j)*((wz(i-1,j,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(wz(i-1,j,k)-wz(i,j,k+1))&
&*(pkc(i-1,j,k+1)-pkc(i,j,k)))/((p1d(i)+p1d(i-1))*(p1d(i)+p1d(i-1))))
      pkc_ad(i-1,j,k+1) = pkc_ad(i-1,j,k+1)+uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k)-wz(i,j,k+1))/(p1d(i)+p1d(i-1)))
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k+1)-wz(i,j,k))/(p1d(i)+p1d(i-1)))
      pkc_ad(i-1,j,k) = pkc_ad(i-1,j,k)-uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k+1)-wz(i,j,k))/(p1d(i)+p1d(i-1)))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k)-wz(i,j,k+1))/(p1d(i)+p1d(i-1)))
      wz_ad(i-1,j,k+1) = wz_ad(i-1,j,k+1)+uc_ad(i,j,k)*(dtdx2(j)*(pkc(i,j,k+1)-pkc(i-1,j,k))/(p1d(i)+p1d(i-1)))
      wz_ad(i,j,k+1) = wz_ad(i,j,k+1)-uc_ad(i,j,k)*(dtdx2(j)*(pkc(i-1,j,k+1)-pkc(i,j,k))/(p1d(i)+p1d(i-1)))
      wz_ad(i-1,j,k) = wz_ad(i-1,j,k)+uc_ad(i,j,k)*(dtdx2(j)*(pkc(i-1,j,k+1)-pkc(i,j,k))/(p1d(i)+p1d(i-1)))
      wz_ad(i,j,k) = wz_ad(i,j,k)-uc_ad(i,j,k)*(dtdx2(j)*(pkc(i,j,k+1)-pkc(i-1,j,k))/(p1d(i)+p1d(i-1)))
    end do
    p1d_ad(im) = p1d_ad(im)-uc_ad(1,j,k)*(dtdx2(j)*((wz(im,j,k+1)-wz(1,j,k))*(pkc(1,j,k+1)-pkc(im,j,k))+(wz(im,j,k)-wz(1,j,k+1))*&
&(pkc(im,j,k+1)-pkc(1,j,k)))/((p1d(1)+p1d(im))*(p1d(1)+p1d(im))))
    p1d_ad(1) = p1d_ad(1)-uc_ad(1,j,k)*(dtdx2(j)*((wz(im,j,k+1)-wz(1,j,k))*(pkc(1,j,k+1)-pkc(im,j,k))+(wz(im,j,k)-wz(1,j,k+1))*&
&(pkc(im,j,k+1)-pkc(1,j,k)))/((p1d(1)+p1d(im))*(p1d(1)+p1d(im))))
    pkc_ad(im,j,k+1) = pkc_ad(im,j,k+1)+uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k)-wz(1,j,k+1))/(p1d(1)+p1d(im)))
    pkc_ad(1,j,k+1) = pkc_ad(1,j,k+1)+uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k+1)-wz(1,j,k))/(p1d(1)+p1d(im)))
    pkc_ad(im,j,k) = pkc_ad(im,j,k)-uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k+1)-wz(1,j,k))/(p1d(1)+p1d(im)))
    pkc_ad(1,j,k) = pkc_ad(1,j,k)-uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k)-wz(1,j,k+1))/(p1d(1)+p1d(im)))
    wz_ad(im,j,k+1) = wz_ad(im,j,k+1)+uc_ad(1,j,k)*(dtdx2(j)*(pkc(1,j,k+1)-pkc(im,j,k))/(p1d(1)+p1d(im)))
    wz_ad(1,j,k+1) = wz_ad(1,j,k+1)-uc_ad(1,j,k)*(dtdx2(j)*(pkc(im,j,k+1)-pkc(1,j,k))/(p1d(1)+p1d(im)))
    wz_ad(im,j,k) = wz_ad(im,j,k)+uc_ad(1,j,k)*(dtdx2(j)*(pkc(im,j,k+1)-pkc(1,j,k))/(p1d(1)+p1d(im)))
    wz_ad(1,j,k) = wz_ad(1,j,k)-uc_ad(1,j,k)*(dtdx2(j)*(pkc(1,j,k+1)-pkc(im,j,k))/(p1d(1)+p1d(im)))
    do i = 1, im
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+p1d_ad(i)
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-p1d_ad(i)
      p1d_ad(i) = 0.d0
    end do
  end do
end do
#ifdef TIMING
call adtiming_on( 'C_U_LOOP' )
call adtiming_off( 'Send_pkc_wz' )
#endif
call mp_send2_n_ad( im,jm,jfirst,jlast,1,help_i,1,1,pkc_ad,wz_ad )
#ifdef TIMING
call adtiming_on( 'Send_pkc_wz' )
call adtiming_off( 'C_GEOP' )
#endif
call geopk_ad( ptop,pe_ae,ptk,ptk_ad,pkc,pkc_ad,wz_ad,ptc,ptc_ad,im,km,jfirst,jlast,0,cp,akap,nx,0, .false.  )
#ifdef TIMING
call adtiming_on( 'C_GEOP' )
call adtiming_off( 'C_CORE' )
#endif
u = cd_core_tape_u_1h(:,:,:,cd_core_tape_rec+1)
v = cd_core_tape_v_2h(:,:,:,cd_core_tape_rec+1)
delpf = cd_core_tape_delpf_3h(:,:,:,cd_core_tape_rec+1)
delp = cd_core_tape_delp_4h(:,:,:,cd_core_tape_rec+1)
pt = cd_core_tape_pt_5h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!$omp parallel do shared(acosp,cd_core_tape_rec,cose,cosl5,coslon,cosp,cye,dc,delp,delp_ae,delpf,delpf_ad,dtdx2,dtdx4,dtdy5,dtxe5,&
!$omp& dxdt,dxe,dycp,dydt,ifax,im,iord_c,jfirst,jlast,jm,jn1gc,jn2g0,jord_c,js2g0,js2gc,km,ng_c,ng_d,ng_s,pt,pt_ae,ptc_ad,ptk,&
!$omp& ptk_ad,rcap,rdxe,sc,sinl5,sinlon,trigs,u,u_ae,uc,uc_ad,v,v_ae,vc,vc_ad,zt_c) private(c_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    iord = 1
    jord = 1
  else
    iord = iord_c
    jord = jord_c
  endif
  c_sw_tape_rec = k-1+cd_core_tape_rec*km
  call c_sw_ad( u(1,jfirst-ng_d,k),u_ae(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),v_ae(1,jfirst-ng_s,k),pt(1,jfirst-ng_d,k),pt_ae(1,&
&jfirst-ng_d,k),delp(1,jfirst,k),delp_ae(1,jfirst,k),uc(1,jfirst-ng_d,k),uc_ad(1,jfirst-ng_d,k),vc(1,jfirst-2,k),vc_ad(1,jfirst-&
&2,k),ptc_ad(1,jfirst,k),delpf(1,jfirst-ng_d,k),delpf_ad(1,jfirst-ng_d,k),ptk(1:im,jfirst:jlast,k),ptk_ad(1:im,jfirst:jlast,k),&
&cosp,acosp,cose,coslon,sinlon,dxdt,dxe,dtdx2,dtdx4,dtxe5,rdxe,dycp,dydt,dtdy5,cye,ifax,trigs,dc(1,js2g0),sc,zt_c,tiny,rcap,im,&
&jm,jfirst,jlast,ng_c,ng_d,ng_s,js2g0,jn2g0,js2gc,jn1gc,iord,jord,cosl5,sinl5,c_sw_tape_rec )
end do
#ifdef TIMING
call adtiming_on( 'C_CORE' )
#endif
if (ipe .eq. (-1) .or. ns .eq. 1) then
#ifdef TIMING
  call adtiming_off( 'Ghost_pt&delpf' )
#endif
  call mp_recv3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf_ad,2 )
  call mp_recv3d_ns_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt_ae,1 )
  call mp_send3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf_ad,2 )
  call mp_send3d_ns_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt_ae,1 )
#ifdef TIMING
  call adtiming_on( 'Ghost_pt&delpf' )
#endif
endif
#ifdef TIMING
call adtiming_off( 'Recv_uv' )
#endif
call mp_recv3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_s,ng_d,v_ae,2 )
call mp_recv3d_ns_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u_ae,1 )
#ifdef TIMING
call adtiming_on( 'Recv_uv' )
#endif
if (ipe .eq. (-1) .or. ns .eq. 1) then
#ifdef USE_OPENMP
  !$omp parallel do shared(dc,delp_ae,delpf_ad,ifax,im,jfirst,jlast,jn2g0,js2g0,km,sc,trigs) private(help_h,i,j,k,wk2,wk_ad)
#endif /* ! USE_OPENMP */
  do k = 1, km
    wk2_ad(:,:) = 0.d0
    wk_ad(:,:) = 0.d0
    help_h = jn2g0-js2g0+1
    call pft2d_ad( delpf_ad(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,wk_ad,wk2 )
    do j = jfirst, jlast
      do i = 1, im
        delp_ae(i,j,k) = delp_ae(i,j,k)+delpf_ad(i,j,k)
        delpf_ad(i,j,k) = 0.d0
      end do
    end do
  end do
endif
#ifdef TIMING
call adtiming_off( 'Send_uv' )
#endif
call mp_send3d_ns2_ad( im,jm,jfirst,jlast,1,km,ng_s,ng_d,v_ae,2 )
call mp_send3d_ns_ad( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u_ae,1 )
#ifdef TIMING
call adtiming_on( 'Send_uv' )
#endif
vc_ad = 0.d0
uc_ad = 0.d0
wz3_ad = 0.d0

end subroutine cd_core_do_ad


subroutine cd_core_domd( im, jm, km, nq, nx, jfirst, jlast, u, v, pt, delp, pe, pk, ns, dt, ptop, umax, fill, filter, acap, ae, &
&rcap, cp, akap, iord_c, jord_c, iord_d, jord_d, ng_c, ng_d, ng_s, ipe, om, hs, sinp, cosp, cose, acosp, sinlon, coslon, cosl5, &
&sinl5, cx3, cy3, mfx, mfy, delpf, uc, vc, ptc, dpt, ptk, wz3, pkc, wz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use sw_core
use tp_core
#ifdef TIMING
use timingmodule
#endif
use mod_comm, only : gid,gsize,mp_barrier, mp_recv2_ns, mp_recv2_s, mp_recv3d_ns, mp_recv3d_ns2, mp_recv_n, mp_send2_n, &
&mp_send2_ns, mp_send3d_ns, mp_send3d_ns2, mp_send_s
use cd_core_do_ad_store, only : cd_core_tape_cd_core_do,cd_core_tape_delp_17h,cd_core_tape_delp_4h,cd_core_tape_delpf_3h,&
&cd_core_tape_pkc_10h,cd_core_tape_pkc_21h,cd_core_tape_pkc_23h,cd_core_tape_pkc_8h,cd_core_tape_pt_16h,cd_core_tape_pt_18h,&
&cd_core_tape_pt_5h,cd_core_tape_ptc_6h,cd_core_tape_ptk_7h,cd_core_tape_u_12h,cd_core_tape_u_1h,cd_core_tape_uc_14h,&
&cd_core_tape_v_13h,cd_core_tape_v_2h,cd_core_tape_vc_15h,cd_core_tape_wz3_25h,cd_core_tape_wz_11h,cd_core_tape_wz_22h,&
&cd_core_tape_wz_24h,cd_core_tape_wz_9h
use sw_core_ad, only : c_swmd, d_swmd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real(kind=r8), parameter :: tiny = 1.e-10

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
integer :: jm
real(kind=r8) :: acosp(jm)
real(kind=r8) :: ae
real(kind=r8) :: akap
real(kind=r8) :: cose(jm)
integer :: im
real(kind=r8) :: cosl5(im)
real(kind=r8) :: coslon(im)
real(kind=r8) :: cosp(jm)
real(kind=r8) :: cp
integer :: jfirst
integer :: jlast
integer :: km
integer :: ng_d
real(kind=r8) :: cx3(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: cy3(im,jfirst:jlast+1,km)
real(kind=r8) :: delp(im,jfirst:jlast,km)
real(kind=r8) :: delpf(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: dpt(im,jfirst-1:jlast+1,km)
real(kind=r8) :: dt
logical :: fill
logical :: filter
real(kind=r8) :: hs(im,jfirst:jlast)
integer :: iord_c
integer :: iord_d
integer :: ipe
integer :: jord_c
integer :: jord_d
real(kind=r8) :: mfx(im,jfirst:jlast,km)
real(kind=r8) :: mfy(im,jfirst:jlast+1,km)
integer :: ng_c
integer :: ng_s
integer :: nq
integer :: ns
integer :: nx
real(kind=r8) :: om
real(kind=r8) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8) :: pkc(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: ptc(im,jfirst:jlast,km)
real(kind=r8) :: ptk(im,jfirst:jlast,km)
real(kind=r8) :: ptop
real(kind=r8) :: rcap
real(kind=r8) :: sinl5(im)
real(kind=r8) :: sinlon(im)
real(kind=r8) :: sinp(jm)
real(kind=r8) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: uc(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: umax
real(kind=r8) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: vc(im,jfirst-2:jlast+2,km)
real(kind=r8) :: wz(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: wz3(im,jfirst-1:jlast,km+1)

!==============================================
! declare local variables
!==============================================
integer :: c_sw_tape_rec
integer :: d_sw_tape_rec
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_l
integer :: help_m
integer :: help_n
integer :: help_o
integer :: help_p
integer :: help_q
integer :: i
integer :: iord
integer :: j
integer :: jn1g1
integer :: jn1gc
integer :: jn2g0
integer :: jord
integer :: js1g1
integer :: js2g0
integer :: js2g1
integer :: js2gc
integer :: k
real(kind=r8) :: p1d(im)
real(kind=r8) :: pk4
real(kind=r8) :: pkchelp(im,jfirst-1:jlast+1)
real(kind=r8) :: wk(im,jfirst:jlast+2)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: wk2(im,jfirst:jlast+1)
real(kind=r8) :: wk3(im,jfirst-1:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
js1g1 = max(1,jfirst-1)
js2g0 = max(2,jfirst)
js2g1 = max(2,jfirst-1)
jn2g0 = min(jm-1,jlast)
jn1g1 = min(jm,jlast+1)
js2gc = max(2,jfirst-ng_c)
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc = max(2,jfirst-2)
endif
jn1gc = min(jm,jlast+ng_c)
wz3 = 0.
uc = 0.
vc = 0.
call mp_send3d_ns( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u,1 )
call mp_send3d_ns2( im,jm,jfirst,jlast,1,km,ng_s,ng_d,v,2 )
if (ipe .eq. (-1) .or. ns .eq. 1) then
#ifdef USE_OPENMP
  !$omp parallel do private(help_h,i,j,k,wk,wk2)
#endif /* ! USE_OPENMP */
  do k = 1, km
    do j = jfirst, jlast
      do i = 1, im
        delpf(i,j,k) = delp(i,j,k)
      end do
    end do
    help_h = jn2g0-js2g0+1
    call pft2d( delpf(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,wk,wk2 )
  end do
endif
call mp_recv3d_ns( im,jm,jfirst,jlast,1,km,ng_d,ng_s,u,1 )
call mp_recv3d_ns2( im,jm,jfirst,jlast,1,km,ng_s,ng_d,v,2 )
if (ipe .eq. (-1) .or. ns .eq. 1) then
  call mp_send3d_ns( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt,1 )
  call mp_send3d_ns2( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf,2 )
  call mp_recv3d_ns( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt,1 )
  call mp_recv3d_ns2( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf,2 )
endif
if ( .not. allocated(cd_core_tape_u_1h)) then
  allocate( cd_core_tape_u_1h(1:im,1:1+jlast+ng_s-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_u_1h(:,:,:,cd_core_tape_rec+1) = u
if ( .not. allocated(cd_core_tape_v_2h)) then
  allocate( cd_core_tape_v_2h(1:im,1:1+jlast+ng_d-(jfirst-ng_s),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_v_2h(:,:,:,cd_core_tape_rec+1) = v
if ( .not. allocated(cd_core_tape_delpf_3h)) then
  allocate( cd_core_tape_delpf_3h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_delpf_3h(:,:,:,cd_core_tape_rec+1) = delpf
if ( .not. allocated(cd_core_tape_delp_4h)) then
  allocate( cd_core_tape_delp_4h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_delp_4h(:,:,:,cd_core_tape_rec+1) = delp
if ( .not. allocated(cd_core_tape_pt_5h)) then
  allocate( cd_core_tape_pt_5h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pt_5h(:,:,:,cd_core_tape_rec+1) = pt
#ifdef USE_OPENMP
!$omp parallel do private(c_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    iord = 1
    jord = 1
  else
    iord = iord_c
    jord = jord_c
  endif
  c_sw_tape_rec = k-1+cd_core_tape_rec*km
  call c_swmd( u(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),pt(1,jfirst-ng_d,k),delp(1,jfirst,k),uc(1,jfirst-ng_d,k),vc(1,jfirst-2,k),&
&ptc(1,jfirst,k),delpf(1,jfirst-ng_d,k),ptk(1:im,jfirst:jlast,k),cosp,acosp,cose,coslon,sinlon,dxdt,dxe,dtdx2,dtdx4,dtxe5,rdxe,&
&dycp,dydt,dtdy5,cye,fc,ifax,trigs,dc(1,js2g0),sc,zt_c,tiny,rcap,im,jm,jfirst,jlast,ng_c,ng_d,ng_s,js2g0,jn2g0,js2gc,jn1gc,iord,&
&jord,cosl5,sinl5,c_sw_tape_rec )
end do
if ( .not. allocated(cd_core_tape_ptc_6h)) then
  allocate( cd_core_tape_ptc_6h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_ptc_6h(:,:,:,cd_core_tape_rec+1) = ptc
if ( .not. allocated(cd_core_tape_ptk_7h)) then
  allocate( cd_core_tape_ptk_7h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_ptk_7h(:,:,:,cd_core_tape_rec+1) = ptk
call geopk( ptop,pe,ptk,pkc,wz,hs,ptc,im,jm,km,jfirst,jlast,0,cp,akap,nx,0, .false.  )
help_i = km+1
call mp_send2_n( im,jm,jfirst,jlast,1,help_i,1,1,pkc,wz )
if ( .not. allocated(cd_core_tape_pkc_8h)) then
  allocate( cd_core_tape_pkc_8h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_8h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_9h)) then
  allocate( cd_core_tape_wz_9h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_9h(:,:,:,cd_core_tape_rec+1) = wz
#ifdef USE_OPENMP
!$omp parallel do private(help_j,i,j,k,p1d,wk,wk2)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js2g0, jn2g0
    do i = 1, im
      p1d(i) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
    uc(1,j,k) = uc(1,j,k)+dtdx2(j)*((wz(im,j,k+1)-wz(1,j,k))*(pkc(1,j,k+1)-pkc(im,j,k))+(wz(im,j,k)-wz(1,j,k+1))*(pkc(im,j,k+1)-&
&pkc(1,j,k)))/(p1d(1)+p1d(im))
    do i = 2, im
      uc(i,j,k) = uc(i,j,k)+dtdx2(j)*((wz(i-1,j,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(wz(i-1,j,k)-wz(i,j,k+1))*(pkc(i-1,j,k+&
&1)-pkc(i,j,k)))/(p1d(i)+p1d(i-1))
    end do
  end do
  help_j = jn2g0-js2g0+1
  call pft2d( uc(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_j,ifax,trigs,wk,wk2 )
end do
help_k = km+1
call mp_recv2_s( im,jm,jfirst,jlast,1,help_k,1,1,pkc,wz )
call mp_send3d_ns2( im,jm,jfirst,jlast,1,km,ng_d,ng_d,uc,2 )
if ( .not. allocated(cd_core_tape_pkc_10h)) then
  allocate( cd_core_tape_pkc_10h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_10h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_11h)) then
  allocate( cd_core_tape_wz_11h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_11h(:,:,:,cd_core_tape_rec+1) = wz
#ifdef USE_OPENMP
!$omp parallel do private(help_l,i,j,k,wk,wk1)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js1g1, jlast
    do i = 1, im
      wk1(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      vc(i,j,k) = vc(i,j,k)+dtdy5/(wk1(i,j)+wk1(i,j-1))*((wz(i,j-1,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(wz(i,j-1,k)-wz(i,j,&
&k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
    end do
  end do
  help_l = jlast-js2g0+1
  call pft2d( vc(1,js2g0,k),se(js2g0),de(1,js2g0),im,help_l,ifax,trigs,wk,wk1 )
end do
call mp_recv3d_ns2( im,jm,jfirst,jlast,1,km,ng_d,ng_d,uc,2 )
call mp_send_s( im,jm,jfirst,jlast,1,km,2,2,vc )
call mp_recv_n( im,jm,jfirst,jlast,1,km,2,2,vc )
if ( .not. allocated(cd_core_tape_u_12h)) then
  allocate( cd_core_tape_u_12h(1:im,1:1+jlast+ng_s-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_u_12h(:,:,:,cd_core_tape_rec+1) = u
if ( .not. allocated(cd_core_tape_v_13h)) then
  allocate( cd_core_tape_v_13h(1:im,1:1+jlast+ng_d-(jfirst-ng_s),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_v_13h(:,:,:,cd_core_tape_rec+1) = v
if ( .not. allocated(cd_core_tape_uc_14h)) then
  allocate( cd_core_tape_uc_14h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_uc_14h(:,:,:,cd_core_tape_rec+1) = uc
if ( .not. allocated(cd_core_tape_vc_15h)) then
  allocate( cd_core_tape_vc_15h(1:im,1:3+2+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_vc_15h(:,:,:,cd_core_tape_rec+1) = vc
if ( .not. allocated(cd_core_tape_pt_16h)) then
  allocate( cd_core_tape_pt_16h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pt_16h(:,:,:,cd_core_tape_rec+1) = pt
#ifdef USE_OPENMP
!$omp parallel do private(d_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    if (k .eq. 1) then
      iord = 1
      jord = 1
    else
      iord = min(2,iord_d)
      jord = min(2,jord_d)
    endif
  else
    iord = iord_d
    jord = jord_d
  endif
  d_sw_tape_rec = k-1+cd_core_tape_rec*km
  call d_swmd( u(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),uc(1,jfirst-ng_d,k),vc(1,jfirst-2,k),pt(1,jfirst-ng_d,k),delp(1,jfirst,k),&
&delpf(1,jfirst-ng_d,k),cx3(1,jfirst-ng_d,k),cy3(1,jfirst,k),mfx(1,jfirst,k),mfy(1,jfirst,k),cdx(js2g0,k),cdy(js2g0,k),dtdx,&
&dtdxe,dtxe5,txe5,dyce,rdx,cyy,dx,f0(jfirst-ng_d),js2g0,jn1g1,im,jm,jfirst,jlast,ng_d,ng_s,nq,iord,jord,zt_d,rcap,tiny,dtdy,&
&dtdy5,tdy5,rdy,cosp,acosp,cose,coslon,sinlon,cosl5,sinl5,d_sw_tape_rec )
end do
if ( .not. allocated(cd_core_tape_delp_17h)) then
  allocate( cd_core_tape_delp_17h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_delp_17h(:,:,:,cd_core_tape_rec+1) = delp
if ( .not. allocated(cd_core_tape_pt_18h)) then
  allocate( cd_core_tape_pt_18h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pt_18h(:,:,:,cd_core_tape_rec+1) = pt
call geopk( ptop,pe,delp,pkc,wz,hs,pt,im,jm,km,jfirst,jlast,ng_d,cp,akap,nx,ipe, .true.  )
help_m = km+1
call mp_send2_ns( im,jm,jfirst,jlast,1,help_m,1,pkc,wz )
if (ipe .ne. 1) then
#ifdef USE_OPENMP
  !$omp parallel do private(help_n,i,j,k,wk,wk2)
#endif /* ! USE_OPENMP */
  do k = 1, km
    do j = jfirst, jlast
      do i = 1, im
        delpf(i,j,k) = delp(i,j,k)
      end do
    end do
    help_n = jn2g0-js2g0+1
    call pft2d( delpf(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_n,ifax,trigs,wk,wk2 )
  end do
else
#ifdef USE_OPENMP
  !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
  do k = 1, km+1
    do j = jfirst, jlast
      do i = 1, im
        pk(i,j,k) = pkc(i,j,k)
      end do
    end do
  end do
endif
help_o = km+1
call mp_recv2_ns( im,jm,jfirst,jlast,1,help_o,1,pkc,wz )
if ( .not. allocated(cd_core_tape_pkc_21h)) then
  allocate( cd_core_tape_pkc_21h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_21h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_22h)) then
  allocate( cd_core_tape_wz_22h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_22h(:,:,:,cd_core_tape_rec+1) = wz
if (ipe .ne. 1) then
  call mp_send3d_ns( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt,1 )
  call mp_send3d_ns2( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf,2 )
endif
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js1g1, jn1g1
    do i = 1, im
      dpt(i,j,k) = (wz(i,j,k+1)+wz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j,k))
    end do
  end do
end do
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k,pkchelp,wk1,wk3)
#endif /* ! USE_OPENMP */
do k = 2, km+1
  do j = js2g1, jn2g0
    wk3(1,j) = (wz(1,j,k)+wz(im,j,k))*(pkc(1,j,k)-pkc(im,j,k))
    do i = 2, im
      wk3(i,j) = (wz(i,j,k)+wz(i-1,j,k))*(pkc(i,j,k)-pkc(i-1,j,k))
    end do
  end do
  do j = js2g1, jn2g0
    do i = 1, im-1
      wk1(i,j) = wk3(i,j)+wk3(i+1,j)
    end do
    wk1(im,j) = wk3(im,j)+wk3(1,j)
  end do
  if (jfirst .eq. 1) then
    do i = 1, im
      wk1(i,1) = 0.
    end do
  endif
  if (jlast .eq. jm) then
    do i = 1, im
      wk1(i,jm) = 0.
    end do
  endif
  do j = js2g0, jlast
    do i = 1, im
      wz3(i,j,k) = wk1(i,j)+wk1(i,j-1)
    end do
  end do
  do j = js2g0, jn1g1
    do i = 1, im
      wk1(i,j) = (wz(i,j,k)+wz(i,j-1,k))*(pkc(i,j,k)-pkc(i,j-1,k))
    end do
  end do
  do j = js2g0, jn1g1
    wk3(1,j) = wk1(1,j)+wk1(im,j)
    do i = 2, im
      wk3(i,j) = wk1(i,j)+wk1(i-1,j)
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      wz(i,j,k) = wk3(i,j)+wk3(i,j+1)
    end do
  end do
  do j = jfirst-1, jlast+1
    do i = 1, im
      pkchelp(i,j) = pkc(i,j,k)
    end do
  end do
  call avgc( pkchelp,pkc(1,jfirst,k),im,jm,jfirst,jlast,wk1 )
end do
do j = js2g0, jlast
  do i = 1, im
    wz3(i,j,1) = 0.
    wz(i,j,1) = 0.
  end do
end do
pk4 = 4.*ptop**akap
do j = js2g0, jn1g1
  do i = 1, im
    pkc(i,j,1) = pk4
  end do
end do
if ( .not. allocated(cd_core_tape_pkc_23h)) then
  allocate( cd_core_tape_pkc_23h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_23h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_24h)) then
  allocate( cd_core_tape_wz_24h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_24h(:,:,:,cd_core_tape_rec+1) = wz
if ( .not. allocated(cd_core_tape_wz3_25h)) then
  allocate( cd_core_tape_wz3_25h(1:im,1:2+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz3_25h(:,:,:,cd_core_tape_rec+1) = wz3
#ifdef USE_OPENMP
!$omp parallel do private(help_p,help_q,i,j,k,wk,wk1,wk2,wk3)
#endif /* ! USE_OPENMP */
do k = 1, km
  call avgc( dpt(1,jfirst-1,k),wk2(1,jfirst),im,jm,jfirst,jlast,wk1 )
  do j = js2g0, jn1g1
    do i = 1, im
      wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im-1
      wk3(i,j) = uc(i,j,k)+dtdxe(j)/(wk(i,j)+wk(i+1,j))*(wk2(i,j)-wk2(i+1,j)+wz3(i,j,k+1)-wz3(i,j,k))
    end do
    wk3(im,j) = uc(im,j,k)+dtdxe(j)/(wk(im,j)+wk(1,j))*(wk2(im,j)-wk2(1,j)+wz3(im,j,k+1)-wz3(im,j,k))
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      wk1(i,j) = vc(i,j,k)+dtdy/(wk(i,j)+wk(i,j+1))*(wk2(i,j)-wk2(i,j+1)+wz(i,j,k+1)-wz(i,j,k))
    end do
  end do
  help_p = jlast-js2g0+1
  call pft2d( wk3(1,js2g0),se(js2g0),de(1,js2g0),im,help_p,ifax,trigs,wk,wk2 )
  help_q = jn2g0-js2g0+1
  call pft2d( wk1(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_q,ifax,trigs,wk,wk2 )
  do j = js2g0, jlast
    do i = 1, im
      u(i,j,k) = u(i,j,k)+wk3(i,j)
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      v(i,j,k) = v(i,j,k)+wk1(i,j)
    end do
  end do
end do
if (ipe .ne. 1) then
  call mp_recv3d_ns( im,jm,jfirst,jlast,1,km,ng_d,ng_d,pt,1 )
  call mp_recv3d_ns2( im,jm,jfirst,jlast,1,km,ng_d,ng_d,delpf,2 )
endif
end subroutine cd_core_domd


end module     cd_core_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     cd_core_do_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: cd_core_tape_cd_core_do
real(kind=8), allocatable :: cd_core_tape_delp_17h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_delp_4h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_delpf_3h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_10h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_19h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_21h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pkc_8h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pt_16h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pt_18h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_pt_5h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_ptc_6h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_ptk_7h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_u_12h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_u_1h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_uc_14h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_v_13h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_v_2h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_vc_15h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz3_23h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_11h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_20h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_22h(:,:,:,:)
real(kind=8), allocatable :: cd_core_tape_wz_9h(:,:,:,:)

end module     cd_core_do_ad_store


module     cd_core_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use cd_core
!#ifdef TIMING
use timingModule, only : timing_on, timing_off
!#endif

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine cd_core_do_ad( im, jm, km, nq, nx, jfirst, jlast, u, u_ae, v, v_ae, pt, pt_ae, delp, delp_ae, pe_ae, pk_ae, ns, ptop, &
&rcap, cp, akap, iord_c, jord_c, iord_d, jord_d, ng_c, ng_d, ng_s, ipe, cosp, cose, acosp, sinlon, coslon, cosl5, sinl5, cx3_ad, &
&cy3_ad, mfx_ad, mfy_ad, delpf, delpf_ad, uc, uc_ad, vc, vc_ad, ptc, ptc_ad, dpt, dpt_ad, ptk, ptk_ad, wz3, wz3_ad, pkc, pkc_ad, &
&wz, wz_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use sw_core
use sw_core_ad
use tp_core
use tp_core_ad
use cd_core_do_ad_store, only : cd_core_tape_cd_core_do,cd_core_tape_delp_17h,cd_core_tape_delp_4h,cd_core_tape_delpf_3h,&
&cd_core_tape_pkc_10h,cd_core_tape_pkc_19h,cd_core_tape_pkc_21h,cd_core_tape_pkc_8h,cd_core_tape_pt_16h,cd_core_tape_pt_18h,&
&cd_core_tape_pt_5h,cd_core_tape_ptc_6h,cd_core_tape_ptk_7h,cd_core_tape_u_12h,cd_core_tape_u_1h,cd_core_tape_uc_14h,&
&cd_core_tape_v_13h,cd_core_tape_v_2h,cd_core_tape_vc_15h,cd_core_tape_wz3_23h,cd_core_tape_wz_11h,cd_core_tape_wz_20h,&
&cd_core_tape_wz_22h,cd_core_tape_wz_9h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real(kind=r8), parameter :: tiny = 1.e-10

!==============================================
! declare arguments
!==============================================
integer :: jm
real(kind=r8) :: acosp(jm)
real(kind=r8) :: akap
real(kind=r8) :: cose(jm)
integer :: im
real(kind=r8) :: cosl5(im)
real(kind=r8) :: coslon(im)
real(kind=r8) :: cosp(jm)
real(kind=r8) :: cp
integer :: jfirst
integer :: jlast
integer :: km
integer :: ng_d
real(kind=r8) :: cx3_ad(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: cy3_ad(im,jfirst:jlast+1,km)
real(kind=r8) :: delp(im,jfirst:jlast,km)
real(kind=r8) :: delp_ae(im,jfirst:jlast,km)
real(kind=r8) :: delpf(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: delpf_ad(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: dpt(im,jfirst-1:jlast+1,km)
real(kind=r8) :: dpt_ad(im,jfirst-1:jlast+1,km)
integer :: iord_c
integer :: iord_d
integer :: ipe
integer :: jord_c
integer :: jord_d
real(kind=r8) :: mfx_ad(im,jfirst:jlast,km)
real(kind=r8) :: mfy_ad(im,jfirst:jlast+1,km)
integer :: ng_c
integer :: ng_s
integer :: nq
integer :: ns
integer :: nx
real(kind=r8) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8) :: pkc(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: pkc_ad(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: pt_ae(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: ptc(im,jfirst:jlast,km)
real(kind=r8) :: ptc_ad(im,jfirst:jlast,km)
real(kind=r8) :: ptk(im,jfirst:jlast,km)
real(kind=r8) :: ptk_ad(im,jfirst:jlast,km)
real(kind=r8) :: ptop
real(kind=r8) :: rcap
real(kind=r8) :: sinl5(im)
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: u_ae(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: uc(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: uc_ad(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: v_ae(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: vc(im,jfirst-2:jlast+2,km)
real(kind=r8) :: vc_ad(im,jfirst-2:jlast+2,km)
real(kind=r8) :: wz(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: wz3(im,jfirst-1:jlast,km+1)
real(kind=r8) :: wz3_ad(im,jfirst-1:jlast,km+1)
real(kind=r8) :: wz_ad(im,jfirst-1:jlast+1,km+1)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: temp_wz3_ad(im,jfirst-1:jlast,km)
real(kind=r8) :: temp_wz_ad(im,jfirst-1:jlast+1,km)
real(kind=r8) :: temp1_wz_ad(im,jfirst-1:jlast+1,km)
real(kind=r8) :: temp_pkc_ad(im,jfirst-1:jlast+1,km)
real(kind=r8) :: temp1_pkc_ad(im,jfirst-1:jlast+1,km)
real(kind=r8) :: temp2_pkc_ad(im,jfirst-1:jlast+1,km)
integer :: c_sw_tape_rec
integer :: d_sw_tape_rec
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_l
integer :: help_m
integer :: i
integer :: iord
integer :: j
integer :: jn1g1
integer :: jn1gc
integer :: jn2g0
integer :: jord
integer :: js1g1
integer :: js2g0
integer :: js2g1
integer :: js2gc
integer :: k
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1d_ad(im)
#ifdef USE_OPENMP
real(kind=r8) :: pkc_adh(im,jfirst-1:jlast+1,km+1)
#endif /* ! USE_OPENMP */
real(kind=r8) :: pkchelp_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: wk(im,jfirst:jlast+2)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: wk1_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: wk2(im,jfirst:jlast+1)
real(kind=r8) :: wk2_ad(im,jfirst:jlast+1)
real(kind=r8) :: wk3_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: wk_ad(im,jfirst:jlast+2)
#ifdef USE_OPENMP
real(kind=r8) :: wz_adh(im,jfirst-1:jlast+1,km+1)
#endif /* ! USE_OPENMP */
!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
p1d_ad(:) = 0.d0
pkchelp_ad(:,:) = 0.d0
wk1_ad(:,:) = 0.d0
wk2_ad(:,:) = 0.d0
wk3_ad(:,:) = 0.d0
wk_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
js1g1 = max(1,jfirst-1)
js2g0 = max(2,jfirst)
js2g1 = max(2,jfirst-1)
jn2g0 = min(jm-1,jlast)
jn1g1 = min(jm,jlast+1)
js2gc = max(2,jfirst-ng_c)
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc = max(2,jfirst-2)
endif
jn1gc = min(jm,jlast+ng_c)
ptc = cd_core_tape_ptc_6h(:,:,:,cd_core_tape_rec+1)
ptk = cd_core_tape_ptk_7h(:,:,:,cd_core_tape_rec+1)
u = cd_core_tape_u_12h(:,:,:,cd_core_tape_rec+1)
v = cd_core_tape_v_13h(:,:,:,cd_core_tape_rec+1)
uc = cd_core_tape_uc_14h(:,:,:,cd_core_tape_rec+1)
vc = cd_core_tape_vc_15h(:,:,:,cd_core_tape_rec+1)
delp = cd_core_tape_delp_17h(:,:,:,cd_core_tape_rec+1)
pt = cd_core_tape_pt_18h(:,:,:,cd_core_tape_rec+1)
pkc = cd_core_tape_pkc_19h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_20h(:,:,:,cd_core_tape_rec+1)
#ifdef TIMING
call timing_on("cd_core_ad1")
#endif
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js1g1, jn1g1
    do i = 1, im
      dpt(i,j,k) = (wz(i,j,k+1)+wz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j,k))
    end do
  end do
end do
#ifdef TIMING
call timing_off("cd_core_ad1")
#endif
pkc = cd_core_tape_pkc_21h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_22h(:,:,:,cd_core_tape_rec+1)
wz3 = cd_core_tape_wz3_23h(:,:,:,cd_core_tape_rec+1)
!#ifdef TIMING
!!call adtiming_off( 'D-6000' )
call timing_on("cd_core_ad2_no")
!#endif
#ifdef USE_OPENMP
!$omp parallel do shared(dc,de,dpt,dpt_ad,dtdxe,dtdy,ifax,im,jfirst,jlast,jm,jn1g1,jn2g0,js2g0,km,pkc,temp_pkc_ad,sc,se,trigs,u_ae,&
!$omp& uc_ad,v_ae,vc_ad,wz,wz3,temp_wz3_ad,temp_wz_ad) private(help_l,help_m,i,j,k,wk,wk1,wk1_ad,wk2,wk2_ad,wk3_ad,wk_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
  wk1_ad(:,:) = 0.d0
  wk2_ad(:,:) = 0.d0
  wk3_ad(:,:) = 0.d0
  wk_ad(:,:) = 0.d0
  do j = js2g0, jn1g1
    do i = 1, im
      wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  help_l = jlast-js2g0+1
  help_m = jn2g0-js2g0+1
  do j = js2g0, jn2g0
    do i = 1, im
      wk1_ad(i,j) = wk1_ad(i,j)+v_ae(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      wk3_ad(i,j) = wk3_ad(i,j)+u_ae(i,j,k)
    end do
  end do
  call pft2d_ad( wk1_ad(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_m,ifax,trigs,wk_ad,wk2 )
  call pft2d_ad( wk3_ad(1,js2g0),se(js2g0),de(1,js2g0),im,help_l,ifax,trigs,wk_ad,wk2 )
  call avgc( dpt(1,jfirst-1,k),wk2(1,jfirst),im,jm,jfirst,jlast,wk1 )
#ifdef TIMING
!  call timing_on('CD_CORE_ad_1')
#endif
  do j = js2g0, jn2g0
    do i = 1, im
      vc_ad(i,j,k) = vc_ad(i,j,k)+wk1_ad(i,j)
      wk_ad(i,j+1) = wk_ad(i,j+1)-wk1_ad(i,j)*dtdy/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*(wk2(i,j)-wk2(i,j+1)+wz(i,j,k+1)-wz(i,&
&j,k))
      wk_ad(i,j) = wk_ad(i,j)-wk1_ad(i,j)*dtdy/((wk(i,j)+wk(i,j+1))*(wk(i,j)+wk(i,j+1)))*(wk2(i,j)-wk2(i,j+1)+wz(i,j,k+1)-wz(i,j,k))
      wk2_ad(i,j+1) = wk2_ad(i,j+1)-wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      wk2_ad(i,j) = wk2_ad(i,j)+wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      temp_wz_ad(i,j,k) =  wk1_ad(i,j)*(dtdy/(wk(i,j)+wk(i,j+1)))
      wk1_ad(i,j) = 0.d0
    end do
  end do
#ifdef TIMING
!  call timing_off('CD_CORE_ad_1')
#endif
  call avgc( dpt(1,jfirst-1,k),wk2(1,jfirst),im,jm,jfirst,jlast,wk1 )
  do j = js2g0, jlast
    uc_ad(im,j,k) = uc_ad(im,j,k)+wk3_ad(im,j)
    wk_ad(im,j) = wk_ad(im,j)-wk3_ad(im,j)*dtdxe(j)/((wk(im,j)+wk(1,j))*(wk(im,j)+wk(1,j)))*(wk2(im,j)-wk2(1,j)+wz3(im,j,k+1)-&
&wz3(im,j,k))
    wk_ad(1,j) = wk_ad(1,j)-wk3_ad(im,j)*dtdxe(j)/((wk(im,j)+wk(1,j))*(wk(im,j)+wk(1,j)))*(wk2(im,j)-wk2(1,j)+wz3(im,j,k+1)-wz3(im,&
&j,k))
    wk2_ad(im,j) = wk2_ad(im,j)+wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    wk2_ad(1,j) = wk2_ad(1,j)-wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    temp_wz3_ad(im,j,k) =  wk3_ad(im,j)*(dtdxe(j)/(wk(im,j)+wk(1,j)))
    wk3_ad(im,j) = 0.d0
    do i = 1, im-1
      uc_ad(i,j,k) = uc_ad(i,j,k)+wk3_ad(i,j)
      wk_ad(i+1,j) = wk_ad(i+1,j)-wk3_ad(i,j)*dtdxe(j)/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*(wk2(i,j)-wk2(i+1,j)+wz3(i,j,k+1)-&
&wz3(i,j,k))
      wk_ad(i,j) = wk_ad(i,j)-wk3_ad(i,j)*dtdxe(j)/((wk(i,j)+wk(i+1,j))*(wk(i,j)+wk(i+1,j)))*(wk2(i,j)-wk2(i+1,j)+wz3(i,j,k+1)-&
&wz3(i,j,k))
      wk2_ad(i+1,j) = wk2_ad(i+1,j)-wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      wk2_ad(i,j) = wk2_ad(i,j)+wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      temp_wz3_ad(i,j,k) =  wk3_ad(i,j)*(dtdxe(j)/(wk(i,j)+wk(i+1,j)))
      wk3_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, jn1g1
    do i = 1, im
      temp_pkc_ad(i,j,k) =  wk_ad(i,j)
      wk_ad(i,j) = 0.d0
    end do
  end do
  call avgc_ad( dpt_ad(1,jfirst-1,k),wk2_ad(1,jfirst),im,jm,jfirst,jlast,wk1_ad )
end do
!$omp parallel shared(pkc_ad,wz3_ad,wz_ad,temp_pkc_ad,temp_wz3_ad,temp_wz_ad,km) private(k)
!$omp do
  do k = 1,km
    wz_ad(:,js2g0:jn2g0,k+1) = wz_ad(:,js2g0:jn2g0,k+1)+temp_wz_ad(:,js2g0:jn2g0,k)
    wz3_ad(:,js2g0:jn2g0,k+1) = wz3_ad(:,js2g0:jn2g0,k+1)+temp_wz3_ad(:,js2g0:jn2g0,k)
    pkc_ad(:,js2g0:jn1g1,k+1) = pkc_ad(:,js2g0:jn1g1,k+1)+temp_pkc_ad(:,js2g0:jn1g1,k)
  enddo
!$omp do
  do k = 1,km
    wz_ad(:,js2g0:jn2g0,k) = wz_ad(:,js2g0:jn2g0,k)-temp_wz_ad(:,js2g0:jn2g0,k)
    wz3_ad(:,js2g0:jn2g0,k) = wz3_ad(:,js2g0:jn2g0,k)-temp_wz3_ad(:,js2g0:jn2g0,k)
    pkc_ad(:,js2g0:jn1g1,k) = pkc_ad(:,js2g0:jn1g1,k)-temp_pkc_ad(:,js2g0:jn1g1,k)
  enddo
!$omp end parallel
!#ifdef TIMING
call timing_off("cd_core_ad2_no")
!!call adtiming_on( 'D-6000' )
!#endif
do j = js2g0, jn1g1
  do i = 1, im
    pkc_ad(i,j,1) = 0.d0
  end do
end do
do j = js2g0, jlast
  do i = 1, im
    wz_ad(i,j,1) = 0.d0
    wz3_ad(i,j,1) = 0.d0
  end do
end do
#ifdef TIMING
!!call adtiming_off( 'D-4500' )
#endif
pkc = cd_core_tape_pkc_19h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_20h(:,:,:,cd_core_tape_rec+1)
#ifdef TIMING
call timing_on("cd_core_ad3")
#endif
#ifdef USE_OPENMP
!$omp parallel do shared(im,jfirst,jlast,jm,jn1g1,jn2g0,js2g0,js2g1,km,pkc,pkc_ad,wz,wz3_ad,wz_ad) private(i,j,k,pkchelp_ad,wk1_ad,&
!$omp& wk3_ad)
#endif /* ! USE_OPENMP */
do k = 2, km+1
  pkchelp_ad(:,:) = 0.d0
  wk1_ad(:,:) = 0.d0
  wk3_ad(:,:) = 0.d0
  call avgc_ad( pkchelp_ad,pkc_ad(1,jfirst,k),im,jm,jfirst,jlast,wk1_ad )
  do j = jfirst-1, jlast+1
    do i = 1, im
      pkc_ad(i,j,k) = pkc_ad(i,j,k)+pkchelp_ad(i,j)
      pkchelp_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      wk3_ad(i,j+1) = wk3_ad(i,j+1)+wz_ad(i,j,k)
      wk3_ad(i,j) = wk3_ad(i,j)+wz_ad(i,j,k)
      wz_ad(i,j,k) = 0.d0
    end do
  end do
  do j = js2g0, jn1g1
    do i = 2, im
      wk1_ad(i-1,j) = wk1_ad(i-1,j)+wk3_ad(i,j)
      wk1_ad(i,j) = wk1_ad(i,j)+wk3_ad(i,j)
      wk3_ad(i,j) = 0.d0
    end do
    wk1_ad(im,j) = wk1_ad(im,j)+wk3_ad(1,j)
    wk1_ad(1,j) = wk1_ad(1,j)+wk3_ad(1,j)
    wk3_ad(1,j) = 0.d0
  end do
  do j = js2g0, jn1g1
    do i = 1, im
      pkc_ad(i,j-1,k) = pkc_ad(i,j-1,k)-wk1_ad(i,j)*(wz(i,j,k)+wz(i,j-1,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)+wk1_ad(i,j)*(wz(i,j,k)+wz(i,j-1,k))
      wz_ad(i,j-1,k) = wz_ad(i,j-1,k)+wk1_ad(i,j)*(pkc(i,j,k)-pkc(i,j-1,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)+wk1_ad(i,j)*(pkc(i,j,k)-pkc(i,j-1,k))
      wk1_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      wk1_ad(i,j-1) = wk1_ad(i,j-1)+wz3_ad(i,j,k)
      wk1_ad(i,j) = wk1_ad(i,j)+wz3_ad(i,j,k)
      wz3_ad(i,j,k) = 0.d0
    end do
  end do
  if (jlast .eq. jm) then
    do i = 1, im
      wk1_ad(i,jm) = 0.d0
    end do
  endif
  if (jfirst .eq. 1) then
    do i = 1, im
      wk1_ad(i,1) = 0.d0
    end do
  endif
  do j = js2g1, jn2g0
    wk3_ad(im,j) = wk3_ad(im,j)+wk1_ad(im,j)
    wk3_ad(1,j) = wk3_ad(1,j)+wk1_ad(im,j)
    wk1_ad(im,j) = 0.d0
    do i = 1, im-1
      wk3_ad(i+1,j) = wk3_ad(i+1,j)+wk1_ad(i,j)
      wk3_ad(i,j) = wk3_ad(i,j)+wk1_ad(i,j)
      wk1_ad(i,j) = 0.d0
    end do
  end do
  do j = js2g1, jn2g0
    do i = 2, im
      pkc_ad(i-1,j,k) = pkc_ad(i-1,j,k)-wk3_ad(i,j)*(wz(i,j,k)+wz(i-1,j,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)+wk3_ad(i,j)*(wz(i,j,k)+wz(i-1,j,k))
      wz_ad(i-1,j,k) = wz_ad(i-1,j,k)+wk3_ad(i,j)*(pkc(i,j,k)-pkc(i-1,j,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)+wk3_ad(i,j)*(pkc(i,j,k)-pkc(i-1,j,k))
      wk3_ad(i,j) = 0.d0
    end do
    pkc_ad(im,j,k) = pkc_ad(im,j,k)-wk3_ad(1,j)*(wz(1,j,k)+wz(im,j,k))
    pkc_ad(1,j,k) = pkc_ad(1,j,k)+wk3_ad(1,j)*(wz(1,j,k)+wz(im,j,k))
    wz_ad(im,j,k) = wz_ad(im,j,k)+wk3_ad(1,j)*(pkc(1,j,k)-pkc(im,j,k))
    wz_ad(1,j,k) = wz_ad(1,j,k)+wk3_ad(1,j)*(pkc(1,j,k)-pkc(im,j,k))
    wk3_ad(1,j) = 0.d0
  end do
end do
#ifdef TIMING
call timing_off("cd_core_ad3")
!!call adtiming_on( 'D-4500' )
#endif
pkc = cd_core_tape_pkc_19h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_20h(:,:,:,cd_core_tape_rec+1)
!#ifdef TIMING
call timing_on("cd_core_ad4_no")
!#endif
#ifdef USE_OPENMP
!oloso pkc_adh(:,:,:) = pkc_ad(:,:,:)
!oloso wz_adh(:,:,:) = wz_ad(:,:,:)
!$omp parallel do shared(dpt_ad,im,jn1g1,js1g1,km,pkc,temp_pkc_ad,wz,temp_wz_ad) private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
#ifdef USE_OPENMP
!oloso  pkc_ad(:,:,:) = 0.d0
!oloso  wz_ad(:,:,:) = 0.d0
#endif /* ! USE_OPENMP */
  do j = js1g1, jn1g1
    do i = 1, im
      temp_pkc_ad(i,j,k) =  dpt_ad(i,j,k)*(wz(i,j,k+1)+wz(i,j,k))
      temp_wz_ad(i,j,k)  =  dpt_ad(i,j,k)*(pkc(i,j,k+1)-pkc(i,j,k))
      dpt_ad(i,j,k) = 0.d0
    end do
  end do
#ifdef USE_OPENMP
!oloso  !$omp critical  (adtaf)
!oloso  pkc_adh(:,:,:) = pkc_adh(:,:,:)+pkc_ad(:,:,:)
!oloso  wz_adh(:,:,:) = wz_adh(:,:,:)+wz_ad(:,:,:)
!oloso  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
!oloso pkc_ad(:,:,:) = pkc_adh(:,:,:)
!oloso wz_ad(:,:,:) = wz_adh(:,:,:)
#endif /* ! USE_OPENMP */
!$omp parallel shared(pkc_ad,wz_ad,temp_pkc_ad,temp_wz_ad,km) private(k)
!$omp do
  do k = 1,km
    pkc_ad(:,js1g1:jn1g1,k+1) = pkc_ad(:,js1g1:jn1g1,k+1)+temp_pkc_ad(:,js1g1:jn1g1,k)
    wz_ad(:,js1g1:jn1g1,k+1) = wz_ad(:,js1g1:jn1g1,k+1)+temp_wz_ad(:,js1g1:jn1g1,k)
  enddo
!$omp do
  do k = 1,km
    pkc_ad(:,js1g1:jn1g1,k) = pkc_ad(:,js1g1:jn1g1,k)-temp_pkc_ad(:,js1g1:jn1g1,k)
    wz_ad(:,js1g1:jn1g1,k) = wz_ad(:,js1g1:jn1g1,k)+temp_wz_ad(:,js1g1:jn1g1,k)
  enddo
!$omp end parallel
!#ifdef TIMING
call timing_off("cd_core_ad4_no")
!#endif
if (ipe .ne. 1) then
#ifdef TIMING
call timing_on("cd_core_ad5")
#endif
#ifdef USE_OPENMP
  !$omp parallel do shared(dc,delp_ae,delpf_ad,ifax,im,jfirst,jlast,jn2g0,js2g0,km,sc,trigs) private(help_k,i,j,k,wk2,wk_ad)
#endif /* ! USE_OPENMP */
  do k = 1, km
    wk2_ad(:,:) = 0.d0
    wk_ad(:,:) = 0.d0
    help_k = jn2g0-js2g0+1
    call pft2d_ad( delpf_ad(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_k,ifax,trigs,wk_ad,wk2 )
    do j = jfirst, jlast
      do i = 1, im
        delp_ae(i,j,k) = delp_ae(i,j,k)+delpf_ad(i,j,k)
        delpf_ad(i,j,k) = 0.d0
      end do
    end do
  end do
#ifdef TIMING
call timing_off("cd_core_ad5")
#endif
else
#ifdef TIMING
call timing_on("cd_core_ad6")
#endif
#ifdef USE_OPENMP
  !$omp parallel do shared(im,jfirst,jlast,km,pk_ae,pkc_ad) private(i,j,k)
#endif /* ! USE_OPENMP */
  do k = 1, km+1
    do j = jfirst, jlast
      do i = 1, im
        pkc_ad(i,j,k) = pkc_ad(i,j,k)+pk_ae(i,j,k)
        pk_ae(i,j,k) = 0.d0
      end do
    end do
  end do
#ifdef TIMING
call timing_off("cd_core_ad6")
#endif
endif
#ifdef TIMING
!!call adtiming_off( 'D_GEOP' )
#endif
call geopk_ad( ptop,pe_ae,delp,delp_ae,pkc,pkc_ad,wz_ad,pt,pt_ae,im,km,jfirst,jlast,ng_d,cp,akap,nx,ipe, .true.  )
#ifdef TIMING
!!call adtiming_on( 'D_GEOP' )
!!call adtiming_off( 'D_CORE' )
#endif
pt = cd_core_tape_pt_16h(:,:,:,cd_core_tape_rec+1)
#ifdef TIMING
call timing_on("cd_core_ad7")
#endif
#ifdef USE_OPENMP
!$omp parallel do shared(acosp,cd_core_tape_rec,cdx,cdy,cose,cosl5,coslon,cosp,cx3_ad,cy3_ad,cyy,delp,delp_ae,delpf,delpf_ad,dtdx,&
!$omp& dtdxe,dtdy,dtdy5,dtxe5,dx,dyce,im,iord_d,jfirst,jlast,jm,jn1g1,jord_d,js2g0,km,mfx_ad,mfy_ad,ng_d,ng_s,nq,pt,pt_ae,rcap,rdx,&
!$omp& rdy,sinl5,sinlon,tdy5,txe5,u,u_ae,uc,uc_ad,v,v_ae,vc,vc_ad,zt_d) private(d_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    if (k .eq. 1) then
      iord = 1
      jord = 1
    else
      iord = min(2,iord_d)
      jord = min(2,jord_d)
    endif
  else
    iord = iord_d
    jord = jord_d
  endif
  d_sw_tape_rec = k-1+cd_core_tape_rec*km
  call d_sw_ad( u(1,jfirst-ng_d,k),u_ae(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),v_ae(1,jfirst-ng_s,k),uc(1,jfirst-ng_d,k),uc_ad(1,&
&jfirst-ng_d,k),vc(1,jfirst-2,k),vc_ad(1,jfirst-2,k),pt(1,jfirst-ng_d,k),pt_ae(1,jfirst-ng_d,k),delp(1,jfirst,k),delp_ae(1,&
&jfirst,k),delpf(1,jfirst-ng_d,k),delpf_ad(1,jfirst-ng_d,k),cx3_ad(1,jfirst-ng_d,k),cy3_ad(1,jfirst,k),mfx_ad(1,jfirst,k),&
&mfy_ad(1,jfirst,k),cdx(js2g0,k),cdy(js2g0,k),dtdx,dtdxe,dtxe5,txe5,dyce,rdx,cyy,dx,js2g0,jn1g1,im,jm,jfirst,jlast,ng_d,ng_s,nq,&
&iord,jord,zt_d,rcap,tiny,dtdy,dtdy5,tdy5,rdy,cosp,acosp,cose,coslon,sinlon,cosl5,sinl5,d_sw_tape_rec )
end do
#ifdef TIMING
call timing_off("cd_core_ad7")
!!call adtiming_on( 'D_CORE' )
!!call adtiming_off( 'C_V_LOOP' )
#endif
pkc = cd_core_tape_pkc_10h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_11h(:,:,:,cd_core_tape_rec+1)
!#ifdef TIMING
call timing_on("cd_core_ad8_no")
!#endif
#ifdef USE_OPENMP
!AOO!$omp parallel do shared(de,dtdy5,ifax,im,jlast,js1g1,js2g0,km,pkc,pkc_ad,se,trigs,vc_ad,wz,wz_ad) private(help_j,i,j,k,wk1,wk1_ad,&
!AOO!$omp& wk_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
  wk1_ad(:,:) = 0.d0
  wk_ad(:,:) = 0.d0
  help_j = jlast-js2g0+1
  call pft2d_ad( vc_ad(1,js2g0,k),se(js2g0),de(1,js2g0),im,help_j,ifax,trigs,wk_ad,wk1 )
  do j = js1g1, jlast
    do i = 1, im
      wk1(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      pkc_ad(i,j-1,k+1) = pkc_ad(i,j-1,k+1)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k)-wz(i,j,k+1))
      pkc_ad(i,j-1,k) = pkc_ad(i,j-1,k)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k+1)-wz(i,j,k))
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k+1)-wz(i,j,k))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(wz(i,j-1,k)-wz(i,j,k+1))
      wk1_ad(i,j-1) = wk1_ad(i,j-1)-vc_ad(i,j,k)*dtdy5/((wk1(i,j)+wk1(i,j-1))*(wk1(i,j)+wk1(i,j-1)))*((wz(i,j-1,k+1)-wz(i,j,k))*&
&(pkc(i,j,k+1)-pkc(i,j-1,k))+(wz(i,j-1,k)-wz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      wk1_ad(i,j) = wk1_ad(i,j)-vc_ad(i,j,k)*dtdy5/((wk1(i,j)+wk1(i,j-1))*(wk1(i,j)+wk1(i,j-1)))*((wz(i,j-1,k+1)-wz(i,j,k))*(pkc(i,&
&j,k+1)-pkc(i,j-1,k))+(wz(i,j-1,k)-wz(i,j,k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
      wz_ad(i,j-1,k+1) = wz_ad(i,j-1,k+1)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j,k+1)-pkc(i,j-1,k))
      wz_ad(i,j-1,k) = wz_ad(i,j-1,k)+vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j-1,k+1)-pkc(i,j,k))
      wz_ad(i,j,k+1) = wz_ad(i,j,k+1)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j-1,k+1)-pkc(i,j,k))
      wz_ad(i,j,k) = wz_ad(i,j,k)-vc_ad(i,j,k)*dtdy5/(wk1(i,j)+wk1(i,j-1))*(pkc(i,j,k+1)-pkc(i,j-1,k))
    end do
  end do
  do j = js1g1, jlast
    do i = 1, im
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+wk1_ad(i,j)
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-wk1_ad(i,j)
      wk1_ad(i,j) = 0.d0
    end do
  end do
end do
#ifdef TIMING
!!call adtiming_on( 'C_V_LOOP' )
!!call adtiming_off( 'C_U_LOOP' )
#endif
pkc = cd_core_tape_pkc_8h(:,:,:,cd_core_tape_rec+1)
wz = cd_core_tape_wz_9h(:,:,:,cd_core_tape_rec+1)
#ifdef USE_OPENMP
!AOO!$omp parallel do shared(dc,dtdx2,ifax,im,jn2g0,js2g0,km,pkc,pkc_ad,sc,trigs,uc_ad,wz,wz_ad) private(help_i,i,j,k,p1d,p1d_ad,wk2,&
!AOO!$omp& wk_ad)
#endif /* ! USE_OPENMP */
do k = 1, km
  p1d_ad(:) = 0.d0
  wk2_ad(:,:) = 0.d0
  wk_ad(:,:) = 0.d0
  help_i = jn2g0-js2g0+1
  call pft2d_ad( uc_ad(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,wk_ad,wk2 )
  do j = js2g0, jn2g0
    do i = 1, im
      p1d(i) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
    do i = 2, im
      p1d_ad(i-1) = p1d_ad(i-1)-uc_ad(i,j,k)*(dtdx2(j)*((wz(i-1,j,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(wz(i-1,j,k)-wz(i,j,&
&k+1))*(pkc(i-1,j,k+1)-pkc(i,j,k)))/((p1d(i)+p1d(i-1))*(p1d(i)+p1d(i-1))))
      p1d_ad(i) = p1d_ad(i)-uc_ad(i,j,k)*(dtdx2(j)*((wz(i-1,j,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(wz(i-1,j,k)-wz(i,j,k+1))&
&*(pkc(i-1,j,k+1)-pkc(i,j,k)))/((p1d(i)+p1d(i-1))*(p1d(i)+p1d(i-1))))
      pkc_ad(i-1,j,k+1) = pkc_ad(i-1,j,k+1)+uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k)-wz(i,j,k+1))/(p1d(i)+p1d(i-1)))
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k+1)-wz(i,j,k))/(p1d(i)+p1d(i-1)))
      pkc_ad(i-1,j,k) = pkc_ad(i-1,j,k)-uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k+1)-wz(i,j,k))/(p1d(i)+p1d(i-1)))
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-uc_ad(i,j,k)*(dtdx2(j)*(wz(i-1,j,k)-wz(i,j,k+1))/(p1d(i)+p1d(i-1)))
      wz_ad(i-1,j,k+1) = wz_ad(i-1,j,k+1)+uc_ad(i,j,k)*(dtdx2(j)*(pkc(i,j,k+1)-pkc(i-1,j,k))/(p1d(i)+p1d(i-1)))
      wz_ad(i,j,k+1) = wz_ad(i,j,k+1)-uc_ad(i,j,k)*(dtdx2(j)*(pkc(i-1,j,k+1)-pkc(i,j,k))/(p1d(i)+p1d(i-1)))
      wz_ad(i-1,j,k) = wz_ad(i-1,j,k)+uc_ad(i,j,k)*(dtdx2(j)*(pkc(i-1,j,k+1)-pkc(i,j,k))/(p1d(i)+p1d(i-1)))
      wz_ad(i,j,k) = wz_ad(i,j,k)-uc_ad(i,j,k)*(dtdx2(j)*(pkc(i,j,k+1)-pkc(i-1,j,k))/(p1d(i)+p1d(i-1)))
    end do
    p1d_ad(im) = p1d_ad(im)-uc_ad(1,j,k)*(dtdx2(j)*((wz(im,j,k+1)-wz(1,j,k))*(pkc(1,j,k+1)-pkc(im,j,k))+(wz(im,j,k)-wz(1,j,k+1))*&
&(pkc(im,j,k+1)-pkc(1,j,k)))/((p1d(1)+p1d(im))*(p1d(1)+p1d(im))))
    p1d_ad(1) = p1d_ad(1)-uc_ad(1,j,k)*(dtdx2(j)*((wz(im,j,k+1)-wz(1,j,k))*(pkc(1,j,k+1)-pkc(im,j,k))+(wz(im,j,k)-wz(1,j,k+1))*&
&(pkc(im,j,k+1)-pkc(1,j,k)))/((p1d(1)+p1d(im))*(p1d(1)+p1d(im))))
    pkc_ad(im,j,k+1) = pkc_ad(im,j,k+1)+uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k)-wz(1,j,k+1))/(p1d(1)+p1d(im)))
    pkc_ad(1,j,k+1) = pkc_ad(1,j,k+1)+uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k+1)-wz(1,j,k))/(p1d(1)+p1d(im)))
    pkc_ad(im,j,k) = pkc_ad(im,j,k)-uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k+1)-wz(1,j,k))/(p1d(1)+p1d(im)))
    pkc_ad(1,j,k) = pkc_ad(1,j,k)-uc_ad(1,j,k)*(dtdx2(j)*(wz(im,j,k)-wz(1,j,k+1))/(p1d(1)+p1d(im)))
    wz_ad(im,j,k+1) = wz_ad(im,j,k+1)+uc_ad(1,j,k)*(dtdx2(j)*(pkc(1,j,k+1)-pkc(im,j,k))/(p1d(1)+p1d(im)))
    wz_ad(1,j,k+1) = wz_ad(1,j,k+1)-uc_ad(1,j,k)*(dtdx2(j)*(pkc(im,j,k+1)-pkc(1,j,k))/(p1d(1)+p1d(im)))
    wz_ad(im,j,k) = wz_ad(im,j,k)+uc_ad(1,j,k)*(dtdx2(j)*(pkc(im,j,k+1)-pkc(1,j,k))/(p1d(1)+p1d(im)))
    wz_ad(1,j,k) = wz_ad(1,j,k)-uc_ad(1,j,k)*(dtdx2(j)*(pkc(1,j,k+1)-pkc(im,j,k))/(p1d(1)+p1d(im)))
    do i = 1, im
      pkc_ad(i,j,k+1) = pkc_ad(i,j,k+1)+p1d_ad(i)
      pkc_ad(i,j,k) = pkc_ad(i,j,k)-p1d_ad(i)
      p1d_ad(i) = 0.d0
    end do
  end do
end do
!#ifdef TIMING
call timing_off("cd_core_ad8_no")
!!call adtiming_on( 'C_U_LOOP' )
!!call adtiming_off( 'C_GEOP' )
!#endif
call geopk_ad( ptop,pe_ae,ptk,ptk_ad,pkc,pkc_ad,wz_ad,ptc,ptc_ad,im,km,jfirst,jlast,0,cp,akap,nx,0, .false.  )
#ifdef TIMING
!!call adtiming_on( 'C_GEOP' )
!!call adtiming_off( 'C_CORE' )
#endif
u = cd_core_tape_u_1h(:,:,:,cd_core_tape_rec+1)
v = cd_core_tape_v_2h(:,:,:,cd_core_tape_rec+1)
delpf = cd_core_tape_delpf_3h(:,:,:,cd_core_tape_rec+1)
delp = cd_core_tape_delp_4h(:,:,:,cd_core_tape_rec+1)
pt = cd_core_tape_pt_5h(:,:,:,cd_core_tape_rec+1)
#ifdef TIMING
call timing_on("cd_core_ad9")
#endif
#ifdef USE_OPENMP
!$omp parallel do shared(acosp,cd_core_tape_rec,cose,cosl5,coslon,cosp,cye,dc,delp,delp_ae,delpf,delpf_ad,dtdx2,dtdx4,dtdy5,dtxe5,&
!$omp& dxdt,dxe,dycp,dydt,ifax,im,iord_c,jfirst,jlast,jm,jn1gc,jn2g0,jord_c,js2g0,js2gc,km,ng_c,ng_d,ng_s,pt,pt_ae,ptc_ad,ptk,&
!$omp& ptk_ad,rcap,rdxe,sc,sinl5,sinlon,trigs,u,u_ae,uc,uc_ad,v,v_ae,vc,vc_ad,zt_c) private(c_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    iord = 1
    jord = 1
  else
    iord = iord_c
    jord = jord_c
  endif
  c_sw_tape_rec = k-1+cd_core_tape_rec*km
  call c_sw_ad( u(1,jfirst-ng_d,k),u_ae(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),v_ae(1,jfirst-ng_s,k),pt(1,jfirst-ng_d,k),pt_ae(1,&
&jfirst-ng_d,k),delp(1,jfirst,k),delp_ae(1,jfirst,k),uc(1,jfirst-ng_d,k),uc_ad(1,jfirst-ng_d,k),vc(1,jfirst-2,k),vc_ad(1,jfirst-&
&2,k),ptc_ad(1,jfirst,k),delpf(1,jfirst-ng_d,k),delpf_ad(1,jfirst-ng_d,k),ptk(1:im,jfirst:jlast,k),ptk_ad(1:im,jfirst:jlast,k),&
&cosp,acosp,cose,coslon,sinlon,dxdt,dxe,dtdx2,dtdx4,dtxe5,rdxe,dycp,dydt,dtdy5,cye,ifax,trigs,dc(1,js2g0),sc,zt_c,tiny,rcap,im,&
&jm,jfirst,jlast,ng_c,ng_d,ng_s,js2g0,jn2g0,js2gc,jn1gc,iord,jord,cosl5,sinl5,c_sw_tape_rec )
end do
#ifdef TIMING
call timing_off("cd_core_ad9")
!!call adtiming_on( 'C_CORE' )
#endif
if (ipe .eq. (-1) .or. ns .eq. 1) then
#ifdef TIMING
call timing_on("cd_core_ad10")
#endif
#ifdef USE_OPENMP
  !$omp parallel do shared(dc,delp_ae,delpf_ad,ifax,im,jfirst,jlast,jn2g0,js2g0,km,sc,trigs) private(help_h,i,j,k,wk2,wk_ad)
#endif /* ! USE_OPENMP */
  do k = 1, km
    wk2_ad(:,:) = 0.d0
    wk_ad(:,:) = 0.d0
    help_h = jn2g0-js2g0+1
    call pft2d_ad( delpf_ad(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,wk_ad,wk2 )
    do j = jfirst, jlast
      do i = 1, im
        delp_ae(i,j,k) = delp_ae(i,j,k)+delpf_ad(i,j,k)
        delpf_ad(i,j,k) = 0.d0
      end do
    end do
  end do
#ifdef TIMING
call timing_off("cd_core_ad10")
#endif
endif
vc_ad = 0.d0
uc_ad = 0.d0
wz3_ad = 0.d0
wz_ad = 0.d0

end subroutine cd_core_do_ad


subroutine cd_core_domd( im, jm, km, nq, nx, jfirst, jlast, u, v, pt, delp, pe, pk, ns, dt, ptop, umax, fill, filter, acap, ae, &
&rcap, cp, akap, iord_c, jord_c, iord_d, jord_d, ng_c, ng_d, ng_s, ipe, om, hs, sinp, cosp, cose, acosp, sinlon, coslon, cosl5, &
&sinl5, cx3, cy3, mfx, mfy, delpf, uc, vc, ptc, dpt, ptk, wz3, pkc, wz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use sw_core
use tp_core
!#ifdef TIMING
use timingmodule, only : timing_on, timing_off
!#endif
use cd_core_do_ad_store, only : cd_core_tape_cd_core_do,cd_core_tape_delp_17h,cd_core_tape_delp_4h,cd_core_tape_delpf_3h,&
&cd_core_tape_pkc_10h,cd_core_tape_pkc_19h,cd_core_tape_pkc_21h,cd_core_tape_pkc_8h,cd_core_tape_pt_16h,cd_core_tape_pt_18h,&
&cd_core_tape_pt_5h,cd_core_tape_ptc_6h,cd_core_tape_ptk_7h,cd_core_tape_u_12h,cd_core_tape_u_1h,cd_core_tape_uc_14h,&
&cd_core_tape_v_13h,cd_core_tape_v_2h,cd_core_tape_vc_15h,cd_core_tape_wz3_23h,cd_core_tape_wz_11h,cd_core_tape_wz_20h,&
&cd_core_tape_wz_22h,cd_core_tape_wz_9h
use sw_core_ad, only : c_swmd, d_swmd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real(kind=r8), parameter :: tiny = 1.e-10

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
integer :: jm
real(kind=r8) :: acosp(jm)
real(kind=r8) :: ae
real(kind=r8) :: akap
real(kind=r8) :: cose(jm)
integer :: im
real(kind=r8) :: cosl5(im)
real(kind=r8) :: coslon(im)
real(kind=r8) :: cosp(jm)
real(kind=r8) :: cp
integer :: jfirst
integer :: jlast
integer :: km
integer :: ng_d
real(kind=r8) :: cx3(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: cy3(im,jfirst:jlast+1,km)
real(kind=r8) :: delp(im,jfirst:jlast,km)
real(kind=r8) :: delpf(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: dpt(im,jfirst-1:jlast+1,km)
real(kind=r8) :: dt
logical :: fill
logical :: filter
real(kind=r8) :: hs(im,jfirst:jlast)
integer :: iord_c
integer :: iord_d
integer :: ipe
integer :: jord_c
integer :: jord_d
real(kind=r8) :: mfx(im,jfirst:jlast,km)
real(kind=r8) :: mfy(im,jfirst:jlast+1,km)
integer :: ng_c
integer :: ng_s
integer :: nq
integer :: ns
integer :: nx
real(kind=r8) :: om
real(kind=r8) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8) :: pkc(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: ptc(im,jfirst:jlast,km)
real(kind=r8) :: ptk(im,jfirst:jlast,km)
real(kind=r8) :: ptop
real(kind=r8) :: rcap
real(kind=r8) :: sinl5(im)
real(kind=r8) :: sinlon(im)
real(kind=r8) :: sinp(jm)
real(kind=r8) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8) :: uc(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: umax
real(kind=r8) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8) :: vc(im,jfirst-2:jlast+2,km)
real(kind=r8) :: wz(im,jfirst-1:jlast+1,km+1)
real(kind=r8) :: wz3(im,jfirst-1:jlast,km+1)

!==============================================
! declare local variables
!==============================================
integer :: c_sw_tape_rec
integer :: d_sw_tape_rec
integer :: help_h
integer :: help_i
integer :: help_j
integer :: help_k
integer :: help_l
integer :: help_m
integer :: i
integer :: iord
integer :: j
integer :: jn1g1
integer :: jn1gc
integer :: jn2g0
integer :: jord
integer :: js1g1
integer :: js2g0
integer :: js2g1
integer :: js2gc
integer :: k
real(kind=r8) :: p1d(im)
real(kind=r8) :: pk4
real(kind=r8) :: pkchelp(im,jfirst-1:jlast+1)
real(kind=r8) :: wk(im,jfirst:jlast+2)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: wk2(im,jfirst:jlast+1)
real(kind=r8) :: wk3(im,jfirst-1:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
js1g1 = max(1,jfirst-1)
js2g0 = max(2,jfirst)
js2g1 = max(2,jfirst-1)
jn2g0 = min(jm-1,jlast)
jn1g1 = min(jm,jlast+1)
js2gc = max(2,jfirst-ng_c)
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc = max(2,jfirst-2)
endif
jn1gc = min(jm,jlast+ng_c)
wz = 0.
wz3 = 0.
uc = 0.
vc = 0.
if (ipe .eq. (-1) .or. ns .eq. 1) then
#ifdef TIMING
call timing_on("cd_core_ad11")
#endif
#ifdef USE_OPENMP
  !$omp parallel do private(help_h,i,j,k,wk,wk2)
#endif /* ! USE_OPENMP */
  do k = 1, km
    do j = jfirst, jlast
      do i = 1, im
        delpf(i,j,k) = delp(i,j,k)
      end do
    end do
    help_h = jn2g0-js2g0+1
    call pft2d( delpf(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,wk,wk2 )
  end do
#ifdef TIMING
call timing_off("cd_core_ad11")
#endif
endif
if ( .not. allocated(cd_core_tape_u_1h)) then
  allocate( cd_core_tape_u_1h(1:im,1:1+jlast+ng_s-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_u_1h(:,:,:,cd_core_tape_rec+1) = u
if ( .not. allocated(cd_core_tape_v_2h)) then
  allocate( cd_core_tape_v_2h(1:im,1:1+jlast+ng_d-(jfirst-ng_s),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_v_2h(:,:,:,cd_core_tape_rec+1) = v
if ( .not. allocated(cd_core_tape_delpf_3h)) then
  allocate( cd_core_tape_delpf_3h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_delpf_3h(:,:,:,cd_core_tape_rec+1) = delpf
if ( .not. allocated(cd_core_tape_delp_4h)) then
  allocate( cd_core_tape_delp_4h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_delp_4h(:,:,:,cd_core_tape_rec+1) = delp
if ( .not. allocated(cd_core_tape_pt_5h)) then
  allocate( cd_core_tape_pt_5h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pt_5h(:,:,:,cd_core_tape_rec+1) = pt
#ifdef TIMING
call timing_on("cd_core_ad12")
#endif
#ifdef USE_OPENMP
!$omp parallel do private(c_sw_tape_rec,iord,jord,k) schedule(dynamic)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    iord = 1
    jord = 1
  else
    iord = iord_c
    jord = jord_c
  endif
  c_sw_tape_rec = k-1+cd_core_tape_rec*km
  call c_swmd( u(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),pt(1,jfirst-ng_d,k),delp(1,jfirst,k),uc(1,jfirst-ng_d,k),vc(1,jfirst-2,k),&
&ptc(1,jfirst,k),delpf(1,jfirst-ng_d,k),ptk(1:im,jfirst:jlast,k),cosp,acosp,cose,coslon,sinlon,dxdt,dxe,dtdx2,dtdx4,dtxe5,rdxe,&
&dycp,dydt,dtdy5,cye,fc,ifax,trigs,dc(1,js2g0),sc,zt_c,tiny,rcap,im,jm,jfirst,jlast,ng_c,ng_d,ng_s,js2g0,jn2g0,js2gc,jn1gc,iord,&
&jord,cosl5,sinl5,c_sw_tape_rec )
end do
#ifdef TIMING
call timing_off("cd_core_ad12")
#endif
if ( .not. allocated(cd_core_tape_ptc_6h)) then
  allocate( cd_core_tape_ptc_6h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_ptc_6h(:,:,:,cd_core_tape_rec+1) = ptc
if ( .not. allocated(cd_core_tape_ptk_7h)) then
  allocate( cd_core_tape_ptk_7h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_ptk_7h(:,:,:,cd_core_tape_rec+1) = ptk
call geopk( ptop,pe,ptk,pkc,wz,hs,ptc,im,jm,km,jfirst,jlast,0,cp,akap,nx,0, .false.  )
if ( .not. allocated(cd_core_tape_pkc_8h)) then
  allocate( cd_core_tape_pkc_8h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_8h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_9h)) then
  allocate( cd_core_tape_wz_9h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_9h(:,:,:,cd_core_tape_rec+1) = wz
#ifdef TIMING
call timing_on("cd_core_ad13")
#endif
#ifdef USE_OPENMP
!$omp parallel do private(help_i,i,j,k,p1d,wk,wk2)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js2g0, jn2g0
    do i = 1, im
      p1d(i) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
    uc(1,j,k) = uc(1,j,k)+dtdx2(j)*((wz(im,j,k+1)-wz(1,j,k))*(pkc(1,j,k+1)-pkc(im,j,k))+(wz(im,j,k)-wz(1,j,k+1))*(pkc(im,j,k+1)-&
&pkc(1,j,k)))/(p1d(1)+p1d(im))
    do i = 2, im
      uc(i,j,k) = uc(i,j,k)+dtdx2(j)*((wz(i-1,j,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i-1,j,k))+(wz(i-1,j,k)-wz(i,j,k+1))*(pkc(i-1,j,k+&
&1)-pkc(i,j,k)))/(p1d(i)+p1d(i-1))
    end do
  end do
  help_i = jn2g0-js2g0+1
  call pft2d( uc(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,wk,wk2 )
end do
#ifdef TIMING
call timing_off("cd_core_ad13")
#endif
if ( .not. allocated(cd_core_tape_pkc_10h)) then
  allocate( cd_core_tape_pkc_10h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_10h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_11h)) then
  allocate( cd_core_tape_wz_11h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_11h(:,:,:,cd_core_tape_rec+1) = wz
#ifdef TIMING
call timing_on("cd_core_ad14")
#endif
#ifdef USE_OPENMP
!$omp parallel do private(help_j,i,j,k,wk,wk1)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js1g1, jlast
    do i = 1, im
      wk1(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      vc(i,j,k) = vc(i,j,k)+dtdy5/(wk1(i,j)+wk1(i,j-1))*((wz(i,j-1,k+1)-wz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j-1,k))+(wz(i,j-1,k)-wz(i,j,&
&k+1))*(pkc(i,j-1,k+1)-pkc(i,j,k)))
    end do
  end do
  help_j = jlast-js2g0+1
  call pft2d( vc(1,js2g0,k),se(js2g0),de(1,js2g0),im,help_j,ifax,trigs,wk,wk1 )
end do
#ifdef TIMING
call timing_off("cd_core_ad14")
#endif
if ( .not. allocated(cd_core_tape_u_12h)) then
  allocate( cd_core_tape_u_12h(1:im,1:1+jlast+ng_s-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_u_12h(:,:,:,cd_core_tape_rec+1) = u
if ( .not. allocated(cd_core_tape_v_13h)) then
  allocate( cd_core_tape_v_13h(1:im,1:1+jlast+ng_d-(jfirst-ng_s),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_v_13h(:,:,:,cd_core_tape_rec+1) = v
if ( .not. allocated(cd_core_tape_uc_14h)) then
  allocate( cd_core_tape_uc_14h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_uc_14h(:,:,:,cd_core_tape_rec+1) = uc
if ( .not. allocated(cd_core_tape_vc_15h)) then
  allocate( cd_core_tape_vc_15h(1:im,1:3+2+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_vc_15h(:,:,:,cd_core_tape_rec+1) = vc
if ( .not. allocated(cd_core_tape_pt_16h)) then
  allocate( cd_core_tape_pt_16h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pt_16h(:,:,:,cd_core_tape_rec+1) = pt
#ifdef TIMING
call timing_on("cd_core_ad15")
#endif
#ifdef USE_OPENMP
!$omp parallel do private(d_sw_tape_rec,iord,jord,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  if (k .lt. km/8) then
    if (k .eq. 1) then
      iord = 1
      jord = 1
    else
      iord = min(2,iord_d)
      jord = min(2,jord_d)
    endif
  else
    iord = iord_d
    jord = jord_d
  endif
  d_sw_tape_rec = k-1+cd_core_tape_rec*km
  call d_swmd( u(1,jfirst-ng_d,k),v(1,jfirst-ng_s,k),uc(1,jfirst-ng_d,k),vc(1,jfirst-2,k),pt(1,jfirst-ng_d,k),delp(1,jfirst,k),&
&delpf(1,jfirst-ng_d,k),cx3(1,jfirst-ng_d,k),cy3(1,jfirst,k),mfx(1,jfirst,k),mfy(1,jfirst,k),cdx(js2g0,k),cdy(js2g0,k),dtdx,&
&dtdxe,dtxe5,txe5,dyce,rdx,cyy,dx,f0(jfirst-ng_d),js2g0,jn1g1,im,jm,jfirst,jlast,ng_d,ng_s,nq,iord,jord,zt_d,rcap,tiny,dtdy,&
&dtdy5,tdy5,rdy,cosp,acosp,cose,coslon,sinlon,cosl5,sinl5,d_sw_tape_rec )
end do
#ifdef TIMING
call timing_off("cd_core_ad15")
#endif
if ( .not. allocated(cd_core_tape_delp_17h)) then
  allocate( cd_core_tape_delp_17h(1:im,1:1+jlast-jfirst,1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_delp_17h(:,:,:,cd_core_tape_rec+1) = delp
if ( .not. allocated(cd_core_tape_pt_18h)) then
  allocate( cd_core_tape_pt_18h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pt_18h(:,:,:,cd_core_tape_rec+1) = pt
call geopk( ptop,pe,delp,pkc,wz,hs,pt,im,jm,km,jfirst,jlast,ng_d,cp,akap,nx,ipe, .true.  )
if ( .not. allocated(cd_core_tape_pkc_19h)) then
  allocate( cd_core_tape_pkc_19h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_19h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_20h)) then
  allocate( cd_core_tape_wz_20h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_20h(:,:,:,cd_core_tape_rec+1) = wz
#ifdef TIMING
call timing_on("cd_core_ad16")
#endif
if (ipe .ne. 1) then
#ifdef USE_OPENMP
  !$omp parallel do private(help_k,i,j,k,wk,wk2)
#endif /* ! USE_OPENMP */
  do k = 1, km
    do j = jfirst, jlast
      do i = 1, im
        delpf(i,j,k) = delp(i,j,k)
      end do
    end do
    help_k = jn2g0-js2g0+1
    call pft2d( delpf(1,js2g0,k),sc(js2g0),dc(1,js2g0),im,help_k,ifax,trigs,wk,wk2 )
  end do
else
#ifdef USE_OPENMP
  !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
  do k = 1, km+1
    do j = jfirst, jlast
      do i = 1, im
        pk(i,j,k) = pkc(i,j,k)
      end do
    end do
  end do
endif
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
do k = 1, km
  do j = js1g1, jn1g1
    do i = 1, im
      dpt(i,j,k) = (wz(i,j,k+1)+wz(i,j,k))*(pkc(i,j,k+1)-pkc(i,j,k))
    end do
  end do
end do
#ifdef USE_OPENMP
!$omp parallel do private(i,j,k,pkchelp,wk1,wk3)
#endif /* ! USE_OPENMP */
do k = 2, km+1
  do j = js2g1, jn2g0
    wk3(1,j) = (wz(1,j,k)+wz(im,j,k))*(pkc(1,j,k)-pkc(im,j,k))
    do i = 2, im
      wk3(i,j) = (wz(i,j,k)+wz(i-1,j,k))*(pkc(i,j,k)-pkc(i-1,j,k))
    end do
  end do
  do j = js2g1, jn2g0
    do i = 1, im-1
      wk1(i,j) = wk3(i,j)+wk3(i+1,j)
    end do
    wk1(im,j) = wk3(im,j)+wk3(1,j)
  end do
  if (jfirst .eq. 1) then
    do i = 1, im
      wk1(i,1) = 0.
    end do
  endif
  if (jlast .eq. jm) then
    do i = 1, im
      wk1(i,jm) = 0.
    end do
  endif
  do j = js2g0, jlast
    do i = 1, im
      wz3(i,j,k) = wk1(i,j)+wk1(i,j-1)
    end do
  end do
  do j = js2g0, jn1g1
    do i = 1, im
      wk1(i,j) = (wz(i,j,k)+wz(i,j-1,k))*(pkc(i,j,k)-pkc(i,j-1,k))
    end do
  end do
  do j = js2g0, jn1g1
    wk3(1,j) = wk1(1,j)+wk1(im,j)
    do i = 2, im
      wk3(i,j) = wk1(i,j)+wk1(i-1,j)
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      wz(i,j,k) = wk3(i,j)+wk3(i,j+1)
    end do
  end do
  do j = jfirst-1, jlast+1
    do i = 1, im
      pkchelp(i,j) = pkc(i,j,k)
    end do
  end do
  call avgc( pkchelp,pkc(1,jfirst,k),im,jm,jfirst,jlast,wk1 )
end do
#ifdef TIMING
call timing_off("cd_core_ad16")
#endif
do j = js2g0, jlast
  do i = 1, im
    wz3(i,j,1) = 0.
    wz(i,j,1) = 0.
  end do
end do
pk4 = 4.*ptop**akap
do j = js2g0, jn1g1
  do i = 1, im
    pkc(i,j,1) = pk4
  end do
end do
if ( .not. allocated(cd_core_tape_pkc_21h)) then
  allocate( cd_core_tape_pkc_21h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_pkc_21h(:,:,:,cd_core_tape_rec+1) = pkc
if ( .not. allocated(cd_core_tape_wz_22h)) then
  allocate( cd_core_tape_wz_22h(1:im,1:2+1+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz_22h(:,:,:,cd_core_tape_rec+1) = wz
if ( .not. allocated(cd_core_tape_wz3_23h)) then
  allocate( cd_core_tape_wz3_23h(1:im,1:2+jlast-jfirst,1:1+km,cd_core_tape_cd_core_do) )
endif
cd_core_tape_wz3_23h(:,:,:,cd_core_tape_rec+1) = wz3
#ifdef TIMING
call timing_on("cd_core_ad17")
#endif
#ifdef USE_OPENMP
!$omp parallel do private(help_l,help_m,i,j,k,wk,wk1,wk2,wk3)
#endif /* ! USE_OPENMP */
do k = 1, km
  call avgc( dpt(1,jfirst-1,k),wk2(1,jfirst),im,jm,jfirst,jlast,wk1 )
  do j = js2g0, jn1g1
    do i = 1, im
      wk(i,j) = pkc(i,j,k+1)-pkc(i,j,k)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im-1
      wk3(i,j) = uc(i,j,k)+dtdxe(j)/(wk(i,j)+wk(i+1,j))*(wk2(i,j)-wk2(i+1,j)+wz3(i,j,k+1)-wz3(i,j,k))
    end do
    wk3(im,j) = uc(im,j,k)+dtdxe(j)/(wk(im,j)+wk(1,j))*(wk2(im,j)-wk2(1,j)+wz3(im,j,k+1)-wz3(im,j,k))
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      wk1(i,j) = vc(i,j,k)+dtdy/(wk(i,j)+wk(i,j+1))*(wk2(i,j)-wk2(i,j+1)+wz(i,j,k+1)-wz(i,j,k))
    end do
  end do
  help_l = jlast-js2g0+1
  call pft2d( wk3(1,js2g0),se(js2g0),de(1,js2g0),im,help_l,ifax,trigs,wk,wk2 )
  help_m = jn2g0-js2g0+1
  call pft2d( wk1(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_m,ifax,trigs,wk,wk2 )
  do j = js2g0, jlast
    do i = 1, im
      u(i,j,k) = u(i,j,k)+wk3(i,j)
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      v(i,j,k) = v(i,j,k)+wk1(i,j)
    end do
  end do
end do
#ifdef TIMING
call timing_off("cd_core_ad17")
#endif
end subroutine cd_core_domd

end module     cd_core_ad
#endif /* SPMD */
