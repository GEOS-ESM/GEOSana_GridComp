#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine d2a2_ad( u_ae, v_ae, ua_ad, va_ad, im, jm, jfirst, jlast, ng_d, coslon, sinlon )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: ng_d
real(kind=r8) :: coslon(im)
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u_ae(im,jfirst:jlast)
real(kind=r8) :: ua_ad(im,jfirst-ng_d:jlast)
real(kind=r8) :: v_ae(im,jfirst:jlast)
real(kind=r8) :: va_ad(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: imh
integer :: j
integer :: jn2g0
integer :: js2g0
real(kind=r8) :: un_ad
real(kind=r8) :: us_ad
real(kind=r8) :: vn_ad
real(kind=r8) :: vs_ad
integer :: jstart

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
un_ad = 0.d0
us_ad = 0.d0
vn_ad = 0.d0
vs_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
imh = im/2
jn2g0 = min(jlast,jm-1)
js2g0 = max(jfirst,2)
if (jlast .eq. jm) then
  do i = 1, imh
    va_ad(i,jm) = va_ad(i,jm)-va_ad(i+imh,jm)
    va_ad(i+imh,jm) = 0.d0
    ua_ad(i,jm) = ua_ad(i,jm)-ua_ad(i+imh,jm)
    ua_ad(i+imh,jm) = 0.d0
    un_ad = un_ad-va_ad(i,jm)*coslon(i)
    vn_ad = vn_ad-va_ad(i,jm)*sinlon(i)
    va_ad(i,jm) = 0.d0
    un_ad = un_ad-ua_ad(i,jm)*sinlon(i)
    vn_ad = vn_ad+ua_ad(i,jm)*coslon(i)
    ua_ad(i,jm) = 0.d0
  end do
  vn_ad = vn_ad/dble(im)
  un_ad = un_ad/dble(im)
  do i = 1, imh
    ua_ad(i+imh,jm-1) = ua_ad(i+imh,jm-1)-vn_ad*coslon(i)
    ua_ad(i,jm-1) = ua_ad(i,jm-1)+vn_ad*coslon(i)
    va_ad(i+imh,jm-1) = va_ad(i+imh,jm-1)+vn_ad*sinlon(i)
    va_ad(i,jm-1) = va_ad(i,jm-1)-vn_ad*sinlon(i)
    ua_ad(i+imh,jm-1) = ua_ad(i+imh,jm-1)+un_ad*sinlon(i)
    ua_ad(i,jm-1) = ua_ad(i,jm-1)-un_ad*sinlon(i)
    va_ad(i+imh,jm-1) = va_ad(i+imh,jm-1)+un_ad*coslon(i)
    va_ad(i,jm-1) = va_ad(i,jm-1)-un_ad*coslon(i)
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, imh
    va_ad(i,1) = va_ad(i,1)-va_ad(i+imh,1)
    va_ad(i+imh,1) = 0.d0
    ua_ad(i,1) = ua_ad(i,1)-ua_ad(i+imh,1)
    ua_ad(i+imh,1) = 0.d0
    us_ad = us_ad+va_ad(i,1)*coslon(i)
    vs_ad = vs_ad-va_ad(i,1)*sinlon(i)
    va_ad(i,1) = 0.d0
    us_ad = us_ad-ua_ad(i,1)*sinlon(i)
    vs_ad = vs_ad-ua_ad(i,1)*coslon(i)
    ua_ad(i,1) = 0.d0
  end do
  vs_ad = vs_ad/dble(im)
  us_ad = us_ad/dble(im)
  do i = 1, imh
    ua_ad(i+imh,2) = ua_ad(i+imh,2)+vs_ad*coslon(i)
    ua_ad(i,2) = ua_ad(i,2)-vs_ad*coslon(i)
    va_ad(i+imh,2) = va_ad(i+imh,2)+vs_ad*sinlon(i)
    va_ad(i,2) = va_ad(i,2)-vs_ad*sinlon(i)
    ua_ad(i+imh,2) = ua_ad(i+imh,2)+us_ad*sinlon(i)
    ua_ad(i,2) = ua_ad(i,2)-us_ad*sinlon(i)
    va_ad(i+imh,2) = va_ad(i+imh,2)-us_ad*coslon(i)
    va_ad(i,2) = va_ad(i,2)+us_ad*coslon(i)
  end do
endif
do j = js2g0, jn2g0
  v_ae(im,j) = v_ae(im,j)+0.5*va_ad(im,j)
  v_ae(1,j) = v_ae(1,j)+0.5*va_ad(im,j)
  va_ad(im,j) = 0.d0
  do i = 1, im-1
    v_ae(i+1,j) = v_ae(i+1,j)+0.5*va_ad(i,j)
    v_ae(i,j) = v_ae(i,j)+0.5*va_ad(i,j)
    va_ad(i,j) = 0.d0
  end do
end do
!do j = js2g0, jlast-1
if(js2g0 == 2) then
   u_ae(:,js2g0) = u_ae(:,js2g0)+0.5*ua_ad(:,js2g0)
   jstart = js2g0+1
else 
   jstart = js2g0
endif
if(jn2g0 == jm-1) u_ae(:,jm) = u_ae(:,jm)+0.5*ua_ad(:,jm-1)
!do j = js2g0, jn2g0
do j = jstart, jn2g0
  do i = 1, im
!    u_ae(i,j+1) = u_ae(i,j+1)+0.5*ua_ad(i,j)
    u_ae(i,j) = u_ae(i,j)+0.5*(ua_ad(i,j-1)+ua_ad(i,j))
  end do
end do
ua_ad(:,:) = 0.d0

end subroutine d2a2_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine d2a2_ad( u_ae, v_ae, ua_ad, va_ad, im, jm, jfirst, jlast, ng_d, coslon, sinlon )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: ng_d
real(kind=r8) :: coslon(im)
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u_ae(im,jfirst:jlast)
real(kind=r8) :: ua_ad(im,jfirst:jlast)
real(kind=r8) :: v_ae(im,jfirst:jlast)
real(kind=r8) :: va_ad(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: imh
integer :: j
integer :: jn2g0
integer :: js2g0
real(kind=r8) :: un_ad
real(kind=r8) :: us_ad
real(kind=r8) :: vn_ad
real(kind=r8) :: vs_ad

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
un_ad = 0.d0
us_ad = 0.d0
vn_ad = 0.d0
vs_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
imh = im/2
jn2g0 = min(jlast,jm-1)
js2g0 = max(jfirst,2)
if (jlast .eq. jm) then
  do i = 1, imh
    va_ad(i,jm) = va_ad(i,jm)-va_ad(i+imh,jm)
    va_ad(i+imh,jm) = 0.d0
    ua_ad(i,jm) = ua_ad(i,jm)-ua_ad(i+imh,jm)
    ua_ad(i+imh,jm) = 0.d0
    un_ad = un_ad-va_ad(i,jm)*coslon(i)
    vn_ad = vn_ad-va_ad(i,jm)*sinlon(i)
    va_ad(i,jm) = 0.d0
    un_ad = un_ad-ua_ad(i,jm)*sinlon(i)
    vn_ad = vn_ad+ua_ad(i,jm)*coslon(i)
    ua_ad(i,jm) = 0.d0
  end do
  vn_ad = vn_ad/dble(im)
  un_ad = un_ad/dble(im)
  do i = 1, imh
    ua_ad(i+imh,jm-1) = ua_ad(i+imh,jm-1)-vn_ad*coslon(i)
    ua_ad(i,jm-1) = ua_ad(i,jm-1)+vn_ad*coslon(i)
    va_ad(i+imh,jm-1) = va_ad(i+imh,jm-1)+vn_ad*sinlon(i)
    va_ad(i,jm-1) = va_ad(i,jm-1)-vn_ad*sinlon(i)
    ua_ad(i+imh,jm-1) = ua_ad(i+imh,jm-1)+un_ad*sinlon(i)
    ua_ad(i,jm-1) = ua_ad(i,jm-1)-un_ad*sinlon(i)
    va_ad(i+imh,jm-1) = va_ad(i+imh,jm-1)+un_ad*coslon(i)
    va_ad(i,jm-1) = va_ad(i,jm-1)-un_ad*coslon(i)
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, imh
    va_ad(i,1) = va_ad(i,1)-va_ad(i+imh,1)
    va_ad(i+imh,1) = 0.d0
    ua_ad(i,1) = ua_ad(i,1)-ua_ad(i+imh,1)
    ua_ad(i+imh,1) = 0.d0
    us_ad = us_ad+va_ad(i,1)*coslon(i)
    vs_ad = vs_ad-va_ad(i,1)*sinlon(i)
    va_ad(i,1) = 0.d0
    us_ad = us_ad-ua_ad(i,1)*sinlon(i)
    vs_ad = vs_ad-ua_ad(i,1)*coslon(i)
    ua_ad(i,1) = 0.d0
  end do
  vs_ad = vs_ad/dble(im)
  us_ad = us_ad/dble(im)
  do i = 1, imh
    ua_ad(i+imh,2) = ua_ad(i+imh,2)+vs_ad*coslon(i)
    ua_ad(i,2) = ua_ad(i,2)-vs_ad*coslon(i)
    va_ad(i+imh,2) = va_ad(i+imh,2)+vs_ad*sinlon(i)
    va_ad(i,2) = va_ad(i,2)-vs_ad*sinlon(i)
    ua_ad(i+imh,2) = ua_ad(i+imh,2)+us_ad*sinlon(i)
    ua_ad(i,2) = ua_ad(i,2)-us_ad*sinlon(i)
    va_ad(i+imh,2) = va_ad(i+imh,2)-us_ad*coslon(i)
    va_ad(i,2) = va_ad(i,2)+us_ad*coslon(i)
  end do
endif
do j = js2g0, jn2g0
  v_ae(im,j) = v_ae(im,j)+0.5*va_ad(im,j)
  v_ae(1,j) = v_ae(1,j)+0.5*va_ad(im,j)
  va_ad(im,j) = 0.d0
  do i = 1, im-1
    v_ae(i+1,j) = v_ae(i+1,j)+0.5*va_ad(i,j)
    v_ae(i,j) = v_ae(i,j)+0.5*va_ad(i,j)
    va_ad(i,j) = 0.d0
  end do
end do
do j = js2g0, jlast-1
  do i = 1, im
    u_ae(i,j+1) = u_ae(i,j+1)+0.5*ua_ad(i,j)
    u_ae(i,j) = u_ae(i,j)+0.5*ua_ad(i,j)
    ua_ad(i,j) = 0.d0
  end do
end do

end subroutine d2a2_ad


#endif /* SPMD */
