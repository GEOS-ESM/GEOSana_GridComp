#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fill_module_tl
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fill_module

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine filew_tl( q, q_tm, im, jm, jfirst, jlast, acap, ipx, tiny, cosp2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
real(kind=r8) :: cosp2
integer :: im
integer :: ipx
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: q(im,jfirst:jlast)
real(kind=r8) :: q_tm(im,jfirst:jlast)
real(kind=r8) :: tiny

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: d0
real(kind=r8) :: d0_tl
real(kind=r8) :: d1
real(kind=r8) :: d1_tl
real(kind=r8) :: d2
real(kind=r8) :: d2_tl
integer :: i
integer :: ip2
integer :: j
integer :: j1
integer :: j2
integer :: jm1
real(kind=r8) :: qtmp(jfirst:jlast,im)
real(kind=r8) :: qtmp_tl(jfirst:jlast,im)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
j1 = max(jfirst,2)
j2 = min(jlast,jm-1)
jm1 = jm-1
ipx = 0
do i = 1, im
  do j = j1, j2
    qtmp_tl(j,i) = q_tm(i,j)
    qtmp(j,i) = q(i,j)
  end do
end do
do i = 2, im-1
  do j = j1, j2
    if (qtmp(j,i) .lt. 0.) then
      ipx = 1
      d0_tl = qtmp_tl(j,i-1)*(0.5-sign(0.5d0,0._8-qtmp(j,i-1)))
      d0 = max(0._8,qtmp(j,i-1))
      d1_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
      d1 = min(-qtmp(j,i),d0)
      qtmp_tl(j,i-1) = (-d1_tl)+qtmp_tl(j,i-1)
      qtmp(j,i-1) = qtmp(j,i-1)-d1
      qtmp_tl(j,i) = d1_tl+qtmp_tl(j,i)
      qtmp(j,i) = qtmp(j,i)+d1
      d0_tl = qtmp_tl(j,i+1)*(0.5-sign(0.5d0,0._8-qtmp(j,i+1)))
      d0 = max(0._8,qtmp(j,i+1))
      d2_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
      d2 = min(-qtmp(j,i),d0)
      qtmp_tl(j,i+1) = (-d2_tl)+qtmp_tl(j,i+1)
      qtmp(j,i+1) = qtmp(j,i+1)-d2
      qtmp_tl(j,i) = d2_tl+qtmp_tl(j,i)
      qtmp(j,i) = qtmp(j,i)+d2+tiny
    endif
  end do
end do
i = 1
do j = j1, j2
  if (qtmp(j,i) .lt. 0.) then
    ipx = 1
    d0_tl = qtmp_tl(j,im)*(0.5-sign(0.5d0,0._8-qtmp(j,im)))
    d0 = max(0._8,qtmp(j,im))
    d1_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d1 = min(-qtmp(j,i),d0)
    qtmp_tl(j,im) = (-d1_tl)+qtmp_tl(j,im)
    qtmp(j,im) = qtmp(j,im)-d1
    qtmp_tl(j,i) = d1_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d1
    d0_tl = qtmp_tl(j,i+1)*(0.5-sign(0.5d0,0._8-qtmp(j,i+1)))
    d0 = max(0._8,qtmp(j,i+1))
    d2_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d2 = min(-qtmp(j,i),d0)
    qtmp_tl(j,i+1) = (-d2_tl)+qtmp_tl(j,i+1)
    qtmp(j,i+1) = qtmp(j,i+1)-d2
    qtmp_tl(j,i) = d2_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d2+tiny
  endif
end do
i = im
do j = j1, j2
  if (qtmp(j,i) .lt. 0.) then
    ipx = 1
    d0_tl = qtmp_tl(j,i-1)*(0.5-sign(0.5d0,0._8-qtmp(j,i-1)))
    d0 = max(0._8,qtmp(j,i-1))
    d1_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d1 = min(-qtmp(j,i),d0)
    qtmp_tl(j,i-1) = (-d1_tl)+qtmp_tl(j,i-1)
    qtmp(j,i-1) = qtmp(j,i-1)-d1
    qtmp_tl(j,i) = d1_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d1
    d0_tl = qtmp_tl(j,1)*(0.5-sign(0.5d0,0._8-qtmp(j,1)))
    d0 = max(0._8,qtmp(j,1))
    d2_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d2 = min(-qtmp(j,i),d0)
    qtmp_tl(j,1) = (-d2_tl)+qtmp_tl(j,1)
    qtmp(j,1) = qtmp(j,1)-d2
    qtmp_tl(j,i) = d2_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d2+tiny
  endif
end do
if (ipx .ne. 0) then
  do i = 1, im-1
    do j = j1, j2
      if (qtmp(j,i) .lt. 0.) then
        qtmp_tl(j,i+1) = qtmp_tl(j,i+1)+qtmp_tl(j,i)
        qtmp(j,i+1) = qtmp(j,i+1)+qtmp(j,i)
        qtmp_tl(j,i) = 0.d0
        qtmp(j,i) = 0.
      endif
    end do
  end do
  do i = im, 2, -1
    do j = j1, j2
      if (qtmp(j,i) .lt. 0.) then
        qtmp_tl(j,i-1) = qtmp_tl(j,i-1)+qtmp_tl(j,i)
        qtmp(j,i-1) = qtmp(j,i-1)+qtmp(j,i)
        qtmp_tl(j,i) = 0.d0
        qtmp(j,i) = 0.
      endif
    end do
  end do
  do j = j1, j2
    do i = 1, im
      q_tm(i,j) = qtmp_tl(j,i)
      q(i,j) = qtmp(j,i)
    end do
  end do
endif
if (jfirst .eq. 1) then
  if (q(1,1) .lt. 0.) then
    call pfix_tl( q(1,2),q_tm(1,2),q(1,1),q_tm(1,1),im,ipx,acap,cosp2 )
  else
    ip2 = 0
    do i = 1, im
      if (q(i,2) .lt. 0.) then
        ip2 = 1
        exit
      endif
    end do
    if (ip2 .ne. 0) then
      call pfix_tl( q(1,2),q_tm(1,2),q(1,1),q_tm(1,1),im,ipx,acap,cosp2 )
    endif
  endif
endif
if (jlast .eq. jm) then
  if (q(1,jm) .lt. 0.) then
    call pfix_tl( q(1,jm1),q_tm(1,jm1),q(1,jm),q_tm(1,jm),im,ipx,acap,cosp2 )
  else
    ip2 = 0
    do i = 1, im
      if (q(i,jm1) .lt. 0.) then
        ip2 = 1
        exit
      endif
    end do
    if (ip2 .ne. 0) then
      call pfix_tl( q(1,jm1),q_tm(1,jm1),q(1,jm),q_tm(1,jm),im,ipx,acap,cosp2 )
    endif
  endif
endif

end subroutine filew_tl


subroutine fillxy_tl( q, q_tm, im, jm, jfirst, jlast, acap, cosp )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real(kind=r8), parameter :: tiny = 1.e-20

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
integer :: jm
real(kind=r8) :: cosp(jm)
integer :: im
integer :: jfirst
integer :: jlast
real(kind=r8) :: q(im,jfirst:jlast)
real(kind=r8) :: q_tm(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: ipx

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call filew_tl( q,q_tm,im,jm,jfirst,jlast,acap,ipx,tiny,cosp(2) )

end subroutine fillxy_tl


subroutine pfix_tl( q, q_tm, qp, qp_tl, im, ipx, acap, cosp2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
real(kind=r8) :: cosp2
integer :: im
integer :: ipx
real(kind=r8) :: q(im)
real(kind=r8) :: q_tm(im)
real(kind=r8) :: qp(im)
real(kind=r8) :: qp_tl(im)

!==============================================
! declare local variables
!==============================================
integer :: i
real(kind=r8) :: pmean
real(kind=r8) :: pmean_tl
real(kind=r8) :: summ
real(kind=r8) :: summ_tl
real(kind=r8) :: sump
real(kind=r8) :: sump_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
summ_tl = 0.d0
summ = 0.
sump_tl = 0.d0
sump = 0.
do i = 1, im
  summ_tl = q_tm(i)+summ_tl
  summ = summ+q(i)
  sump_tl = qp_tl(i)+sump_tl
  sump = sump+qp(i)
end do
sump_tl = sump_tl/dble(im)
sump = sump/im
pmean_tl = summ_tl*(cosp2/(acap+cosp2*im))+sump_tl*(acap/(acap+cosp2*im))
pmean = (sump*acap+summ*cosp2)/(acap+cosp2*im)
do i = 1, im
  q_tm(i) = pmean_tl
  q(i) = pmean
  qp_tl(i) = pmean_tl
  qp(i) = pmean
end do

end subroutine pfix_tl


end module     fill_module_tl


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fill_module_tl
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fill_module

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine filew_tl( q, q_tm, im, jm, jfirst, jlast, acap, ipx, tiny, cosp2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
real(kind=r8) :: cosp2
integer :: im
integer :: ipx
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: q(im,jfirst:jlast)
real(kind=r8) :: q_tm(im,jfirst:jlast)
real(kind=r8) :: tiny

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: d0
real(kind=r8) :: d0_tl
real(kind=r8) :: d1
real(kind=r8) :: d1_tl
real(kind=r8) :: d2
real(kind=r8) :: d2_tl
integer :: i
integer :: ip2
integer :: j
integer :: j1
integer :: j2
integer :: jm1
real(kind=r8) :: qtmp(jfirst:jlast,im)
real(kind=r8) :: qtmp_tl(jfirst:jlast,im)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
j1 = max(jfirst,2)
j2 = min(jlast,jm-1)
jm1 = jm-1
ipx = 0
do i = 1, im
  do j = j1, j2
    qtmp_tl(j,i) = q_tm(i,j)
    qtmp(j,i) = q(i,j)
  end do
end do
do i = 2, im-1
  do j = j1, j2
    if (qtmp(j,i) .lt. 0.) then
      ipx = 1
      d0_tl = qtmp_tl(j,i-1)*(0.5-sign(0.5d0,0._8-qtmp(j,i-1)))
      d0 = max(0._8,qtmp(j,i-1))
      d1_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
      d1 = min(-qtmp(j,i),d0)
      qtmp_tl(j,i-1) = (-d1_tl)+qtmp_tl(j,i-1)
      qtmp(j,i-1) = qtmp(j,i-1)-d1
      qtmp_tl(j,i) = d1_tl+qtmp_tl(j,i)
      qtmp(j,i) = qtmp(j,i)+d1
      d0_tl = qtmp_tl(j,i+1)*(0.5-sign(0.5d0,0._8-qtmp(j,i+1)))
      d0 = max(0._8,qtmp(j,i+1))
      d2_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
      d2 = min(-qtmp(j,i),d0)
      qtmp_tl(j,i+1) = (-d2_tl)+qtmp_tl(j,i+1)
      qtmp(j,i+1) = qtmp(j,i+1)-d2
      qtmp_tl(j,i) = d2_tl+qtmp_tl(j,i)
      qtmp(j,i) = qtmp(j,i)+d2+tiny
    endif
  end do
end do
i = 1
do j = j1, j2
  if (qtmp(j,i) .lt. 0.) then
    ipx = 1
    d0_tl = qtmp_tl(j,im)*(0.5-sign(0.5d0,0._8-qtmp(j,im)))
    d0 = max(0._8,qtmp(j,im))
    d1_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d1 = min(-qtmp(j,i),d0)
    qtmp_tl(j,im) = (-d1_tl)+qtmp_tl(j,im)
    qtmp(j,im) = qtmp(j,im)-d1
    qtmp_tl(j,i) = d1_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d1
    d0_tl = qtmp_tl(j,i+1)*(0.5-sign(0.5d0,0._8-qtmp(j,i+1)))
    d0 = max(0._8,qtmp(j,i+1))
    d2_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d2 = min(-qtmp(j,i),d0)
    qtmp_tl(j,i+1) = (-d2_tl)+qtmp_tl(j,i+1)
    qtmp(j,i+1) = qtmp(j,i+1)-d2
    qtmp_tl(j,i) = d2_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d2+tiny
  endif
end do
i = im
do j = j1, j2
  if (qtmp(j,i) .lt. 0.) then
    ipx = 1
    d0_tl = qtmp_tl(j,i-1)*(0.5-sign(0.5d0,0._8-qtmp(j,i-1)))
    d0 = max(0._8,qtmp(j,i-1))
    d1_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d1 = min(-qtmp(j,i),d0)
    qtmp_tl(j,i-1) = (-d1_tl)+qtmp_tl(j,i-1)
    qtmp(j,i-1) = qtmp(j,i-1)-d1
    qtmp_tl(j,i) = d1_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d1
    d0_tl = qtmp_tl(j,1)*(0.5-sign(0.5d0,0._8-qtmp(j,1)))
    d0 = max(0._8,qtmp(j,1))
    d2_tl = d0_tl*(0.5-sign(0.5d0,d0-(-qtmp(j,i))))-qtmp_tl(j,i)*(0.5+sign(0.5d0,d0-(-qtmp(j,i))))
    d2 = min(-qtmp(j,i),d0)
    qtmp_tl(j,1) = (-d2_tl)+qtmp_tl(j,1)
    qtmp(j,1) = qtmp(j,1)-d2
    qtmp_tl(j,i) = d2_tl+qtmp_tl(j,i)
    qtmp(j,i) = qtmp(j,i)+d2+tiny
  endif
end do
if (ipx .ne. 0) then
  do i = 1, im-1
    do j = j1, j2
      if (qtmp(j,i) .lt. 0.) then
        qtmp_tl(j,i+1) = qtmp_tl(j,i+1)+qtmp_tl(j,i)
        qtmp(j,i+1) = qtmp(j,i+1)+qtmp(j,i)
        qtmp_tl(j,i) = 0.d0
        qtmp(j,i) = 0.
      endif
    end do
  end do
  do i = im, 2, -1
    do j = j1, j2
      if (qtmp(j,i) .lt. 0.) then
        qtmp_tl(j,i-1) = qtmp_tl(j,i-1)+qtmp_tl(j,i)
        qtmp(j,i-1) = qtmp(j,i-1)+qtmp(j,i)
        qtmp_tl(j,i) = 0.d0
        qtmp(j,i) = 0.
      endif
    end do
  end do
  do j = j1, j2
    do i = 1, im
      q_tm(i,j) = qtmp_tl(j,i)
      q(i,j) = qtmp(j,i)
    end do
  end do
endif
if (jfirst .eq. 1) then
  if (q(1,1) .lt. 0.) then
    call pfix_tl( q(1,2),q_tm(1,2),q(1,1),q_tm(1,1),im,ipx,acap,cosp2 )
  else
    ip2 = 0
    do i = 1, im
      if (q(i,2) .lt. 0.) then
        ip2 = 1
        exit
      endif
    end do
    if (ip2 .ne. 0) then
      call pfix_tl( q(1,2),q_tm(1,2),q(1,1),q_tm(1,1),im,ipx,acap,cosp2 )
    endif
  endif
endif
if (jlast .eq. jm) then
  if (q(1,jm) .lt. 0.) then
    call pfix_tl( q(1,jm1),q_tm(1,jm1),q(1,jm),q_tm(1,jm),im,ipx,acap,cosp2 )
  else
    ip2 = 0
    do i = 1, im
      if (q(i,jm1) .lt. 0.) then
        ip2 = 1
        exit
      endif
    end do
    if (ip2 .ne. 0) then
      call pfix_tl( q(1,jm1),q_tm(1,jm1),q(1,jm),q_tm(1,jm),im,ipx,acap,cosp2 )
    endif
  endif
endif

end subroutine filew_tl


subroutine fillxy_tl( q, q_tm, im, jm, jfirst, jlast, acap, cosp )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
real(kind=r8), parameter :: tiny = 1.e-20

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
integer :: jm
real(kind=r8) :: cosp(jm)
integer :: im
integer :: jfirst
integer :: jlast
real(kind=r8) :: q(im,jfirst:jlast)
real(kind=r8) :: q_tm(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: ipx

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call filew_tl( q,q_tm,im,jm,jfirst,jlast,acap,ipx,tiny,cosp(2) )

end subroutine fillxy_tl


subroutine pfix_tl( q, q_tm, qp, qp_tl, im, ipx, acap, cosp2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: acap
real(kind=r8) :: cosp2
integer :: im
integer :: ipx
real(kind=r8) :: q(im)
real(kind=r8) :: q_tm(im)
real(kind=r8) :: qp(im)
real(kind=r8) :: qp_tl(im)

!==============================================
! declare local variables
!==============================================
integer :: i
real(kind=r8) :: pmean
real(kind=r8) :: pmean_tl
real(kind=r8) :: summ
real(kind=r8) :: summ_tl
real(kind=r8) :: sump
real(kind=r8) :: sump_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
summ_tl = 0.d0
summ = 0.
sump_tl = 0.d0
sump = 0.
do i = 1, im
  summ_tl = q_tm(i)+summ_tl
  summ = summ+q(i)
  sump_tl = qp_tl(i)+sump_tl
  sump = sump+qp(i)
end do
sump_tl = sump_tl/dble(im)
sump = sump/im
pmean_tl = summ_tl*(cosp2/(acap+cosp2*im))+sump_tl*(acap/(acap+cosp2*im))
pmean = (sump*acap+summ*cosp2)/(acap+cosp2*im)
do i = 1, im
  q_tm(i) = pmean_tl
  q(i) = pmean
  qp_tl(i) = pmean_tl
  qp(i) = pmean
end do

end subroutine pfix_tl


end module     fill_module_tl


#endif /* SPMD */
