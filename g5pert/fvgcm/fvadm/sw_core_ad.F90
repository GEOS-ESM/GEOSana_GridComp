#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     c_sw_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real(kind=8), allocatable :: c_sw_tape1_a6_5h(:,:)
integer :: c_sw_tape1_c_sw
real(kind=8), allocatable :: c_sw_tape1_crx_9h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_ptk_4h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_tm2_3h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_tm2_7h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_v2_6h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_xfx_1h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_yfx_2h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_ymass_8h(:,:,:)
real(kind=8), allocatable :: c_sw_tape2_a6_1h(:,:)
integer :: c_sw_tape2_c_sw
real(kind=8), allocatable :: c_sw_tape2_slope_2h(:,:)

end module     c_sw_ad_store


module     d_sw_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: d_sw_tape1_d_sw
real(kind=8), allocatable :: d_sw_tape1_delp_5h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_delpf_1h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_ub_6h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_uc_7h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_wk1_4h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_xfx_2h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_yfx_3h(:,:,:)
real(kind=8), allocatable :: d_sw_tapej_a6_1h(:,:)
integer :: d_sw_tapej_d_sw
real(kind=8), allocatable :: d_sw_tapej_slope_2h(:,:)

end module     d_sw_ad_store


module     sw_core_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sw_core

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine c_sw_ad( u, u_ae, v, v_ae, pt, pt_ae, delp, delp_ae, uc, uc_ad, vc, vc_ad, ptc_ad, delpf, delpf_ad, ptk, ptk_ad, cosp, &
&acosp, cose, coslon, sinlon, dxdt, dxe, dtdx2, dtdx4, dtxe5, rdxe, dycp, dydt, dtdy5, cye, ifax, trigs, dc, sc, zt_c, tiny, rcap, &
&im, jm, jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_ad
use c_sw_ad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_ptk_4h,c_sw_tape1_tm2_3h,c_sw_tape1_tm2_7h,&
&c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,c_sw_tape1_yfx_2h,c_sw_tape1_ymass_8h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
real(kind=r8), intent(in) :: cye(jm)
integer, intent(in) :: jn2g0
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: dc(im,js2g0:jn2g0)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real(kind=r8), intent(in) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delp_ae(im,jfirst:jlast)
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: delpf_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dxdt(jm)
real(kind=r8), intent(in) :: dxe(jm)
real(kind=r8), intent(in) :: dycp(jm)
real(kind=r8), intent(in) :: dydt
integer, intent(in) :: ifax(13)
integer, intent(in) :: iord
integer, intent(in) :: jn1gc
integer, intent(in) :: jord
integer, intent(in) :: js2gc
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: pt_ae(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: ptc_ad(im,jfirst:jlast)
real(kind=r8), intent(out) :: ptk(im,jfirst:jlast)
real(kind=r8), intent(inout) :: ptk_ad(im,jfirst:jlast)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdxe(jm)
real(kind=r8), intent(in) :: sc(js2g0:jn2g0)
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: trigs(3*im/2+1)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: u_ae(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: uc_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: v_ae(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(inout) :: vc_ad(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6_ad(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: crx_ad(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cry_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
real(kind=r8) :: cx1_ad(im)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fx_ad(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxj_ad(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
real(kind=r8) :: fy_ad(im,jfirst-1:jlast+1)
integer :: help_h
integer :: help_i
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js1g1
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1d_ad(im)
real(kind=r8) :: p1ke_ad
real(kind=r8) :: p2ke_ad
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_ad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_ad(1+im+2*(im/3))
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: tm2_ad(im,jfirst:jlast)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: u2_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: un_ad
real(kind=r8) :: us
real(kind=r8) :: us_ad
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: v2_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: va_ad(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vn_ad
real(kind=r8) :: vs
real(kind=r8) :: vs_ad
real(kind=r8) :: wk1_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfx_ad(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfx_ad(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)
real(kind=r8) :: ymass_ad(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6_ad(:) = 0.d0
crx_ad(:,:) = 0.d0
cry_ad(:,:) = 0.d0
cx1_ad(:) = 0.d0
fx_ad(:,:) = 0.d0
fxj_ad(:) = 0.d0
fy_ad(:,:) = 0.d0
p1d_ad(:) = 0.d0
p1ke_ad = 0.d0
p2ke_ad = 0.d0
qtmph_ad(:) = 0.d0
slopeh_ad(:) = 0.d0
tm2_ad(:,:) = 0.d0
u2_ad(:,:) = 0.d0
un_ad = 0.d0
us_ad = 0.d0
v2_ad(:,:) = 0.d0
va_ad(:,:) = 0.d0
vn_ad = 0.d0
vs_ad = 0.d0
wk1_ad(:,:) = 0.d0
xfx_ad(:,:) = 0.d0
yfx_ad(:,:) = 0.d0
ymass_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
im2 = im/2
js1g1 = max(1,jfirst-1)
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
xfx = c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1)
yfx = c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
help_h = jn2g0-js2g0+1
help_i = jn2g0-js2g0+1
ptk(:,:) = c_sw_tape1_ptk_4h(:,:,c_sw_tape_rec+1)
a6 = c_sw_tape1_a6_5h(:,c_sw_tape_rec+1)
do j = js1g1, jlast
  do i = 1, im
    cry(i,j) = dtdy5*v(i,j)
  end do
end do
v2 = c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1)
tm2 = c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1)
ymass = c_sw_tape1_ymass_8h(:,:,c_sw_tape_rec+1)
crx = c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1)
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jlast
  fx_ad(1,j) = fx_ad(1,j)-vc_ad(im,j)*dxe(j)
  wk1_ad(im,j-1) = wk1_ad(im,j-1)+vc_ad(im,j)*dtdy5
  wk1_ad(im,j) = wk1_ad(im,j)-vc_ad(im,j)*dtdy5
  do i = 1, im-1
    fx_ad(i+1,j) = fx_ad(i+1,j)-vc_ad(i,j)*dxe(j)
    wk1_ad(i,j-1) = wk1_ad(i,j-1)+vc_ad(i,j)*dtdy5
    wk1_ad(i,j) = wk1_ad(i,j)-vc_ad(i,j)*dtdy5
  end do
end do
do j = js2g0, jn2g0
  do i = 2, im
    fy_ad(i,j) = fy_ad(i,j)+uc_ad(i,j)*dycp(j)
    wk1_ad(i-1,j) = wk1_ad(i-1,j)+uc_ad(i,j)*dtdx2(j)
    wk1_ad(i,j) = wk1_ad(i,j)-uc_ad(i,j)*dtdx2(j)
  end do
  fy_ad(1,j) = fy_ad(1,j)+uc_ad(1,j)*dycp(j)
  wk1_ad(im,j) = wk1_ad(im,j)+uc_ad(1,j)*dtdx2(j)
  wk1_ad(1,j) = wk1_ad(1,j)-uc_ad(1,j)*dtdx2(j)
end do
call tpcc_ad( tm2,tm2_ad,ymass,ymass_ad,v2(1,jfirst-ng_d),v2_ad(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),crx_ad(1:im,jfirst-1:&
&jlast+2),cry(1:im,jfirst:jlast),cry_ad(1:im,jfirst:jlast),im,jm,ng_d,iord,jord,fx,fx_ad,fy_ad(1:im,jfirst:jlast),ffsl,cose,jfirst,&
&jlast,slope,qtmp,al,ar,a6,a6_ad )
do j = js2gc1, jn1gc
  do i = 2, im
    u2_ad(i,j-1) = u2_ad(i,j-1)+v2_ad(i,j)*cye(j)
    u2_ad(i,j) = u2_ad(i,j)-v2_ad(i,j)*cye(j)
    vc_ad(i-1,j) = vc_ad(i-1,j)-v2_ad(i,j)*rdxe(j)
    vc_ad(i,j) = vc_ad(i,j)+v2_ad(i,j)*rdxe(j)
    v2_ad(i,j) = 0.d0
  end do
  u2_ad(1,j-1) = u2_ad(1,j-1)+v2_ad(1,j)*cye(j)
  u2_ad(1,j) = u2_ad(1,j)-v2_ad(1,j)*cye(j)
  vc_ad(im,j) = vc_ad(im,j)-v2_ad(1,j)*rdxe(j)
  vc_ad(1,j) = vc_ad(1,j)+v2_ad(1,j)*rdxe(j)
  v2_ad(1,j) = 0.d0
end do
if (jlast .eq. jm) then
  do i = 1, im
    u2_ad(i,jm) = 0.d0
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    uc_ad(i,j) = uc_ad(i,j)+u2_ad(i,j)*cosp(j)
    u2_ad(i,j) = 0.d0
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    u2_ad(i,1) = 0.d0
  end do
endif
do j = js2g0, jlast
  do i = 1, im
    cry_ad(i,j-1) = cry_ad(i,j-1)+0.5*tm2_ad(i,j)
    cry_ad(i,j) = cry_ad(i,j)+0.5*tm2_ad(i,j)
    tm2_ad(i,j) = 0.d0
  end do
end do
do j = jfirst, jlast
  do i = 1, im
    cry_ad(i,j) = cry_ad(i,j)+ymass_ad(i,j)*cosp(j)
    ymass_ad(i,j) = 0.d0
  end do
end do
do j = js1g1, jlast
  do i = 1, im
    v_ae(i,j) = v_ae(i,j)+cry_ad(i,j)*dtdy5
    cry_ad(i,j) = 0.d0
  end do
end do
do j = js2gc1, jn1gc
  do i = 2, im
    u_ae(i-1,j) = u_ae(i-1,j)+crx_ad(i,j)*dtxe5(j)
    crx_ad(i,j) = 0.d0
  end do
  u_ae(im,j) = u_ae(im,j)+crx_ad(1,j)*dtxe5(j)
  crx_ad(1,j) = 0.d0
end do
if (jlast .eq. jm) then
  do i = 1, im
    p2ke_ad = p2ke_ad+wk1_ad(i,jm)
    wk1_ad(i,jm) = 0.d0
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, im
    p1ke_ad = p1ke_ad+wk1_ad(i,1)
    wk1_ad(i,1) = 0.d0
  end do
endif
do j = jn2g0, js2g1, -1
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  a6 = c_sw_tape2_a6_1h(:,irec)
  slope = c_sw_tape2_slope_2h(:,irec)
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  do i = 1, im
    fxj_ad(i) = fxj_ad(i)+wk1_ad(i,j)*dxdt(j)
    fy_ad(i,j) = fy_ad(i,j)+wk1_ad(i,j)*dydt
    wk1_ad(i,j) = 0.d0
  end do
  call xtp_ad( im,sld,fxj,fxj_ad,p1d,p1d_ad,cx1,cx1_ad,iord,cx1,cx1_ad,cosp(j),0,slope,slopeh_ad,qtmp,qtmph_ad,al,ar,a6,a6_ad )
  do i = 1, im-1
    uc_ad(i+1,j) = uc_ad(i+1,j)+p1d_ad(i)
    p1d_ad(i) = 0.d0
  end do
  uc_ad(1,j) = uc_ad(1,j)+p1d_ad(im)
  p1d_ad(im) = 0.d0
  do i = 1, im
    u2_ad(i,j) = u2_ad(i,j)+cx1_ad(i)*dtdx4(j)
    cx1_ad(i) = 0.d0
  end do
end do
call ycc_ad( im,jm,fy_ad,vc(1,jfirst-2),vc_ad(1,jfirst-2),va(1,jfirst-1),va_ad(1,jfirst-1),va(1,jfirst-1),va_ad(1,jfirst-1),jord,1,&
&jfirst,jlast )
tm2(:,:) = c_sw_tape1_tm2_3h(:,:,c_sw_tape_rec+1)
do j = jfirst, jlast
  do i = 1, im
    ptk(i,j) = delp(i,j)+ptk(i,j)
    delp_ae(i,j) = delp_ae(i,j)+ptc_ad(i,j)*(pt(i,j)/ptk(i,j))
    pt_ae(i,j) = pt_ae(i,j)+ptc_ad(i,j)*(delp(i,j)/ptk(i,j))
    ptk_ad(i,j) = ptk_ad(i,j)-ptc_ad(i,j)*((pt(i,j)*delp(i,j)+tm2(i,j))/(ptk(i,j)*ptk(i,j)))
    tm2_ad(i,j) = tm2_ad(i,j)+ptc_ad(i,j)/ptk(i,j)
    ptc_ad(i,j) = 0.
    delp_ae(i,j) = delp_ae(i,j)+ptk_ad(i,j)
  end do
end do
call pft2d_ad( tm2_ad(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,v2_ad,crx )
call pft2d_ad( ptk_ad(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,v2_ad,crx )
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_ad( tm2_ad,va(1,jfirst),va_ad(1,jfirst),pt(1,jfirst-ng_c),pt_ae(1,jfirst-ng_c),crx(1,jfirst-ng_c),crx_ad(1,jfirst-ng_c),&
&cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_c,fx,fx_ad,fy(1,jfirst),fy_ad(1,jfirst),ffsl,rcap,acosp,xfx,xfx_ad,yfx,yfx_ad,&
&cosp,1,jfirst,jlast )
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
xfx = c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      crx_ad(i,j) = crx_ad(i,j)-xfx_ad(i,j)*(xfx(i,j)*(0.5+sign(0.5d0,abs(crx(i,j))-tiny))*sign(1.d0,crx(i,j))*sign(1.d0,crx(i,j))*&
&sign(1.d0,max(abs(crx(i,j)),tiny))/(sign(max(abs(crx(i,j)),tiny),crx(i,j))*sign(max(abs(crx(i,j)),tiny),crx(i,j))))
      xfx_ad(i,j) = xfx_ad(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_ad( ptk_ad,va(1,jfirst),va_ad(1,jfirst),delpf(1,jfirst-ng_c),delpf_ad(1,jfirst-ng_c),crx(1,jfirst-ng_c),crx_ad(1,jfirst-&
&ng_c),cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_c,xfx,xfx_ad,yfx,yfx_ad,ffsl,rcap,acosp,crx(1,jfirst),crx_ad(1,jfirst),&
&ymass,ymass_ad,cosp,0,jfirst,jlast )
do j = jn2gc, js2gc, -1
  do i = 1, im
    uc_ad(i,j) = uc_ad(i,j)+crx_ad(i,j)*dtdx2(j)
    crx_ad(i,j) = 0.d0
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    cry_ad(i,j+1) = cry_ad(i,j+1)+0.5*va_ad(i,j)
    cry_ad(i,j) = cry_ad(i,j)+0.5*va_ad(i,j)
    va_ad(i,j) = 0.d0
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry_ad(i,j) = cry_ad(i,j)+ymass_ad(i,j)*cose(j)
    ymass_ad(i,j) = 0.d0
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    vc_ad(i,j) = vc_ad(i,j)+cry_ad(i,j)*dtdy5
    cry_ad(i,j) = 0.d0
  end do
end do
do j = js2gc, jn1gc
  do i = 1, im
    v2_ad(i,j-1) = v2_ad(i,j-1)+0.25*vc_ad(i,j)
    v2_ad(i,j) = v2_ad(i,j)+0.25*vc_ad(i,j)
    vc_ad(i,j) = 0.
  end do
end do
do i = 1, im
  vc_ad(i,jlast+2) = 0.
  vc_ad(i,jlast+1) = 0.
  vc_ad(i,jfirst) = 0.
  vc_ad(i,jfirst-1) = 0.
  vc_ad(i,jfirst-2) = 0.
end do
do j = js2gc, jn2gc
  do i = 2, im
    u2_ad(i-1,j) = u2_ad(i-1,j)+0.25*uc_ad(i,j)
    u2_ad(i,j) = u2_ad(i,j)+0.25*uc_ad(i,j)
    uc_ad(i,j) = 0.
  end do
  u2_ad(im,j) = u2_ad(im,j)+0.25*uc_ad(1,j)
  u2_ad(1,j) = u2_ad(1,j)+0.25*uc_ad(1,j)
  uc_ad(1,j) = 0.
end do
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    v2(i+im2,1) = -v2(i,1)
  end do
endif
if (jlast .eq. jm) then
  j = jm-1
  do i = 1, im2
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    v2(i+im2,jm) = -v2(i,jm)
  end do
  u2_ad(1,jm) = u2_ad(1,jm)+0.25*p2ke_ad*u2(1,jm)
  v2_ad(1,jm) = v2_ad(1,jm)+0.25*p2ke_ad*v2(1,jm)
  p2ke_ad = 0.d0
  do i = 1, im2
    v2_ad(i,jm) = v2_ad(i,jm)-v2_ad(i+im2,jm)
    v2_ad(i+im2,jm) = 0.d0
    u2_ad(i,jm) = u2_ad(i,jm)-u2_ad(i+im2,jm)
    u2_ad(i+im2,jm) = 0.d0
    un_ad = un_ad-v2_ad(i,jm)*coslon(i)
    vn_ad = vn_ad-v2_ad(i,jm)*sinlon(i)
    v2_ad(i,jm) = 0.d0
    un_ad = un_ad-u2_ad(i,jm)*sinlon(i)
    vn_ad = vn_ad+u2_ad(i,jm)*coslon(i)
    u2_ad(i,jm) = 0.d0
  end do
  vn_ad = vn_ad/dble(im)
  un_ad = un_ad/dble(im)
  do i = 1, im2
    u2_ad(i+im2,j) = u2_ad(i+im2,j)-vn_ad*coslon(i)
    u2_ad(i,j) = u2_ad(i,j)+vn_ad*coslon(i)
    v2_ad(i+im2,j) = v2_ad(i+im2,j)+vn_ad*sinlon(i)
    v2_ad(i,j) = v2_ad(i,j)-vn_ad*sinlon(i)
    u2_ad(i+im2,j) = u2_ad(i+im2,j)+un_ad*sinlon(i)
    u2_ad(i,j) = u2_ad(i,j)-un_ad*sinlon(i)
    v2_ad(i+im2,j) = v2_ad(i+im2,j)+un_ad*coslon(i)
    v2_ad(i,j) = v2_ad(i,j)-un_ad*coslon(i)
  end do
endif
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
  u2_ad(1,1) = u2_ad(1,1)+0.25*p1ke_ad*u2(1,1)
  v2_ad(1,1) = v2_ad(1,1)+0.25*p1ke_ad*v2(1,1)
  p1ke_ad = 0.d0
  do i = 1, im2
    v2_ad(i,1) = v2_ad(i,1)-v2_ad(i+im2,1)
    v2_ad(i+im2,1) = 0.d0
    u2_ad(i,1) = u2_ad(i,1)-u2_ad(i+im2,1)
    u2_ad(i+im2,1) = 0.d0
    us_ad = us_ad+v2_ad(i,1)*coslon(i)
    vs_ad = vs_ad-v2_ad(i,1)*sinlon(i)
    v2_ad(i,1) = 0.d0
    us_ad = us_ad-u2_ad(i,1)*sinlon(i)
    vs_ad = vs_ad-u2_ad(i,1)*coslon(i)
    u2_ad(i,1) = 0.d0
  end do
  vs_ad = vs_ad/dble(im)
  us_ad = us_ad/dble(im)
  do i = 1, im2
    u2_ad(i+im2,2) = u2_ad(i+im2,2)+vs_ad*coslon(i)
    u2_ad(i,2) = u2_ad(i,2)-vs_ad*coslon(i)
    v2_ad(i+im2,2) = v2_ad(i+im2,2)+vs_ad*sinlon(i)
    v2_ad(i,2) = v2_ad(i,2)-vs_ad*sinlon(i)
    u2_ad(i+im2,2) = u2_ad(i+im2,2)+us_ad*sinlon(i)
    u2_ad(i,2) = u2_ad(i,2)-us_ad*sinlon(i)
    v2_ad(i+im2,2) = v2_ad(i+im2,2)-us_ad*coslon(i)
    v2_ad(i,2) = v2_ad(i,2)+us_ad*coslon(i)
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    u_ae(i,j+1) = u_ae(i,j+1)+u2_ad(i,j)
    u_ae(i,j) = u_ae(i,j)+u2_ad(i,j)
    u2_ad(i,j) = 0.d0
  end do
end do
do j = js2gcp1, jn2gc
  v_ae(im,j) = v_ae(im,j)+v2_ad(im,j)
  v_ae(1,j) = v_ae(1,j)+v2_ad(im,j)
  v2_ad(im,j) = 0.d0
  do i = 1, im-1
    v_ae(i+1,j) = v_ae(i+1,j)+v2_ad(i,j)
    v_ae(i,j) = v_ae(i,j)+v2_ad(i,j)
    v2_ad(i,j) = 0.d0
  end do
end do
call vpol5_ad( u_ae(1,jfirst),v_ae(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )

end subroutine c_sw_ad


subroutine c_swmd( u, v, pt, delp, uc, vc, ptc, delpf, ptk, cosp, acosp, cose, coslon, sinlon, dxdt, dxe, dtdx2, dtdx4, dtxe5, &
&rdxe, dycp, dydt, dtdy5, cye, fc, ifax, trigs, dc, sc, zt_c, tiny, rcap, im, jm, jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, &
&js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_ad, only : tpccmd
use c_sw_ad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_ptk_4h,c_sw_tape1_tm2_3h,c_sw_tape1_tm2_7h,&
&c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,c_sw_tape1_yfx_2h,c_sw_tape1_ymass_8h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
real(kind=r8), intent(in) :: cye(jm)
integer, intent(in) :: jn2g0
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: dc(im,js2g0:jn2g0)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real(kind=r8), intent(in) :: delp(im,jfirst:jlast)
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dxdt(jm)
real(kind=r8), intent(in) :: dxe(jm)
real(kind=r8), intent(in) :: dycp(jm)
real(kind=r8), intent(in) :: dydt
integer, intent(in) :: jn1gc
integer, intent(in) :: js2gc
real(kind=r8) :: fc(js2gc:jn1gc)
integer, intent(in) :: ifax(13)
integer, intent(in) :: iord
integer, intent(in) :: jord
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: ptc(im,jfirst:jlast)
real(kind=r8), intent(out) :: ptk(im,jfirst:jlast)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdxe(jm)
real(kind=r8), intent(in) :: sc(js2g0:jn2g0)
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: trigs(3*im/2+1)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: help_h
integer :: help_i
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js1g1
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1ke
real(kind=r8) :: p2ke
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: us
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vs
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
im2 = im/2
js1g1 = max(1,jfirst-1)
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
  p1ke = 0.125*(u2(1,1)**2+v2(1,1)**2)
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
  p2ke = 0.125*(u2(1,jm)**2+v2(1,jm)**2)
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c( ptk,va(1,jfirst),delpf(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,xfx,yfx,ffsl,rcap,acosp,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(c_sw_tape1_xfx_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_xfx_1h)) then
    allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1) = xfx
if ( .not. allocated(c_sw_tape1_yfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_yfx_2h)) then
    allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1) = yfx
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
call tp2c( tm2,va(1,jfirst),pt(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,fx,fy(1,jfirst),ffsl,rcap,&
&acosp,xfx,yfx,cosp,1,jfirst,jlast )
help_h = jn2g0-js2g0+1
call pft2d( ptk(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,v2,crx )
help_i = jn2g0-js2g0+1
call pft2d( tm2(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,v2,crx )
if ( .not. allocated(c_sw_tape1_tm2_3h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_tm2_3h)) then
    allocate( c_sw_tape1_tm2_3h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_tm2_3h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_tm2_3h(:,:,c_sw_tape_rec+1) = tm2(:,:)
if ( .not. allocated(c_sw_tape1_ptk_4h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_ptk_4h)) then
    allocate( c_sw_tape1_ptk_4h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_ptk_4h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_ptk_4h(:,:,c_sw_tape_rec+1) = ptk(:,:)
do j = jfirst, jlast
  do i = 1, im
    ptk(i,j) = delp(i,j)+ptk(i,j)
    ptc(i,j) = (pt(i,j)*delp(i,j)+tm2(i,j))/ptk(i,j)
  end do
end do
call ycc( im,jm,fy,vc(1,jfirst-2),va(1,jfirst-1),va(1,jfirst-1),jord,1,jfirst,jlast )
do j = js2g1, jn2g0
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  if ( .not. allocated(c_sw_tape2_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_a6_1h)) then
      allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_a6_1h(:,irec) = a6
  if ( .not. allocated(c_sw_tape2_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_slope_2h)) then
      allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_slope_2h(:,irec) = slope
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  call xtp( im,sld,fxj,p1d,cx1,iord,cx1,cosp(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = dxdt(j)*fxj(i)+dydt*fy(i,j)
  end do
end do
if ( .not. allocated(c_sw_tape1_a6_5h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_a6_5h)) then
    allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_a6_5h(:,c_sw_tape_rec+1) = a6
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,1) = p1ke
  end do
endif
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = p2ke
  end do
endif
do j = js2gc1, jn1gc
  crx(1,j) = dtxe5(j)*u(im,j)
  do i = 2, im
    crx(i,j) = dtxe5(j)*u(i-1,j)
  end do
end do
do j = js1g1, jlast
  do i = 1, im
    cry(i,j) = dtdy5*v(i,j)
  end do
end do
do j = jfirst, jlast
  do i = 1, im
    ymass(i,j) = cry(i,j)*cosp(j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im
    tm2(i,j) = 0.5*(cry(i,j)+cry(i,j-1))
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    u2(i,1) = 0.
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = uc(i,j)*cosp(j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    u2(i,jm) = 0.
  end do
endif
do j = js2gc1, jn1gc
  v2(1,j) = fc(j)+(u2(1,j-1)-u2(1,j))*cye(j)+(vc(1,j)-vc(im,j))*rdxe(j)
  do i = 2, im
    v2(i,j) = fc(j)+(u2(i,j-1)-u2(i,j))*cye(j)+(vc(i,j)-vc(i-1,j))*rdxe(j)
  end do
end do
if ( .not. allocated(c_sw_tape1_v2_6h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_v2_6h)) then
    allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1) = v2
if ( .not. allocated(c_sw_tape1_tm2_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_tm2_7h)) then
    allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1) = tm2
if ( .not. allocated(c_sw_tape1_ymass_8h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_ymass_8h)) then
    allocate( c_sw_tape1_ymass_8h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_ymass_8h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_ymass_8h(:,:,c_sw_tape_rec+1) = ymass
if ( .not. allocated(c_sw_tape1_crx_9h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_crx_9h)) then
    allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1) = crx
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tpccmd( tm2,ymass,v2(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),cry(1:im,jfirst:jlast),im,jm,ng_d,iord,jord,fx,fy(1:im,jfirst:&
&jlast),ffsl,cose,jfirst,jlast,slope,qtmp,al,ar,a6 )
do j = js2g0, jn2g0
  uc(1,j) = uc(1,j)+dtdx2(j)*(wk1(im,j)-wk1(1,j))+dycp(j)*fy(1,j)
  do i = 2, im
    uc(i,j) = uc(i,j)+dtdx2(j)*(wk1(i-1,j)-wk1(i,j))+dycp(j)*fy(i,j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im-1
    vc(i,j) = vc(i,j)+dtdy5*(wk1(i,j-1)-wk1(i,j))-dxe(j)*fx(i+1,j)
  end do
  vc(im,j) = vc(im,j)+dtdy5*(wk1(im,j-1)-wk1(im,j))-dxe(j)*fx(1,j)
end do
end subroutine c_swmd


subroutine d_sw_ad( u, u_ae, v, v_ae, uc, uc_ad, vc, vc_ad, pt, pt_ae, delp, delp_ae, delpf, delpf_ad, cx3_ad, cy3_ad, mfx_ad, &
&mfy_ad, cdx, cdy, dtdx, dtdxe, dtxe5, txe5, dyce, rdx, cy, dx, js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, nq, iord, jord, &
&zt_d, rcap, tiny, dtdy, dtdy5, tdy5, rdy, cosp, acosp, cose, coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_ad
use d_sw_ad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delp_5h,d_sw_tape1_delpf_1h,d_sw_tape1_ub_6h,d_sw_tape1_uc_7h,&
&d_sw_tape1_wk1_4h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer, intent(in) :: jn1g1
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: cdx(js2g0:jn1g1)
real(kind=r8), intent(in) :: cdy(js2g0:jn1g1)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8), intent(inout) :: cx3_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: cy(jm)
real(kind=r8), intent(inout) :: cy3_ad(im,jfirst:jlast+1)
integer :: d_sw_tape_rec
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delp_ae(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: delpf_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8), intent(in) :: dtdxe(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dx(jm)
real(kind=r8), intent(in) :: dyce(jm)
integer, intent(in) :: iord
integer, intent(in) :: jord
real(kind=r8), intent(inout) :: mfx_ad(im,jfirst:jlast)
real(kind=r8), intent(inout) :: mfy_ad(im,jfirst:jlast+1)
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: pt_ae(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdx(jm)
real(kind=r8), intent(in) :: rdy
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tdy5
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: txe5(jm)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: u_ae(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: uc_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: v_ae(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(inout) :: vc_ad(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6_ad(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: c1_ad
real(kind=r8) :: c2_ad
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: crx_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cry_ad(im,jfirst-1:jlast+1)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fx_ad(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxj_ad(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
real(kind=r8) :: fy_ad(im,jfirst-1:jlast+1)
integer :: i
integer :: j
integer :: jn1gd
integer :: jn2g0
integer :: jn2g1
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_ad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_ad(1+im+2*(im/3))
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: ub_ad(im,jfirst:jlast+1)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: va_ad(im,jfirst-1:jlast)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: wk1_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfx_ad(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfx_ad(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)
real(kind=r8) :: ymass_ad(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6_ad(:) = 0.d0
c1_ad = 0.d0
c2_ad = 0.d0
crx_ad(:,:) = 0.d0
cry_ad(:,:) = 0.d0
fx_ad(:,:) = 0.d0
fxj_ad(:) = 0.d0
fy_ad(:,:) = 0.d0
qtmph_ad(:) = 0.d0
slopeh_ad(:) = 0.d0
ub_ad(:,:) = 0.d0
va_ad(:,:) = 0.d0
wk1_ad(:,:) = 0.d0
xfx_ad(:,:) = 0.d0
yfx_ad(:,:) = 0.d0
ymass_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
jn2g0 = min(jm-1,jlast)
jn2g1 = min(jm-1,jlast+1)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
jn1gd = min(jm,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
delpf = d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1)
xfx = d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1)
yfx = d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
wk1 = d_sw_tape1_wk1_4h(:,:,d_sw_tape_rec+1)
delp = d_sw_tape1_delp_5h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
uc = d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  do i = 1, im
    fx_ad(i,j) = fx_ad(i,j)-vc_ad(i,j)*dx(j)
    wk1_ad(i,j+1) = wk1_ad(i,j+1)-vc_ad(i,j)*dtdy
    wk1_ad(i,j) = wk1_ad(i,j)+vc_ad(i,j)*dtdy
    vc_ad(i,j) = 0.
  end do
end do
do j = js2g0, jlast
  fy_ad(im,j) = fy_ad(im,j)+uc_ad(im,j)*dyce(j)
  wk1_ad(im,j) = wk1_ad(im,j)+uc_ad(im,j)*dtdxe(j)
  wk1_ad(1,j) = wk1_ad(1,j)-uc_ad(im,j)*dtdxe(j)
  uc_ad(im,j) = 0.
  do i = 1, im-1
    fy_ad(i,j) = fy_ad(i,j)+uc_ad(i,j)*dyce(j)
    wk1_ad(i+1,j) = wk1_ad(i+1,j)-uc_ad(i,j)*dtdxe(j)
    wk1_ad(i,j) = wk1_ad(i,j)+uc_ad(i,j)*dtdxe(j)
    uc_ad(i,j) = 0.
  end do
end do
call tp2d_ad( va(1,jfirst),va_ad(1,jfirst),uc(1,jfirst-ng_d),uc_ad(1,jfirst-ng_d),crx(1,jfirst-ng_d),crx_ad(1,jfirst-ng_d),cry(1,&
&jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_d,fx,fx_ad,fy(1:im,jfirst:jlast+1),fy_ad(1:im,jfirst:jlast+1),ffsl,crx(1,jfirst),&
&crx_ad(1,jfirst),ymass,ymass_ad,cosp,0,jfirst,jlast )
do j = js2gd, min(jm-1,jlast+ng_d-1)
  delpf_ad(im,j+1) = delpf_ad(im,j+1)-uc_ad(im,j)*cy(j)
  delpf_ad(im,j) = delpf_ad(im,j)+uc_ad(im,j)*cy(j)
  v_ae(im,j) = v_ae(im,j)-uc_ad(im,j)*rdx(j)
  v_ae(1,j) = v_ae(1,j)+uc_ad(im,j)*rdx(j)
  uc_ad(im,j) = 0.
  do i = 1, im-1
    delpf_ad(i,j+1) = delpf_ad(i,j+1)-uc_ad(i,j)*cy(j)
    delpf_ad(i,j) = delpf_ad(i,j)+uc_ad(i,j)*cy(j)
    v_ae(i+1,j) = v_ae(i+1,j)+uc_ad(i,j)*rdx(j)
    v_ae(i,j) = v_ae(i,j)-uc_ad(i,j)*rdx(j)
    uc_ad(i,j) = 0.
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    c2_ad = c2_ad+uc_ad(i,jm)
    uc_ad(i,jm) = 0.
  end do
  c2_ad = c2_ad*rdy*rcap
  do i = 1, im
    delpf_ad(i,jm) = delpf_ad(i,jm)+c2_ad
  end do
else
  do i = 1, im
    uc_ad(i,jn2gd) = 0.
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, im
    c1_ad = c1_ad+uc_ad(i,1)
    uc_ad(i,1) = 0.
  end do
  c1_ad = -(c1_ad*rdy*rcap)
  do i = 1, im
    delpf_ad(i,2) = delpf_ad(i,2)+c1_ad
  end do
endif
do j = js2gd, jn1gd
  do i = 1, im
    u_ae(i,j) = u_ae(i,j)+delpf_ad(i,j)*cose(j)
    delpf_ad(i,j) = 0.
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    fy_ad(i,jm-1) = fy_ad(i,jm-1)+wk1_ad(i,jm)*cdy(jm)
    uc_ad(i,jm) = uc_ad(i,jm)+wk1_ad(i,jm)*cdx(jm)
  end do
endif
do j = max(3,jfirst), jn2g1
  do i = 1, im
    fy_ad(i,j-1) = fy_ad(i,j-1)+wk1_ad(i,j)*cdy(j)
    fy_ad(i,j) = fy_ad(i,j)-wk1_ad(i,j)*cdy(j)
    uc_ad(i,j) = uc_ad(i,j)+wk1_ad(i,j)*cdx(j)
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    fy_ad(i,2) = fy_ad(i,2)-wk1_ad(i,2)*cdy(2)
    uc_ad(i,2) = uc_ad(i,2)+wk1_ad(i,2)*cdx(2)
  end do
endif
do j = js2g0, jn1g1
  do i = 2, im
    u_ae(i-1,j) = u_ae(i-1,j)+uc_ad(i,j)
    u_ae(i,j) = u_ae(i,j)-uc_ad(i,j)
    uc_ad(i,j) = 0.
  end do
  u_ae(im,j) = u_ae(im,j)+uc_ad(1,j)
  u_ae(1,j) = u_ae(1,j)-uc_ad(1,j)
  uc_ad(1,j) = 0.
end do
do j = max(2,jfirst-1), jn2g1
  do i = 1, im
    v_ae(i,j) = v_ae(i,j)+fy_ad(i,j)*cosp(j)
    fy_ad(i,j) = 0.d0
  end do
end do
do j = jn1g1, js2g0, -1
  a6 = d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  slope = d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  do i = 1, im
    fxj_ad(i) = fxj_ad(i)+wk1_ad(i,j)*txe5(j)
    fy_ad(i,j) = fy_ad(i,j)+wk1_ad(i,j)*tdy5
    wk1_ad(i,j) = 0.d0
  end do
  call xtp_ad( im,sld,fxj,fxj_ad,u(1,j),u_ae(1,j),ub(1,j),ub_ad(1,j),iord,ub(1,j),ub_ad(1,j),cose(j),0,slope,slopeh_ad,qtmp,&
&qtmph_ad,al,ar,a6,a6_ad )
end do
do j = js2g0, jn1g1
  do i = 1, im
    uc_ad(i,j-1) = uc_ad(i,j-1)+ub_ad(i,j)*dtxe5(j)
    uc_ad(i,j) = uc_ad(i,j)+ub_ad(i,j)*dtxe5(j)
    ub_ad(i,j) = 0.d0
  end do
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp_ad( im,jm,fy(1:im,jfirst:jlast+1),fy_ad(1:im,jfirst:jlast+1),v(1,jfirst-ng_d),v_ae(1,jfirst-ng_d),ub(1,jfirst),ub_ad(1,&
&jfirst),ub(1,jfirst),ub_ad(1,jfirst),ng_d,jord,1,jfirst,jlast )
do j = js2g0, jn1g1
  do i = 2, im
    vc_ad(i-1,j) = vc_ad(i-1,j)+ub_ad(i,j)*dtdy5
    vc_ad(i,j) = vc_ad(i,j)+ub_ad(i,j)*dtdy5
    ub_ad(i,j) = 0.d0
  end do
  vc_ad(im,j) = vc_ad(im,j)+ub_ad(1,j)*dtdy5
  vc_ad(1,j) = vc_ad(1,j)+ub_ad(1,j)*dtdy5
  ub_ad(1,j) = 0.d0
end do
ub = d_sw_tape1_ub_6h(:,:,d_sw_tape_rec+1)
do j = jfirst, jlast
  do i = 1, im
    delp_ae(i,j) = delp_ae(i,j)-pt_ae(i,j)*((pt(i,j)*wk1(i,j)+ub(i,j))/(delp(i,j)*delp(i,j)))
    ub_ad(i,j) = ub_ad(i,j)+pt_ae(i,j)/delp(i,j)
    wk1_ad(i,j) = wk1_ad(i,j)+pt_ae(i,j)*(pt(i,j)/delp(i,j))
    pt_ae(i,j) = pt_ae(i,j)*(wk1(i,j)/delp(i,j))
  end do
end do
call tp2c_ad( ub_ad(1,jfirst),va(1,jfirst),va_ad(1,jfirst),pt(1,jfirst-ng_d),pt_ae(1,jfirst-ng_d),crx(1,jfirst-ng_d),crx_ad(1,&
&jfirst-ng_d),cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_d,fx,fx_ad,fy(1:im,jfirst:jlast+1),fy_ad(1:im,jfirst:jlast+1),ffsl,&
&rcap,acosp,xfx,xfx_ad,yfx(1,jfirst),yfx_ad(1,jfirst),cosp,1,jfirst,jlast )
do j = jfirst, jlast
  do i = 1, im
    ub_ad(i,j) = ub_ad(i,j)+delp_ae(i,j)
    wk1_ad(i,j) = wk1_ad(i,j)+delp_ae(i,j)
    delp_ae(i,j) = 0.
    delp_ae(i,j) = delp_ae(i,j)+wk1_ad(i,j)
    wk1_ad(i,j) = 0.d0
  end do
end do
xfx = d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      crx_ad(i,j) = crx_ad(i,j)-xfx_ad(i,j)*(xfx(i,j)*(0.5+sign(0.5d0,abs(crx(i,j))-tiny))*sign(1.d0,crx(i,j))*sign(1.d0,crx(i,j))*&
&sign(1.d0,max(abs(crx(i,j)),tiny))/(sign(max(abs(crx(i,j)),tiny),crx(i,j))*sign(max(abs(crx(i,j)),tiny),crx(i,j))))
      xfx_ad(i,j) = xfx_ad(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
if (nq .gt. 0) then
  do j = js2g0, jlast
    do i = 1, im
      yfx_ad(i,j) = yfx_ad(i,j)+mfy_ad(i,j)
      cry_ad(i,j) = cry_ad(i,j)+cy3_ad(i,j)
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      xfx_ad(i,j) = xfx_ad(i,j)+mfx_ad(i,j)
      crx_ad(i,j) = crx_ad(i,j)+cx3_ad(i,j)
    end do
  end do
endif
call tp2c_ad( ub_ad(1,jfirst),va(1,jfirst),va_ad(1,jfirst),delpf(1,jfirst-ng_d),delpf_ad(1,jfirst-ng_d),crx(1,jfirst-ng_d),&
&crx_ad(1,jfirst-ng_d),cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_d,xfx,xfx_ad,yfx,yfx_ad,ffsl,rcap,acosp,crx(1,jfirst),&
&crx_ad(1,jfirst),ymass,ymass_ad,cosp,0,jfirst,jlast )
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        cry_ad(i,j) = cry_ad(i,j)+va_ad(i,j)
        va_ad(i,j) = 0.d0
      else
        cry_ad(i,j+1) = cry_ad(i,j+1)+va_ad(i,j)
        va_ad(i,j) = 0.d0
      endif
    else
      va_ad(i,j) = 0.d0
    endif
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry_ad(i,j) = cry_ad(i,j)+ymass_ad(i,j)*cose(j)
    ymass_ad(i,j) = 0.d0
    vc_ad(i,j) = vc_ad(i,j)+cry_ad(i,j)*dtdy
    cry_ad(i,j) = 0.d0
  end do
end do
do j = js2gd, jn2gd
  do i = 1, im
    uc_ad(i,j) = uc_ad(i,j)+crx_ad(i,j)*dtdx(j)
    crx_ad(i,j) = 0.d0
  end do
end do
call upol5_ad( uc_ad(1,jfirst),vc_ad(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )

end subroutine d_sw_ad


subroutine d_swmd( u, v, uc, vc, pt, delp, delpf, cx3, cy3, mfx, mfy, cdx, cdy, dtdx, dtdxe, dtxe5, txe5, dyce, rdx, cy, dx, f0, &
&js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, nq, iord, jord, zt_d, rcap, tiny, dtdy, dtdy5, tdy5, rdy, cosp, acosp, cose, &
&coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use d_sw_ad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delp_5h,d_sw_tape1_delpf_1h,d_sw_tape1_ub_6h,d_sw_tape1_uc_7h,&
&d_sw_tape1_wk1_4h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer, intent(in) :: jn1g1
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: cdx(js2g0:jn1g1)
real(kind=r8), intent(in) :: cdy(js2g0:jn1g1)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8) :: cx3(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: cy(jm)
real(kind=r8) :: cy3(im,jfirst:jlast+1)
integer :: d_sw_tape_rec
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8), intent(in) :: dtdxe(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dx(jm)
real(kind=r8), intent(in) :: dyce(jm)
real(kind=r8) :: f0(jfirst-ng_d:jlast+ng_d)
integer, intent(in) :: iord
integer, intent(in) :: jord
real(kind=r8) :: mfx(im,jfirst:jlast)
real(kind=r8) :: mfy(im,jfirst:jlast+1)
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdx(jm)
real(kind=r8), intent(in) :: rdy
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tdy5
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: txe5(jm)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: c1
real(kind=r8) :: c2
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: i
integer :: j
integer :: jn1gd
integer :: jn2g0
integer :: jn2g1
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
jn2g0 = min(jm-1,jlast)
jn2g1 = min(jm-1,jlast+1)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
jn1gd = min(jm,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
if ( .not. allocated(d_sw_tape1_delpf_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_delpf_1h)) then
    allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1) = delpf
call tp2c( ub(1,jfirst),va(1,jfirst),delpf(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,xfx,yfx,ffsl,rcap,&
&acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(d_sw_tape1_xfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_xfx_2h)) then
    allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1) = xfx
if ( .not. allocated(d_sw_tape1_yfx_3h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_yfx_3h)) then
    allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1) = yfx
if (nq .gt. 0) then
  do j = js2g0, jn2g0
    do i = 1, im
      cx3(i,j) = cx3(i,j)+crx(i,j)
      mfx(i,j) = mfx(i,j)+xfx(i,j)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      cy3(i,j) = cy3(i,j)+cry(i,j)
      mfy(i,j) = mfy(i,j)+yfx(i,j)
    end do
  end do
endif
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = jfirst, jlast
  do i = 1, im
    wk1(i,j) = delp(i,j)
    delp(i,j) = wk1(i,j)+ub(i,j)
  end do
end do
if ( .not. allocated(d_sw_tape1_wk1_4h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_wk1_4h)) then
    allocate( d_sw_tape1_wk1_4h(1:im,1:2+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_wk1_4h(1:im,1:2+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_wk1_4h(:,:,d_sw_tape_rec+1) = wk1
if ( .not. allocated(d_sw_tape1_delp_5h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_delp_5h)) then
    allocate( d_sw_tape1_delp_5h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_delp_5h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_delp_5h(:,:,d_sw_tape_rec+1) = delp
call tp2c( ub(1,jfirst),va(1,jfirst),pt(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:&
&jlast+1),ffsl,rcap,acosp,xfx,yfx(1,jfirst),cosp,1,jfirst,jlast )
if ( .not. allocated(d_sw_tape1_ub_6h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_ub_6h)) then
    allocate( d_sw_tape1_ub_6h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_ub_6h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_ub_6h(:,:,d_sw_tape_rec+1) = ub
do j = jfirst, jlast
  do i = 1, im
    pt(i,j) = (pt(i,j)*wk1(i,j)+ub(i,j))/delp(i,j)
  end do
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp( im,jm,fy(1:im,jfirst:jlast+1),v(1,jfirst-ng_d),ub(1,jfirst),ub(1,jfirst),ng_d,jord,1,jfirst,jlast )
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
do j = js2g0, jn1g1
  if ( .not. allocated(d_sw_tapej_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_a6_1h)) then
      allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = a6
  if ( .not. allocated(d_sw_tapej_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_slope_2h)) then
      allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = slope
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  call xtp( im,sld,fxj,u(1,j),ub(1,j),iord,ub(1,j),cose(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = txe5(j)*fxj(i)+tdy5*fy(i,j)
  end do
end do
do j = max(2,jfirst-1), jn2g1
  do i = 1, im
    fy(i,j) = v(i,j)*cosp(j)
  end do
end do
do j = js2g0, jn1g1
  uc(1,j) = u(im,j)-u(1,j)
  do i = 2, im
    uc(i,j) = u(i-1,j)-u(i,j)
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,2) = wk1(i,2)-cdy(2)*fy(i,2)+cdx(2)*uc(i,2)
  end do
endif
do j = max(3,jfirst), jn2g1
  do i = 1, im
    wk1(i,j) = wk1(i,j)+cdy(j)*(fy(i,j-1)-fy(i,j))+cdx(j)*uc(i,j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = wk1(i,jm)+cdy(jm)*fy(i,jm-1)+cdx(jm)*uc(i,jm)
  end do
endif
do j = js2gd, jn1gd
  do i = 1, im
    delpf(i,j) = u(i,j)*cose(j)
  end do
end do
if (jfirst .eq. 1) then
  c1 = 0.
  do i = 1, im
    c1 = c1+delpf(i,2)
  end do
  c1 = -(c1*rdy*rcap)
  do i = 1, im
    uc(i,1) = c1
  end do
endif
if (jlast .eq. jm) then
  c2 = 0.
  do i = 1, im
    c2 = c2+delpf(i,jm)
  end do
  c2 = c2*rdy*rcap
  do i = 1, im
    uc(i,jm) = c2
  end do
else
  do i = 1, im
    uc(i,jn2gd) = 1.e+30
  end do
endif
do j = js2gd, min(jm-1,jlast+ng_d-1)
  do i = 1, im-1
    uc(i,j) = (delpf(i,j)-delpf(i,j+1))*cy(j)+(v(i+1,j)-v(i,j))*rdx(j)
  end do
  uc(im,j) = (delpf(im,j)-delpf(im,j+1))*cy(j)+(v(1,j)-v(im,j))*rdx(j)
end do
do j = max(1,jfirst-ng_d), jn1gd
  do i = 1, im
    uc(i,j) = uc(i,j)+f0(j)
  end do
end do
if ( .not. allocated(d_sw_tape1_uc_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_uc_7h)) then
    allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1) = uc
call tp2d( va(1,jfirst),uc(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:jlast+1),ffsl,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
do j = js2g0, jlast
  do i = 1, im-1
    uc(i,j) = dtdxe(j)*(wk1(i,j)-wk1(i+1,j))+dyce(j)*fy(i,j)
  end do
  uc(im,j) = dtdxe(j)*(wk1(im,j)-wk1(1,j))+dyce(j)*fy(im,j)
end do
do j = js2g0, jn2g0
  do i = 1, im
    vc(i,j) = dtdy*(wk1(i,j)-wk1(i,j+1))-dx(j)*fx(i,j)
  end do
end do
end subroutine d_swmd


end module     sw_core_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     c_sw_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real(kind=8), allocatable :: c_sw_tape1_a6_5h(:,:)
integer :: c_sw_tape1_c_sw
real(kind=8), allocatable :: c_sw_tape1_crx_9h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_ptk_4h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_tm2_3h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_tm2_7h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_v2_6h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_xfx_1h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_yfx_2h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_ymass_8h(:,:,:)
real(kind=8), allocatable :: c_sw_tape2_a6_1h(:,:)
integer :: c_sw_tape2_c_sw
real(kind=8), allocatable :: c_sw_tape2_slope_2h(:,:)

end module     c_sw_ad_store


module     d_sw_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: d_sw_tape1_d_sw
real(kind=8), allocatable :: d_sw_tape1_delp_5h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_delpf_1h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_ub_6h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_uc_7h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_wk1_4h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_xfx_2h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_yfx_3h(:,:,:)
real(kind=8), allocatable :: d_sw_tapej_a6_1h(:,:)
integer :: d_sw_tapej_d_sw
real(kind=8), allocatable :: d_sw_tapej_slope_2h(:,:)

end module     d_sw_ad_store


module     sw_core_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sw_core

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine c_sw_ad( u, u_ae, v, v_ae, pt, pt_ae, delp, delp_ae, uc, uc_ad, vc, vc_ad, ptc_ad, delpf, delpf_ad, ptk, ptk_ad, cosp, &
&acosp, cose, coslon, sinlon, dxdt, dxe, dtdx2, dtdx4, dtxe5, rdxe, dycp, dydt, dtdy5, cye, ifax, trigs, dc, sc, zt_c, tiny, rcap, &
&im, jm, jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_ad
use c_sw_ad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_ptk_4h,c_sw_tape1_tm2_3h,c_sw_tape1_tm2_7h,&
&c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,c_sw_tape1_yfx_2h,c_sw_tape1_ymass_8h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
real(kind=r8), intent(in) :: cye(jm)
integer, intent(in) :: jn2g0
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: dc(im,js2g0:jn2g0)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real(kind=r8), intent(in) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delp_ae(im,jfirst:jlast)
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: delpf_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dxdt(jm)
real(kind=r8), intent(in) :: dxe(jm)
real(kind=r8), intent(in) :: dycp(jm)
real(kind=r8), intent(in) :: dydt
integer, intent(in) :: ifax(13)
integer, intent(in) :: iord
integer, intent(in) :: jn1gc
integer, intent(in) :: jord
integer, intent(in) :: js2gc
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: pt_ae(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: ptc_ad(im,jfirst:jlast)
real(kind=r8), intent(out) :: ptk(im,jfirst:jlast)
real(kind=r8), intent(inout) :: ptk_ad(im,jfirst:jlast)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdxe(jm)
real(kind=r8), intent(in) :: sc(js2g0:jn2g0)
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: trigs(3*im/2+1)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: u_ae(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: uc_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: v_ae(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(inout) :: vc_ad(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6_ad(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: crx_ad(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cry_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
real(kind=r8) :: cx1_ad(im)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fx_ad(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxj_ad(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
real(kind=r8) :: fy_ad(im,jfirst-1:jlast+1)
integer :: help_h
integer :: help_i
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js1g1
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1d_ad(im)
real(kind=r8) :: p1ke_ad
real(kind=r8) :: p2ke_ad
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_ad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_ad(1+im+2*(im/3))
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: tm2_ad(im,jfirst:jlast)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: u2_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: un_ad
real(kind=r8) :: us
real(kind=r8) :: us_ad
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: v2_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: va_ad(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vn_ad
real(kind=r8) :: vs
real(kind=r8) :: vs_ad
real(kind=r8) :: wk1_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfx_ad(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfx_ad(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)
real(kind=r8) :: ymass_ad(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6_ad(:) = 0.d0
crx_ad(:,:) = 0.d0
cry_ad(:,:) = 0.d0
cx1_ad(:) = 0.d0
fx_ad(:,:) = 0.d0
fxj_ad(:) = 0.d0
fy_ad(:,:) = 0.d0
p1d_ad(:) = 0.d0
p1ke_ad = 0.d0
p2ke_ad = 0.d0
qtmph_ad(:) = 0.d0
slopeh_ad(:) = 0.d0
tm2_ad(:,:) = 0.d0
u2_ad(:,:) = 0.d0
un_ad = 0.d0
us_ad = 0.d0
v2_ad(:,:) = 0.d0
va_ad(:,:) = 0.d0
vn_ad = 0.d0
vs_ad = 0.d0
wk1_ad(:,:) = 0.d0
xfx_ad(:,:) = 0.d0
yfx_ad(:,:) = 0.d0
ymass_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
im2 = im/2
js1g1 = max(1,jfirst-1)
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
xfx = c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1)
yfx = c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
help_h = jn2g0-js2g0+1
help_i = jn2g0-js2g0+1
ptk(:,:) = c_sw_tape1_ptk_4h(:,:,c_sw_tape_rec+1)
a6 = c_sw_tape1_a6_5h(:,c_sw_tape_rec+1)
do j = js1g1, jlast
  do i = 1, im
    cry(i,j) = dtdy5*v(i,j)
  end do
end do
v2 = c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1)
tm2 = c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1)
ymass = c_sw_tape1_ymass_8h(:,:,c_sw_tape_rec+1)
crx = c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1)
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jlast
  fx_ad(1,j) = fx_ad(1,j)-vc_ad(im,j)*dxe(j)
  wk1_ad(im,j-1) = wk1_ad(im,j-1)+vc_ad(im,j)*dtdy5
  wk1_ad(im,j) = wk1_ad(im,j)-vc_ad(im,j)*dtdy5
  do i = 1, im-1
    fx_ad(i+1,j) = fx_ad(i+1,j)-vc_ad(i,j)*dxe(j)
    wk1_ad(i,j-1) = wk1_ad(i,j-1)+vc_ad(i,j)*dtdy5
    wk1_ad(i,j) = wk1_ad(i,j)-vc_ad(i,j)*dtdy5
  end do
end do
do j = js2g0, jn2g0
  do i = 2, im
    fy_ad(i,j) = fy_ad(i,j)+uc_ad(i,j)*dycp(j)
    wk1_ad(i-1,j) = wk1_ad(i-1,j)+uc_ad(i,j)*dtdx2(j)
    wk1_ad(i,j) = wk1_ad(i,j)-uc_ad(i,j)*dtdx2(j)
  end do
  fy_ad(1,j) = fy_ad(1,j)+uc_ad(1,j)*dycp(j)
  wk1_ad(im,j) = wk1_ad(im,j)+uc_ad(1,j)*dtdx2(j)
  wk1_ad(1,j) = wk1_ad(1,j)-uc_ad(1,j)*dtdx2(j)
end do
call tpcc_ad( tm2,tm2_ad,ymass,ymass_ad,v2(1,jfirst-ng_d),v2_ad(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),crx_ad(1:im,jfirst-1:&
&jlast+2),cry(1:im,jfirst:jlast),cry_ad(1:im,jfirst:jlast),im,jm,ng_d,iord,jord,fx,fx_ad,fy_ad(1:im,jfirst:jlast),ffsl,cose,jfirst,&
&jlast,slope,qtmp,al,ar,a6,a6_ad )
do j = js2gc1, jn1gc
  do i = 2, im
    u2_ad(i,j-1) = u2_ad(i,j-1)+v2_ad(i,j)*cye(j)
    u2_ad(i,j) = u2_ad(i,j)-v2_ad(i,j)*cye(j)
    vc_ad(i-1,j) = vc_ad(i-1,j)-v2_ad(i,j)*rdxe(j)
    vc_ad(i,j) = vc_ad(i,j)+v2_ad(i,j)*rdxe(j)
    v2_ad(i,j) = 0.d0
  end do
  u2_ad(1,j-1) = u2_ad(1,j-1)+v2_ad(1,j)*cye(j)
  u2_ad(1,j) = u2_ad(1,j)-v2_ad(1,j)*cye(j)
  vc_ad(im,j) = vc_ad(im,j)-v2_ad(1,j)*rdxe(j)
  vc_ad(1,j) = vc_ad(1,j)+v2_ad(1,j)*rdxe(j)
  v2_ad(1,j) = 0.d0
end do
if (jlast .eq. jm) then
  do i = 1, im
    u2_ad(i,jm) = 0.d0
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    uc_ad(i,j) = uc_ad(i,j)+u2_ad(i,j)*cosp(j)
    u2_ad(i,j) = 0.d0
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    u2_ad(i,1) = 0.d0
  end do
endif
do j = js2g0, jlast
  do i = 1, im
    cry_ad(i,j-1) = cry_ad(i,j-1)+0.5*tm2_ad(i,j)
    cry_ad(i,j) = cry_ad(i,j)+0.5*tm2_ad(i,j)
    tm2_ad(i,j) = 0.d0
  end do
end do
do j = jfirst, jlast
  do i = 1, im
    cry_ad(i,j) = cry_ad(i,j)+ymass_ad(i,j)*cosp(j)
    ymass_ad(i,j) = 0.d0
  end do
end do
do j = js1g1, jlast
  do i = 1, im
    v_ae(i,j) = v_ae(i,j)+cry_ad(i,j)*dtdy5
    cry_ad(i,j) = 0.d0
  end do
end do
do j = js2gc1, jn1gc
  do i = 2, im
    u_ae(i-1,j) = u_ae(i-1,j)+crx_ad(i,j)*dtxe5(j)
    crx_ad(i,j) = 0.d0
  end do
  u_ae(im,j) = u_ae(im,j)+crx_ad(1,j)*dtxe5(j)
  crx_ad(1,j) = 0.d0
end do
if (jlast .eq. jm) then
  do i = 1, im
    p2ke_ad = p2ke_ad+wk1_ad(i,jm)
    wk1_ad(i,jm) = 0.d0
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, im
    p1ke_ad = p1ke_ad+wk1_ad(i,1)
    wk1_ad(i,1) = 0.d0
  end do
endif
do j = jn2g0, js2g1, -1
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  a6 = c_sw_tape2_a6_1h(:,irec)
  slope = c_sw_tape2_slope_2h(:,irec)
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  do i = 1, im
    fxj_ad(i) = fxj_ad(i)+wk1_ad(i,j)*dxdt(j)
    fy_ad(i,j) = fy_ad(i,j)+wk1_ad(i,j)*dydt
    wk1_ad(i,j) = 0.d0
  end do
  call xtp_ad( im,sld,fxj,fxj_ad,p1d,p1d_ad,cx1,cx1_ad,iord,cx1,cx1_ad,cosp(j),0,slope,slopeh_ad,qtmp,qtmph_ad,al,ar,a6,a6_ad )
  do i = 1, im-1
    uc_ad(i+1,j) = uc_ad(i+1,j)+p1d_ad(i)
    p1d_ad(i) = 0.d0
  end do
  uc_ad(1,j) = uc_ad(1,j)+p1d_ad(im)
  p1d_ad(im) = 0.d0
  do i = 1, im
    u2_ad(i,j) = u2_ad(i,j)+cx1_ad(i)*dtdx4(j)
    cx1_ad(i) = 0.d0
  end do
end do
call ycc_ad( im,jm,fy_ad,vc(1,jfirst-2),vc_ad(1,jfirst-2),va(1,jfirst-1),va_ad(1,jfirst-1),va(1,jfirst-1),va_ad(1,jfirst-1),jord,1,&
&jfirst,jlast )
tm2(:,:) = c_sw_tape1_tm2_3h(:,:,c_sw_tape_rec+1)
do j = jfirst, jlast
  do i = 1, im
    ptk(i,j) = delp(i,j)+ptk(i,j)
    delp_ae(i,j) = delp_ae(i,j)+ptc_ad(i,j)*(pt(i,j)/ptk(i,j))
    pt_ae(i,j) = pt_ae(i,j)+ptc_ad(i,j)*(delp(i,j)/ptk(i,j))
    ptk_ad(i,j) = ptk_ad(i,j)-ptc_ad(i,j)*((pt(i,j)*delp(i,j)+tm2(i,j))/(ptk(i,j)*ptk(i,j)))
    tm2_ad(i,j) = tm2_ad(i,j)+ptc_ad(i,j)/ptk(i,j)
    ptc_ad(i,j) = 0.
    delp_ae(i,j) = delp_ae(i,j)+ptk_ad(i,j)
  end do
end do
call pft2d_ad( tm2_ad(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,v2_ad,crx )
call pft2d_ad( ptk_ad(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,v2_ad,crx )
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_ad( tm2_ad,va(1,jfirst),va_ad(1,jfirst),pt(1,jfirst-ng_c),pt_ae(1,jfirst-ng_c),crx(1,jfirst-ng_c),crx_ad(1,jfirst-ng_c),&
&cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_c,fx,fx_ad,fy(1,jfirst),fy_ad(1,jfirst),ffsl,rcap,acosp,xfx,xfx_ad,yfx,yfx_ad,&
&cosp,1,jfirst,jlast )
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
xfx = c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      crx_ad(i,j) = crx_ad(i,j)-xfx_ad(i,j)*(xfx(i,j)*(0.5+sign(0.5d0,abs(crx(i,j))-tiny))*sign(1.d0,crx(i,j))*sign(1.d0,crx(i,j))*&
&sign(1.d0,max(abs(crx(i,j)),tiny))/(sign(max(abs(crx(i,j)),tiny),crx(i,j))*sign(max(abs(crx(i,j)),tiny),crx(i,j))))
      xfx_ad(i,j) = xfx_ad(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_ad( ptk_ad,va(1,jfirst),va_ad(1,jfirst),delpf(1,jfirst-ng_c),delpf_ad(1,jfirst-ng_c),crx(1,jfirst-ng_c),crx_ad(1,jfirst-&
&ng_c),cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_c,xfx,xfx_ad,yfx,yfx_ad,ffsl,rcap,acosp,crx(1,jfirst),crx_ad(1,jfirst),&
&ymass,ymass_ad,cosp,0,jfirst,jlast )
do j = jn2gc, js2gc, -1
  do i = 1, im
    uc_ad(i,j) = uc_ad(i,j)+crx_ad(i,j)*dtdx2(j)
    crx_ad(i,j) = 0.d0
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    cry_ad(i,j+1) = cry_ad(i,j+1)+0.5*va_ad(i,j)
    cry_ad(i,j) = cry_ad(i,j)+0.5*va_ad(i,j)
    va_ad(i,j) = 0.d0
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry_ad(i,j) = cry_ad(i,j)+ymass_ad(i,j)*cose(j)
    ymass_ad(i,j) = 0.d0
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    vc_ad(i,j) = vc_ad(i,j)+cry_ad(i,j)*dtdy5
    cry_ad(i,j) = 0.d0
  end do
end do
do j = js2gc, jn1gc
  do i = 1, im
    v2_ad(i,j-1) = v2_ad(i,j-1)+0.25*vc_ad(i,j)
    v2_ad(i,j) = v2_ad(i,j)+0.25*vc_ad(i,j)
    vc_ad(i,j) = 0.
  end do
end do
do i = 1, im
  vc_ad(i,jlast+2) = 0.
  vc_ad(i,jlast+1) = 0.
  vc_ad(i,jfirst) = 0.
  vc_ad(i,jfirst-1) = 0.
  vc_ad(i,jfirst-2) = 0.
end do
do j = js2gc, jn2gc
  do i = 2, im
    u2_ad(i-1,j) = u2_ad(i-1,j)+0.25*uc_ad(i,j)
    u2_ad(i,j) = u2_ad(i,j)+0.25*uc_ad(i,j)
    uc_ad(i,j) = 0.
  end do
  u2_ad(im,j) = u2_ad(im,j)+0.25*uc_ad(1,j)
  u2_ad(1,j) = u2_ad(1,j)+0.25*uc_ad(1,j)
  uc_ad(1,j) = 0.
end do
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    v2(i+im2,1) = -v2(i,1)
  end do
endif
if (jlast .eq. jm) then
  j = jm-1
  do i = 1, im2
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    v2(i+im2,jm) = -v2(i,jm)
  end do
  u2_ad(1,jm) = u2_ad(1,jm)+0.25*p2ke_ad*u2(1,jm)
  v2_ad(1,jm) = v2_ad(1,jm)+0.25*p2ke_ad*v2(1,jm)
  p2ke_ad = 0.d0
  do i = 1, im2
    v2_ad(i,jm) = v2_ad(i,jm)-v2_ad(i+im2,jm)
    v2_ad(i+im2,jm) = 0.d0
    u2_ad(i,jm) = u2_ad(i,jm)-u2_ad(i+im2,jm)
    u2_ad(i+im2,jm) = 0.d0
    un_ad = un_ad-v2_ad(i,jm)*coslon(i)
    vn_ad = vn_ad-v2_ad(i,jm)*sinlon(i)
    v2_ad(i,jm) = 0.d0
    un_ad = un_ad-u2_ad(i,jm)*sinlon(i)
    vn_ad = vn_ad+u2_ad(i,jm)*coslon(i)
    u2_ad(i,jm) = 0.d0
  end do
  vn_ad = vn_ad/dble(im)
  un_ad = un_ad/dble(im)
  do i = 1, im2
    u2_ad(i+im2,j) = u2_ad(i+im2,j)-vn_ad*coslon(i)
    u2_ad(i,j) = u2_ad(i,j)+vn_ad*coslon(i)
    v2_ad(i+im2,j) = v2_ad(i+im2,j)+vn_ad*sinlon(i)
    v2_ad(i,j) = v2_ad(i,j)-vn_ad*sinlon(i)
    u2_ad(i+im2,j) = u2_ad(i+im2,j)+un_ad*sinlon(i)
    u2_ad(i,j) = u2_ad(i,j)-un_ad*sinlon(i)
    v2_ad(i+im2,j) = v2_ad(i+im2,j)+un_ad*coslon(i)
    v2_ad(i,j) = v2_ad(i,j)-un_ad*coslon(i)
  end do
endif
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
  u2_ad(1,1) = u2_ad(1,1)+0.25*p1ke_ad*u2(1,1)
  v2_ad(1,1) = v2_ad(1,1)+0.25*p1ke_ad*v2(1,1)
  p1ke_ad = 0.d0
  do i = 1, im2
    v2_ad(i,1) = v2_ad(i,1)-v2_ad(i+im2,1)
    v2_ad(i+im2,1) = 0.d0
    u2_ad(i,1) = u2_ad(i,1)-u2_ad(i+im2,1)
    u2_ad(i+im2,1) = 0.d0
    us_ad = us_ad+v2_ad(i,1)*coslon(i)
    vs_ad = vs_ad-v2_ad(i,1)*sinlon(i)
    v2_ad(i,1) = 0.d0
    us_ad = us_ad-u2_ad(i,1)*sinlon(i)
    vs_ad = vs_ad-u2_ad(i,1)*coslon(i)
    u2_ad(i,1) = 0.d0
  end do
  vs_ad = vs_ad/dble(im)
  us_ad = us_ad/dble(im)
  do i = 1, im2
    u2_ad(i+im2,2) = u2_ad(i+im2,2)+vs_ad*coslon(i)
    u2_ad(i,2) = u2_ad(i,2)-vs_ad*coslon(i)
    v2_ad(i+im2,2) = v2_ad(i+im2,2)+vs_ad*sinlon(i)
    v2_ad(i,2) = v2_ad(i,2)-vs_ad*sinlon(i)
    u2_ad(i+im2,2) = u2_ad(i+im2,2)+us_ad*sinlon(i)
    u2_ad(i,2) = u2_ad(i,2)-us_ad*sinlon(i)
    v2_ad(i+im2,2) = v2_ad(i+im2,2)-us_ad*coslon(i)
    v2_ad(i,2) = v2_ad(i,2)+us_ad*coslon(i)
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    u_ae(i,j+1) = u_ae(i,j+1)+u2_ad(i,j)
    u_ae(i,j) = u_ae(i,j)+u2_ad(i,j)
    u2_ad(i,j) = 0.d0
  end do
end do
do j = js2gcp1, jn2gc
  v_ae(im,j) = v_ae(im,j)+v2_ad(im,j)
  v_ae(1,j) = v_ae(1,j)+v2_ad(im,j)
  v2_ad(im,j) = 0.d0
  do i = 1, im-1
    v_ae(i+1,j) = v_ae(i+1,j)+v2_ad(i,j)
    v_ae(i,j) = v_ae(i,j)+v2_ad(i,j)
    v2_ad(i,j) = 0.d0
  end do
end do
call vpol5_ad( u_ae(1,jfirst),v_ae(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )

end subroutine c_sw_ad


subroutine c_swmd( u, v, pt, delp, uc, vc, ptc, delpf, ptk, cosp, acosp, cose, coslon, sinlon, dxdt, dxe, dtdx2, dtdx4, dtxe5, &
&rdxe, dycp, dydt, dtdy5, cye, fc, ifax, trigs, dc, sc, zt_c, tiny, rcap, im, jm, jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, &
&js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_ad, only : tpccmd
use c_sw_ad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_ptk_4h,c_sw_tape1_tm2_3h,c_sw_tape1_tm2_7h,&
&c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,c_sw_tape1_yfx_2h,c_sw_tape1_ymass_8h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
real(kind=r8), intent(in) :: cye(jm)
integer, intent(in) :: jn2g0
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: dc(im,js2g0:jn2g0)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real(kind=r8), intent(in) :: delp(im,jfirst:jlast)
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dxdt(jm)
real(kind=r8), intent(in) :: dxe(jm)
real(kind=r8), intent(in) :: dycp(jm)
real(kind=r8), intent(in) :: dydt
integer, intent(in) :: jn1gc
integer, intent(in) :: js2gc
real(kind=r8) :: fc(js2gc:jn1gc)
integer, intent(in) :: ifax(13)
integer, intent(in) :: iord
integer, intent(in) :: jord
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: ptc(im,jfirst:jlast)
real(kind=r8), intent(out) :: ptk(im,jfirst:jlast)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdxe(jm)
real(kind=r8), intent(in) :: sc(js2g0:jn2g0)
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: trigs(3*im/2+1)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: help_h
integer :: help_i
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js1g1
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1ke
real(kind=r8) :: p2ke
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: us
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vs
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
im2 = im/2
js1g1 = max(1,jfirst-1)
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
  p1ke = 0.125*(u2(1,1)**2+v2(1,1)**2)
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
  p2ke = 0.125*(u2(1,jm)**2+v2(1,jm)**2)
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c( ptk,va(1,jfirst),delpf(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,xfx,yfx,ffsl,rcap,acosp,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(c_sw_tape1_xfx_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_xfx_1h)) then
    allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1) = xfx
if ( .not. allocated(c_sw_tape1_yfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_yfx_2h)) then
    allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1) = yfx
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
call tp2c( tm2,va(1,jfirst),pt(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,fx,fy(1,jfirst),ffsl,rcap,&
&acosp,xfx,yfx,cosp,1,jfirst,jlast )
help_h = jn2g0-js2g0+1
call pft2d( ptk(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,v2,crx )
help_i = jn2g0-js2g0+1
call pft2d( tm2(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,v2,crx )
if ( .not. allocated(c_sw_tape1_tm2_3h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_tm2_3h)) then
    allocate( c_sw_tape1_tm2_3h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_tm2_3h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_tm2_3h(:,:,c_sw_tape_rec+1) = tm2(:,:)
if ( .not. allocated(c_sw_tape1_ptk_4h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_ptk_4h)) then
    allocate( c_sw_tape1_ptk_4h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_ptk_4h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_ptk_4h(:,:,c_sw_tape_rec+1) = ptk(:,:)
do j = jfirst, jlast
  do i = 1, im
    ptk(i,j) = delp(i,j)+ptk(i,j)
    ptc(i,j) = (pt(i,j)*delp(i,j)+tm2(i,j))/ptk(i,j)
  end do
end do
call ycc( im,jm,fy,vc(1,jfirst-2),va(1,jfirst-1),va(1,jfirst-1),jord,1,jfirst,jlast )
do j = js2g1, jn2g0
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  if ( .not. allocated(c_sw_tape2_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_a6_1h)) then
      allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_a6_1h(:,irec) = a6
  if ( .not. allocated(c_sw_tape2_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_slope_2h)) then
      allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_slope_2h(:,irec) = slope
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  call xtp( im,sld,fxj,p1d,cx1,iord,cx1,cosp(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = dxdt(j)*fxj(i)+dydt*fy(i,j)
  end do
end do
if ( .not. allocated(c_sw_tape1_a6_5h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_a6_5h)) then
    allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_a6_5h(:,c_sw_tape_rec+1) = a6
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,1) = p1ke
  end do
endif
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = p2ke
  end do
endif
do j = js2gc1, jn1gc
  crx(1,j) = dtxe5(j)*u(im,j)
  do i = 2, im
    crx(i,j) = dtxe5(j)*u(i-1,j)
  end do
end do
do j = js1g1, jlast
  do i = 1, im
    cry(i,j) = dtdy5*v(i,j)
  end do
end do
do j = jfirst, jlast
  do i = 1, im
    ymass(i,j) = cry(i,j)*cosp(j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im
    tm2(i,j) = 0.5*(cry(i,j)+cry(i,j-1))
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    u2(i,1) = 0.
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = uc(i,j)*cosp(j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    u2(i,jm) = 0.
  end do
endif
do j = js2gc1, jn1gc
  v2(1,j) = fc(j)+(u2(1,j-1)-u2(1,j))*cye(j)+(vc(1,j)-vc(im,j))*rdxe(j)
  do i = 2, im
    v2(i,j) = fc(j)+(u2(i,j-1)-u2(i,j))*cye(j)+(vc(i,j)-vc(i-1,j))*rdxe(j)
  end do
end do
if ( .not. allocated(c_sw_tape1_v2_6h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_v2_6h)) then
    allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1) = v2
if ( .not. allocated(c_sw_tape1_tm2_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_tm2_7h)) then
    allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1) = tm2
if ( .not. allocated(c_sw_tape1_ymass_8h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_ymass_8h)) then
    allocate( c_sw_tape1_ymass_8h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_ymass_8h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_ymass_8h(:,:,c_sw_tape_rec+1) = ymass
if ( .not. allocated(c_sw_tape1_crx_9h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_crx_9h)) then
    allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1) = crx
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tpccmd( tm2,ymass,v2(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),cry(1:im,jfirst:jlast),im,jm,ng_d,iord,jord,fx,fy(1:im,jfirst:&
&jlast),ffsl,cose,jfirst,jlast,slope,qtmp,al,ar,a6 )
do j = js2g0, jn2g0
  uc(1,j) = uc(1,j)+dtdx2(j)*(wk1(im,j)-wk1(1,j))+dycp(j)*fy(1,j)
  do i = 2, im
    uc(i,j) = uc(i,j)+dtdx2(j)*(wk1(i-1,j)-wk1(i,j))+dycp(j)*fy(i,j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im-1
    vc(i,j) = vc(i,j)+dtdy5*(wk1(i,j-1)-wk1(i,j))-dxe(j)*fx(i+1,j)
  end do
  vc(im,j) = vc(im,j)+dtdy5*(wk1(im,j-1)-wk1(im,j))-dxe(j)*fx(1,j)
end do
end subroutine c_swmd


subroutine d_sw_ad( u, u_ae, v, v_ae, uc, uc_ad, vc, vc_ad, pt, pt_ae, delp, delp_ae, delpf, delpf_ad, cx3_ad, cy3_ad, mfx_ad, &
&mfy_ad, cdx, cdy, dtdx, dtdxe, dtxe5, txe5, dyce, rdx, cy, dx, js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, nq, iord, jord, &
&zt_d, rcap, tiny, dtdy, dtdy5, tdy5, rdy, cosp, acosp, cose, coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_ad
use d_sw_ad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delp_5h,d_sw_tape1_delpf_1h,d_sw_tape1_ub_6h,d_sw_tape1_uc_7h,&
&d_sw_tape1_wk1_4h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer, intent(in) :: jn1g1
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: cdx(js2g0:jn1g1)
real(kind=r8), intent(in) :: cdy(js2g0:jn1g1)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8), intent(inout) :: cx3_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: cy(jm)
real(kind=r8), intent(inout) :: cy3_ad(im,jfirst:jlast+1)
integer :: d_sw_tape_rec
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delp_ae(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: delpf_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8), intent(in) :: dtdxe(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dx(jm)
real(kind=r8), intent(in) :: dyce(jm)
integer, intent(in) :: iord
integer, intent(in) :: jord
real(kind=r8), intent(inout) :: mfx_ad(im,jfirst:jlast)
real(kind=r8), intent(inout) :: mfy_ad(im,jfirst:jlast+1)
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: pt_ae(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdx(jm)
real(kind=r8), intent(in) :: rdy
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tdy5
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: txe5(jm)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: u_ae(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(inout) :: uc_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: v_ae(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(inout) :: vc_ad(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6_ad(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: c1_ad
real(kind=r8) :: c2_ad
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: crx_ad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cry_ad(im,jfirst-1:jlast+1)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fx_ad(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxj_ad(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
real(kind=r8) :: fy_ad(im,jfirst-1:jlast+1)
integer :: i
integer :: j
integer :: jn1gd
integer :: jn2g0
integer :: jn2g1
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_ad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_ad(1+im+2*(im/3))
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: ub_ad(im,jfirst:jlast+1)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: va_ad(im,jfirst-1:jlast)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: wk1_ad(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfx_ad(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfx_ad(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)
real(kind=r8) :: ymass_ad(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6_ad(:) = 0.d0
c1_ad = 0.d0
c2_ad = 0.d0
crx_ad(:,:) = 0.d0
cry_ad(:,:) = 0.d0
fx_ad(:,:) = 0.d0
fxj_ad(:) = 0.d0
fy_ad(:,:) = 0.d0
qtmph_ad(:) = 0.d0
slopeh_ad(:) = 0.d0
ub_ad(:,:) = 0.d0
va_ad(:,:) = 0.d0
wk1_ad(:,:) = 0.d0
xfx_ad(:,:) = 0.d0
yfx_ad(:,:) = 0.d0
ymass_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
jn2g0 = min(jm-1,jlast)
jn2g1 = min(jm-1,jlast+1)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
jn1gd = min(jm,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
delpf = d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1)
xfx = d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1)
yfx = d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
wk1 = d_sw_tape1_wk1_4h(:,:,d_sw_tape_rec+1)
delp = d_sw_tape1_delp_5h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
uc = d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  do i = 1, im
    fx_ad(i,j) = fx_ad(i,j)-vc_ad(i,j)*dx(j)
    wk1_ad(i,j+1) = wk1_ad(i,j+1)-vc_ad(i,j)*dtdy
    wk1_ad(i,j) = wk1_ad(i,j)+vc_ad(i,j)*dtdy
    vc_ad(i,j) = 0.
  end do
end do
do j = js2g0, jlast
  fy_ad(im,j) = fy_ad(im,j)+uc_ad(im,j)*dyce(j)
  wk1_ad(im,j) = wk1_ad(im,j)+uc_ad(im,j)*dtdxe(j)
  wk1_ad(1,j) = wk1_ad(1,j)-uc_ad(im,j)*dtdxe(j)
  uc_ad(im,j) = 0.
  do i = 1, im-1
    fy_ad(i,j) = fy_ad(i,j)+uc_ad(i,j)*dyce(j)
    wk1_ad(i+1,j) = wk1_ad(i+1,j)-uc_ad(i,j)*dtdxe(j)
    wk1_ad(i,j) = wk1_ad(i,j)+uc_ad(i,j)*dtdxe(j)
    uc_ad(i,j) = 0.
  end do
end do
call tp2d_ad( va(1,jfirst),va_ad(1,jfirst),uc(1,jfirst-ng_d),uc_ad(1,jfirst-ng_d),crx(1,jfirst-ng_d),crx_ad(1,jfirst-ng_d),cry(1,&
&jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_d,fx,fx_ad,fy(1:im,jfirst:jlast+1),fy_ad(1:im,jfirst:jlast+1),ffsl,crx(1,jfirst),&
&crx_ad(1,jfirst),ymass,ymass_ad,cosp,0,jfirst,jlast )
do j = js2gd, min(jm-1,jlast+ng_d-1)
  delpf_ad(im,j+1) = delpf_ad(im,j+1)-uc_ad(im,j)*cy(j)
  delpf_ad(im,j) = delpf_ad(im,j)+uc_ad(im,j)*cy(j)
  v_ae(im,j) = v_ae(im,j)-uc_ad(im,j)*rdx(j)
  v_ae(1,j) = v_ae(1,j)+uc_ad(im,j)*rdx(j)
  uc_ad(im,j) = 0.
  do i = 1, im-1
    delpf_ad(i,j+1) = delpf_ad(i,j+1)-uc_ad(i,j)*cy(j)
    delpf_ad(i,j) = delpf_ad(i,j)+uc_ad(i,j)*cy(j)
    v_ae(i+1,j) = v_ae(i+1,j)+uc_ad(i,j)*rdx(j)
    v_ae(i,j) = v_ae(i,j)-uc_ad(i,j)*rdx(j)
    uc_ad(i,j) = 0.
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    c2_ad = c2_ad+uc_ad(i,jm)
    uc_ad(i,jm) = 0.
  end do
  c2_ad = c2_ad*rdy*rcap
  do i = 1, im
    delpf_ad(i,jm) = delpf_ad(i,jm)+c2_ad
  end do
else
  do i = 1, im
    uc_ad(i,jn2gd) = 0.
  end do
endif
if (jfirst .eq. 1) then
  do i = 1, im
    c1_ad = c1_ad+uc_ad(i,1)
    uc_ad(i,1) = 0.
  end do
  c1_ad = -(c1_ad*rdy*rcap)
  do i = 1, im
    delpf_ad(i,2) = delpf_ad(i,2)+c1_ad
  end do
endif
do j = js2gd, jn1gd
  do i = 1, im
    u_ae(i,j) = u_ae(i,j)+delpf_ad(i,j)*cose(j)
    delpf_ad(i,j) = 0.
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    fy_ad(i,jm-1) = fy_ad(i,jm-1)+wk1_ad(i,jm)*cdy(jm)
    uc_ad(i,jm) = uc_ad(i,jm)+wk1_ad(i,jm)*cdx(jm)
  end do
endif
do j = max(3,jfirst), jn2g1
  do i = 1, im
    fy_ad(i,j-1) = fy_ad(i,j-1)+wk1_ad(i,j)*cdy(j)
    fy_ad(i,j) = fy_ad(i,j)-wk1_ad(i,j)*cdy(j)
    uc_ad(i,j) = uc_ad(i,j)+wk1_ad(i,j)*cdx(j)
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    fy_ad(i,2) = fy_ad(i,2)-wk1_ad(i,2)*cdy(2)
    uc_ad(i,2) = uc_ad(i,2)+wk1_ad(i,2)*cdx(2)
  end do
endif
do j = js2g0, jn1g1
  do i = 2, im
    u_ae(i-1,j) = u_ae(i-1,j)+uc_ad(i,j)
    u_ae(i,j) = u_ae(i,j)-uc_ad(i,j)
    uc_ad(i,j) = 0.
  end do
  u_ae(im,j) = u_ae(im,j)+uc_ad(1,j)
  u_ae(1,j) = u_ae(1,j)-uc_ad(1,j)
  uc_ad(1,j) = 0.
end do
do j = max(2,jfirst-1), jn2g1
  do i = 1, im
    v_ae(i,j) = v_ae(i,j)+fy_ad(i,j)*cosp(j)
    fy_ad(i,j) = 0.d0
  end do
end do
do j = jn1g1, js2g0, -1
  a6 = d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  slope = d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  do i = 1, im
    fxj_ad(i) = fxj_ad(i)+wk1_ad(i,j)*txe5(j)
    fy_ad(i,j) = fy_ad(i,j)+wk1_ad(i,j)*tdy5
    wk1_ad(i,j) = 0.d0
  end do
  call xtp_ad( im,sld,fxj,fxj_ad,u(1,j),u_ae(1,j),ub(1,j),ub_ad(1,j),iord,ub(1,j),ub_ad(1,j),cose(j),0,slope,slopeh_ad,qtmp,&
&qtmph_ad,al,ar,a6,a6_ad )
end do
do j = js2g0, jn1g1
  do i = 1, im
    uc_ad(i,j-1) = uc_ad(i,j-1)+ub_ad(i,j)*dtxe5(j)
    uc_ad(i,j) = uc_ad(i,j)+ub_ad(i,j)*dtxe5(j)
    ub_ad(i,j) = 0.d0
  end do
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp_ad( im,jm,fy(1:im,jfirst:jlast+1),fy_ad(1:im,jfirst:jlast+1),v(1,jfirst-ng_d),v_ae(1,jfirst-ng_d),ub(1,jfirst),ub_ad(1,&
&jfirst),ub(1,jfirst),ub_ad(1,jfirst),ng_d,jord,1,jfirst,jlast )
do j = js2g0, jn1g1
  do i = 2, im
    vc_ad(i-1,j) = vc_ad(i-1,j)+ub_ad(i,j)*dtdy5
    vc_ad(i,j) = vc_ad(i,j)+ub_ad(i,j)*dtdy5
    ub_ad(i,j) = 0.d0
  end do
  vc_ad(im,j) = vc_ad(im,j)+ub_ad(1,j)*dtdy5
  vc_ad(1,j) = vc_ad(1,j)+ub_ad(1,j)*dtdy5
  ub_ad(1,j) = 0.d0
end do
ub = d_sw_tape1_ub_6h(:,:,d_sw_tape_rec+1)
do j = jfirst, jlast
  do i = 1, im
    delp_ae(i,j) = delp_ae(i,j)-pt_ae(i,j)*((pt(i,j)*wk1(i,j)+ub(i,j))/(delp(i,j)*delp(i,j)))
    ub_ad(i,j) = ub_ad(i,j)+pt_ae(i,j)/delp(i,j)
    wk1_ad(i,j) = wk1_ad(i,j)+pt_ae(i,j)*(pt(i,j)/delp(i,j))
    pt_ae(i,j) = pt_ae(i,j)*(wk1(i,j)/delp(i,j))
  end do
end do
call tp2c_ad( ub_ad(1,jfirst),va(1,jfirst),va_ad(1,jfirst),pt(1,jfirst-ng_d),pt_ae(1,jfirst-ng_d),crx(1,jfirst-ng_d),crx_ad(1,&
&jfirst-ng_d),cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_d,fx,fx_ad,fy(1:im,jfirst:jlast+1),fy_ad(1:im,jfirst:jlast+1),ffsl,&
&rcap,acosp,xfx,xfx_ad,yfx(1,jfirst),yfx_ad(1,jfirst),cosp,1,jfirst,jlast )
do j = jfirst, jlast
  do i = 1, im
    ub_ad(i,j) = ub_ad(i,j)+delp_ae(i,j)
    wk1_ad(i,j) = wk1_ad(i,j)+delp_ae(i,j)
    delp_ae(i,j) = 0.
    delp_ae(i,j) = delp_ae(i,j)+wk1_ad(i,j)
    wk1_ad(i,j) = 0.d0
  end do
end do
xfx = d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      crx_ad(i,j) = crx_ad(i,j)-xfx_ad(i,j)*(xfx(i,j)*(0.5+sign(0.5d0,abs(crx(i,j))-tiny))*sign(1.d0,crx(i,j))*sign(1.d0,crx(i,j))*&
&sign(1.d0,max(abs(crx(i,j)),tiny))/(sign(max(abs(crx(i,j)),tiny),crx(i,j))*sign(max(abs(crx(i,j)),tiny),crx(i,j))))
      xfx_ad(i,j) = xfx_ad(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
if (nq .gt. 0) then
  do j = js2g0, jlast
    do i = 1, im
      yfx_ad(i,j) = yfx_ad(i,j)+mfy_ad(i,j)
      cry_ad(i,j) = cry_ad(i,j)+cy3_ad(i,j)
    end do
  end do
  do j = js2g0, jn2g0
    do i = 1, im
      xfx_ad(i,j) = xfx_ad(i,j)+mfx_ad(i,j)
      crx_ad(i,j) = crx_ad(i,j)+cx3_ad(i,j)
    end do
  end do
endif
call tp2c_ad( ub_ad(1,jfirst),va(1,jfirst),va_ad(1,jfirst),delpf(1,jfirst-ng_d),delpf_ad(1,jfirst-ng_d),crx(1,jfirst-ng_d),&
&crx_ad(1,jfirst-ng_d),cry(1,jfirst),cry_ad(1,jfirst),im,jm,iord,jord,ng_d,xfx,xfx_ad,yfx,yfx_ad,ffsl,rcap,acosp,crx(1,jfirst),&
&crx_ad(1,jfirst),ymass,ymass_ad,cosp,0,jfirst,jlast )
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        cry_ad(i,j) = cry_ad(i,j)+va_ad(i,j)
        va_ad(i,j) = 0.d0
      else
        cry_ad(i,j+1) = cry_ad(i,j+1)+va_ad(i,j)
        va_ad(i,j) = 0.d0
      endif
    else
      va_ad(i,j) = 0.d0
    endif
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry_ad(i,j) = cry_ad(i,j)+ymass_ad(i,j)*cose(j)
    ymass_ad(i,j) = 0.d0
    vc_ad(i,j) = vc_ad(i,j)+cry_ad(i,j)*dtdy
    cry_ad(i,j) = 0.d0
  end do
end do
do j = js2gd, jn2gd
  do i = 1, im
    uc_ad(i,j) = uc_ad(i,j)+crx_ad(i,j)*dtdx(j)
    crx_ad(i,j) = 0.d0
  end do
end do
call upol5_ad( uc_ad(1,jfirst),vc_ad(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )

end subroutine d_sw_ad


subroutine d_swmd( u, v, uc, vc, pt, delp, delpf, cx3, cy3, mfx, mfy, cdx, cdy, dtdx, dtdxe, dtxe5, txe5, dyce, rdx, cy, dx, f0, &
&js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, nq, iord, jord, zt_d, rcap, tiny, dtdy, dtdy5, tdy5, rdy, cosp, acosp, cose, &
&coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use d_sw_ad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delp_5h,d_sw_tape1_delpf_1h,d_sw_tape1_ub_6h,d_sw_tape1_uc_7h,&
&d_sw_tape1_wk1_4h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer, intent(in) :: jn1g1
integer, intent(in) :: js2g0
real(kind=r8), intent(in) :: cdx(js2g0:jn1g1)
real(kind=r8), intent(in) :: cdy(js2g0:jn1g1)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8) :: cx3(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: cy(jm)
real(kind=r8) :: cy3(im,jfirst:jlast+1)
integer :: d_sw_tape_rec
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8), intent(in) :: dtdxe(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8), intent(in) :: dx(jm)
real(kind=r8), intent(in) :: dyce(jm)
real(kind=r8) :: f0(jfirst-ng_d:jlast+ng_d)
integer, intent(in) :: iord
integer, intent(in) :: jord
real(kind=r8) :: mfx(im,jfirst:jlast)
real(kind=r8) :: mfy(im,jfirst:jlast+1)
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: rdx(jm)
real(kind=r8), intent(in) :: rdy
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tdy5
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: txe5(jm)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: c1
real(kind=r8) :: c2
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: i
integer :: j
integer :: jn1gd
integer :: jn2g0
integer :: jn2g1
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
jn2g0 = min(jm-1,jlast)
jn2g1 = min(jm-1,jlast+1)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
jn1gd = min(jm,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
if ( .not. allocated(d_sw_tape1_delpf_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_delpf_1h)) then
    allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1) = delpf
call tp2c( ub(1,jfirst),va(1,jfirst),delpf(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,xfx,yfx,ffsl,rcap,&
&acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(d_sw_tape1_xfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_xfx_2h)) then
    allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1) = xfx
if ( .not. allocated(d_sw_tape1_yfx_3h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_yfx_3h)) then
    allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1) = yfx
if (nq .gt. 0) then
  do j = js2g0, jn2g0
    do i = 1, im
      cx3(i,j) = cx3(i,j)+crx(i,j)
      mfx(i,j) = mfx(i,j)+xfx(i,j)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      cy3(i,j) = cy3(i,j)+cry(i,j)
      mfy(i,j) = mfy(i,j)+yfx(i,j)
    end do
  end do
endif
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = jfirst, jlast
  do i = 1, im
    wk1(i,j) = delp(i,j)
    delp(i,j) = wk1(i,j)+ub(i,j)
  end do
end do
if ( .not. allocated(d_sw_tape1_wk1_4h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_wk1_4h)) then
    allocate( d_sw_tape1_wk1_4h(1:im,1:2+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_wk1_4h(1:im,1:2+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_wk1_4h(:,:,d_sw_tape_rec+1) = wk1
if ( .not. allocated(d_sw_tape1_delp_5h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_delp_5h)) then
    allocate( d_sw_tape1_delp_5h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_delp_5h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_delp_5h(:,:,d_sw_tape_rec+1) = delp
call tp2c( ub(1,jfirst),va(1,jfirst),pt(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:&
&jlast+1),ffsl,rcap,acosp,xfx,yfx(1,jfirst),cosp,1,jfirst,jlast )
if ( .not. allocated(d_sw_tape1_ub_6h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_ub_6h)) then
    allocate( d_sw_tape1_ub_6h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_ub_6h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_ub_6h(:,:,d_sw_tape_rec+1) = ub
do j = jfirst, jlast
  do i = 1, im
    pt(i,j) = (pt(i,j)*wk1(i,j)+ub(i,j))/delp(i,j)
  end do
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp( im,jm,fy(1:im,jfirst:jlast+1),v(1,jfirst-ng_d),ub(1,jfirst),ub(1,jfirst),ng_d,jord,1,jfirst,jlast )
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
do j = js2g0, jn1g1
  if ( .not. allocated(d_sw_tapej_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_a6_1h)) then
      allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = a6
  if ( .not. allocated(d_sw_tapej_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_slope_2h)) then
      allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = slope
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  call xtp( im,sld,fxj,u(1,j),ub(1,j),iord,ub(1,j),cose(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = txe5(j)*fxj(i)+tdy5*fy(i,j)
  end do
end do
do j = max(2,jfirst-1), jn2g1
  do i = 1, im
    fy(i,j) = v(i,j)*cosp(j)
  end do
end do
do j = js2g0, jn1g1
  uc(1,j) = u(im,j)-u(1,j)
  do i = 2, im
    uc(i,j) = u(i-1,j)-u(i,j)
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,2) = wk1(i,2)-cdy(2)*fy(i,2)+cdx(2)*uc(i,2)
  end do
endif
do j = max(3,jfirst), jn2g1
  do i = 1, im
    wk1(i,j) = wk1(i,j)+cdy(j)*(fy(i,j-1)-fy(i,j))+cdx(j)*uc(i,j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = wk1(i,jm)+cdy(jm)*fy(i,jm-1)+cdx(jm)*uc(i,jm)
  end do
endif
do j = js2gd, jn1gd
  do i = 1, im
    delpf(i,j) = u(i,j)*cose(j)
  end do
end do
if (jfirst .eq. 1) then
  c1 = 0.
  do i = 1, im
    c1 = c1+delpf(i,2)
  end do
  c1 = -(c1*rdy*rcap)
  do i = 1, im
    uc(i,1) = c1
  end do
endif
if (jlast .eq. jm) then
  c2 = 0.
  do i = 1, im
    c2 = c2+delpf(i,jm)
  end do
  c2 = c2*rdy*rcap
  do i = 1, im
    uc(i,jm) = c2
  end do
else
  do i = 1, im
    uc(i,jn2gd) = 1.e+30
  end do
endif
do j = js2gd, min(jm-1,jlast+ng_d-1)
  do i = 1, im-1
    uc(i,j) = (delpf(i,j)-delpf(i,j+1))*cy(j)+(v(i+1,j)-v(i,j))*rdx(j)
  end do
  uc(im,j) = (delpf(im,j)-delpf(im,j+1))*cy(j)+(v(1,j)-v(im,j))*rdx(j)
end do
do j = max(1,jfirst-ng_d), jn1gd
  do i = 1, im
    uc(i,j) = uc(i,j)+f0(j)
  end do
end do
if ( .not. allocated(d_sw_tape1_uc_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_uc_7h)) then
    allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1) = uc
call tp2d( va(1,jfirst),uc(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:jlast+1),ffsl,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
do j = js2g0, jlast
  do i = 1, im-1
    uc(i,j) = dtdxe(j)*(wk1(i,j)-wk1(i+1,j))+dyce(j)*fy(i,j)
  end do
  uc(im,j) = dtdxe(j)*(wk1(im,j)-wk1(1,j))+dyce(j)*fy(im,j)
end do
do j = js2g0, jn2g0
  do i = 1, im
    vc(i,j) = dtdy*(wk1(i,j)-wk1(i,j+1))-dx(j)*fx(i,j)
  end do
end do
end subroutine d_swmd


end module     sw_core_ad


#endif /* SPMD */
