#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fvcore_do_tad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision, only : r8

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: dynpkg_1_fvcore_do
real(kind=r8), allocatable :: dynpkg_1_pe_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_ps_5h(:,:,:)
real(kind=r8), allocatable :: dynpkg_1_q_3h(:,:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_cx_3h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_cy_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_dp0_1h(:,:,:,:)
integer :: dynpkg_n2_fvcore_do
real(kind=r8), allocatable :: dynpkg_n2_mfx_5h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_mfy_6h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_q_2h(:,:,:,:,:)

end module     fvcore_do_tad_store


module     fvcore_tad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use fvcore

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine fvcore_do_tad( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, pe, u, v, pt, q, q_tae, pkz, phis, ptop, om, ae, iord,&
& jord, kord, umax, consv )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
use timingmodule
use mapz_module_tad, only : te_map_tad
use fvcore_do_tad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_ps_5h,dynpkg_1_q_3h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,&
&dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,dynpkg_n2_q_2h
use cd_core_tad, only : cd_core_do_tad

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
integer, intent(in) :: im
integer, intent(in) :: iord
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: km
integer, intent(in) :: kord
integer, intent(in) :: nc
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(in) :: om
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: q_tae(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
logical :: fill
integer :: icd
integer :: ipe
integer :: it
integer :: jcd
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
integer :: n
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)

!==============================================
! declare data
!==============================================
data fill/ .true. /

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
if (km .gt. 1) then
  q = dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1)
  pe = dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1)
  ps = dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1)
  te_map_tape_rec = fvcore_tape_rec
  call adtiming_off( 'TE_MAP' )
  call te_map_tad( ps,pe,im,jm,km,nx,jfirst,jlast,nq,u,v,q,q_tae,phis,kord,ng_d,ng_s,te_map_tape_rec )
  call adtiming_on( 'TE_MAP' )
endif
do n = n2, 1, -1
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  if (nq .ne. 0) then
    dp0 = dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1)
    q = dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1)
    cx = dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1)
    cy = dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1)
    mfx = dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1)
    mfy = dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1)
    call adtiming_off( 'TRAC2D' )
    call trac2d_tad( dp0,q,q_tae,nq,cx,cy,mfx,mfy,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,jm,km,jfirst,jlast,pkz,worka )
    call adtiming_on( 'TRAC2D' )
  endif
  do it = nsplit, 1, -1
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
    call adtiming_off( 'CD_CORE' )
    call cd_core_do_tad( im,jm,km,jfirst,jlast,u,v,pt,ns,rcap,icd,jcd,iord,jord,ng_c,ng_d,ng_s,ipe,cosp,cose,acosp,sinlon,coslon,&
&cosl5,sinl5,delpf,uc,vc )
    call adtiming_on( 'CD_CORE' )
  end do
end do
if (km .gt. 1) then
  if (consv) then
    call adtiming_off( 'BENERGY' )
    call adtiming_on( 'BENERGY' )
  endif
endif

!----------------------------------------------
! DEALLOCATE STATEMENTS
!----------------------------------------------
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
deallocate( uc )
deallocate( vc )
deallocate( worka )

end subroutine fvcore_do_tad


subroutine fvcore_domd( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, pe, delp, u, v, pt, q, pk, pkz, phis, ns0, ndt, ptop, &
&om, cp, rg, ae, iord, jord, kord, umax, omga, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
use timingmodule
use mapz_module_tad, only : te_mapmd
use fvcore_do_tad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_ps_5h,dynpkg_1_q_3h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,&
&dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,dynpkg_n2_q_2h
use cd_core_tad, only : cd_core_domd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical :: convt
real(kind=r8) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8) :: delp(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer :: ndt
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
integer :: ns0
real(kind=r8), intent(in) :: om
real(kind=r8) :: omga(im,km,jfirst:jlast)
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
logical :: fill
logical :: filter
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
integer :: n
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8) :: te0
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)

!==============================================
! declare data
!==============================================
data filter/ .true. /
data fill/ .true. /

!**********************************************
! executable statements of routine
!**********************************************
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
delpf = 0.
te0 = 0.
if (km .gt. 1) then
  if (consv) then
    call benergy_do( im,jm,km,u,v,pt,delp,pe,pk,pkz,phis,ng_d,ng_s,cp,te0,mfx,dp0,jfirst,jlast )
  endif
endif
do n = 1, n2
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          dp0(i,j,k) = delp(i,j,k)
          cx(i,j,k) = 0.
          cy(i,j,k) = 0.
          mfx(i,j,k) = 0.
          mfy(i,j,k) = 0.
        end do
      end do
    end do
  endif
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  do it = 1, nsplit
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
    call cd_core_domd( im,jm,km,nq,nx,jfirst,jlast,u,v,pt,delp,pe,pk,ns,dt,ptop,umax,fill,filter,acap,ae,rcap,cp,cappa,icd,jcd,&
&iord,jord,ng_c,ng_d,ng_s,ipe,om,phis,sinp,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx,cy,mfx,mfy,delpf,uc,vc,pkz,dpt,worka,&
&dwz,pkc,wz )
  end do
  if (nq .ne. 0) then
    if ( .not. allocated(dynpkg_n2_dp0_1h)) then
      allocate( dynpkg_n2_dp0_1h(1:size(dp0,1),1:size(dp0,2),1:size(dp0,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1) = dp0
    if ( .not. allocated(dynpkg_n2_q_2h)) then
      allocate( dynpkg_n2_q_2h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1) = q
    if ( .not. allocated(dynpkg_n2_cx_3h)) then
      allocate( dynpkg_n2_cx_3h(1:size(cx,1),1:size(cx,2),1:size(cx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1) = cx
    if ( .not. allocated(dynpkg_n2_cy_4h)) then
      allocate( dynpkg_n2_cy_4h(1:size(cy,1),1:size(cy,2),1:size(cy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1) = cy
    if ( .not. allocated(dynpkg_n2_mfx_5h)) then
      allocate( dynpkg_n2_mfx_5h(1:size(mfx,1),1:size(mfx,2),1:size(mfx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1) = mfx
    if ( .not. allocated(dynpkg_n2_mfy_6h)) then
      allocate( dynpkg_n2_mfy_6h(1:size(mfy,1),1:size(mfy,2),1:size(mfy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1) = mfy
    call trac2d( dp0,q,nq,cx,cy,mfx,mfy,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,jm,km,jfirst,jlast,pkz,worka,&
&cd_tape_rec_n )
  endif
end do
if (km .gt. 1) then
  if ( .not. allocated(dynpkg_1_q_3h)) then
    allocate( dynpkg_1_q_3h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1) = q
  if ( .not. allocated(dynpkg_1_pe_4h)) then
    allocate( dynpkg_1_pe_4h(1:im,1:1+km,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1) = pe
  if ( .not. allocated(dynpkg_1_ps_5h)) then
    allocate( dynpkg_1_ps_5h(1:im,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1) = ps
  te_map_tape_rec = fvcore_tape_rec
  call te_mapmd( consv,convt,ps,omga,pe,delp,pkz,pk,ndt,im,jm,km,nx,jfirst,jlast,nq,u,v,pt,q,phis,cp,cappa,kord,peln,te0,ng_d,ng_s,&
&te_map_tape_rec )
endif
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
end subroutine fvcore_domd


end module     fvcore_tad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fvcore_do_tad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision, only : r8

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: dynpkg_1_fvcore_do
real(kind=r8), allocatable :: dynpkg_1_pe_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_ps_5h(:,:,:)
real(kind=r8), allocatable :: dynpkg_1_q_3h(:,:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_cx_3h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_cy_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_dp0_1h(:,:,:,:)
integer :: dynpkg_n2_fvcore_do
real(kind=r8), allocatable :: dynpkg_n2_mfx_5h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_mfy_6h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_q_2h(:,:,:,:,:)

end module     fvcore_do_tad_store


module     fvcore_tad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use fvcore

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine fvcore_do_tad( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, pe, u, v, pt, q, q_tae, pkz, phis, ptop, om, ae, iord,&
& jord, kord, umax, consv )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
use timingmodule
use mapz_module_tad, only : te_map_tad
use fvcore_do_tad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_ps_5h,dynpkg_1_q_3h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,&
&dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,dynpkg_n2_q_2h
use cd_core_tad, only : cd_core_do_tad

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
integer, intent(in) :: im
integer, intent(in) :: iord
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: km
integer, intent(in) :: kord
integer, intent(in) :: nc
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(in) :: om
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: q_tae(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
logical :: fill
integer :: icd
integer :: it
integer :: jcd
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
integer :: n
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)

!==============================================
! declare data
!==============================================
data fill/ .true. /

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
if (km .gt. 1) then
  q = dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1)
  pe = dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1)
  ps = dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1)
  te_map_tape_rec = fvcore_tape_rec
  call adtiming_off( 'TE_MAP' )
  call te_map_tad( ps,pe,im,jm,km,nx,jfirst,jlast,nq,u,v,q,q_tae,phis,kord,ng_d,ng_s,te_map_tape_rec )
  call adtiming_on( 'TE_MAP' )
endif
do n = n2, 1, -1
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  if (nq .ne. 0) then
    dp0 = dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1)
    q = dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1)
    cx = dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1)
    cy = dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1)
    mfx = dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1)
    mfy = dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1)
    call adtiming_off( 'TRAC2D' )
    call trac2d_tad( dp0,q,q_tae,nq,cx,cy,mfx,mfy,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,jm,km,jfirst,jlast,pkz,worka )
    call adtiming_on( 'TRAC2D' )
  endif
  do it = nsplit, 1, -1
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
    call adtiming_off( 'CD_CORE' )
    call cd_core_do_tad( im,jm,km,jfirst,jlast,u,v,pt,rcap,icd,jcd,iord,jord,ng_c,ng_d,ng_s,cosp,cose,acosp,sinlon,coslon,cosl5,&
&sinl5,delpf,uc,vc )
    call adtiming_on( 'CD_CORE' )
  end do
end do
if (km .gt. 1) then
  if (consv) then
    call adtiming_off( 'BENERGY' )
    call adtiming_on( 'BENERGY' )
  endif
endif

!----------------------------------------------
! DEALLOCATE STATEMENTS
!----------------------------------------------
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
deallocate( uc )
deallocate( vc )
deallocate( worka )

end subroutine fvcore_do_tad


subroutine fvcore_domd( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, pe, delp, u, v, pt, q, pk, pkz, phis, ns0, ndt, ptop, &
&om, cp, rg, ae, iord, jord, kord, umax, omga, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
use timingmodule
use mapz_module_tad, only : te_mapmd
use fvcore_do_tad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_ps_5h,dynpkg_1_q_3h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,&
&dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,dynpkg_n2_q_2h
use cd_core_tad, only : cd_core_domd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical :: convt
real(kind=r8) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8) :: delp(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer :: ndt
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
integer :: ns0
real(kind=r8), intent(in) :: om
real(kind=r8) :: omga(im,km,jfirst:jlast)
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
logical :: fill
logical :: filter
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
integer :: n
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8) :: te0
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)

!==============================================
! declare data
!==============================================
data filter/ .true. /
data fill/ .true. /

!**********************************************
! executable statements of routine
!**********************************************
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
delpf = 0.
te0 = 0.
if (km .gt. 1) then
  if (consv) then
    call benergy_do( im,jm,km,u,v,pt,delp,pe,pk,pkz,phis,ng_d,ng_s,cp,te0,mfx,dp0,jfirst,jlast )
  endif
endif
do n = 1, n2
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          dp0(i,j,k) = delp(i,j,k)
          cx(i,j,k) = 0.
          cy(i,j,k) = 0.
          mfx(i,j,k) = 0.
          mfy(i,j,k) = 0.
        end do
      end do
    end do
  endif
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  do it = 1, nsplit
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
    call cd_core_domd( im,jm,km,nq,nx,jfirst,jlast,u,v,pt,delp,pe,pk,ns,dt,ptop,umax,fill,filter,acap,ae,rcap,cp,cappa,icd,jcd,&
&iord,jord,ng_c,ng_d,ng_s,ipe,om,phis,sinp,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx,cy,mfx,mfy,delpf,uc,vc,pkz,dpt,worka,&
&dwz,pkc,wz )
  end do
  if (nq .ne. 0) then
    if ( .not. allocated(dynpkg_n2_dp0_1h)) then
      allocate( dynpkg_n2_dp0_1h(1:size(dp0,1),1:size(dp0,2),1:size(dp0,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1) = dp0
    if ( .not. allocated(dynpkg_n2_q_2h)) then
      allocate( dynpkg_n2_q_2h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1) = q
    if ( .not. allocated(dynpkg_n2_cx_3h)) then
      allocate( dynpkg_n2_cx_3h(1:size(cx,1),1:size(cx,2),1:size(cx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1) = cx
    if ( .not. allocated(dynpkg_n2_cy_4h)) then
      allocate( dynpkg_n2_cy_4h(1:size(cy,1),1:size(cy,2),1:size(cy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1) = cy
    if ( .not. allocated(dynpkg_n2_mfx_5h)) then
      allocate( dynpkg_n2_mfx_5h(1:size(mfx,1),1:size(mfx,2),1:size(mfx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1) = mfx
    if ( .not. allocated(dynpkg_n2_mfy_6h)) then
      allocate( dynpkg_n2_mfy_6h(1:size(mfy,1),1:size(mfy,2),1:size(mfy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1) = mfy
    call trac2d( dp0,q,nq,cx,cy,mfx,mfy,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,jm,km,jfirst,jlast,pkz,worka,&
&cd_tape_rec_n )
  endif
end do
if (km .gt. 1) then
  if ( .not. allocated(dynpkg_1_q_3h)) then
    allocate( dynpkg_1_q_3h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1) = q
  if ( .not. allocated(dynpkg_1_pe_4h)) then
    allocate( dynpkg_1_pe_4h(1:im,1:1+km,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1) = pe
  if ( .not. allocated(dynpkg_1_ps_5h)) then
    allocate( dynpkg_1_ps_5h(1:im,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1) = ps
  te_map_tape_rec = fvcore_tape_rec
  call te_mapmd( consv,convt,ps,omga,pe,delp,pkz,pk,ndt,im,jm,km,nx,jfirst,jlast,nq,u,v,pt,q,phis,cp,cappa,kord,peln,te0,ng_d,ng_s,&
&te_map_tape_rec )
endif
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
end subroutine fvcore_domd


end module     fvcore_tad


#endif /* SPMD */
