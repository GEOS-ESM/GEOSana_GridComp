#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine pft2d_tl( p, p_tl, s, damp, im, jp, ifax, trigs, q1, q1_tl, q2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: jp
real(kind=r8) :: damp(im,jp)
integer :: ifax(13)
real(kind=r8) :: p(im,jp)
real(kind=r8) :: p_tl(im,jp)
real(kind=r8) :: q1(im+2,*)
real(kind=r8) :: q1_tl(im+2,*)
real(kind=r8) :: q2(*)
real(kind=r8) :: s(jp)
real(kind=r8) :: trigs(3*im/2+1)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: bt
integer :: help_h
integer :: help_i
integer :: help_j
integer :: i
integer :: j
integer :: jf(jp)
integer :: n
integer :: nj
real(kind=r8) :: ptmp(0:im+1)
real(kind=r8) :: ptmp_tl(0:im+1)
real(kind=r8) :: rsc

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
nj = 0
do j = 1, jp
  if (s(j) .gt. 1.01 .and. s(j) .le. 4.) then
    rsc = 1./s(j)
    bt = 0.5*(s(j)-1.)
    do i = 1, im
      ptmp_tl(i) = p_tl(i,j)
      ptmp(i) = p(i,j)
    end do
    ptmp_tl(im+1) = p_tl(1,j)
    ptmp(im+1) = p(1,j)
    ptmp_tl(0) = p_tl(im,j)
    ptmp(0) = p(im,j)
    do i = 1, im
      p_tl(i,j) = (ptmp_tl(i-1)+ptmp_tl(i+1))*rsc*bt+ptmp_tl(i)*rsc
      p(i,j) = rsc*(ptmp(i)+bt*(ptmp(i-1)+ptmp(i+1)))
    end do
  else if (s(j) .gt. 4.) then
    nj = nj+1
    jf(nj) = j
    do i = 1, im
      q1_tl(i,nj) = p_tl(i,j)
      q1(i,nj) = p(i,j)
    end do
    q1_tl(im+1,nj) = 0.d0
    q1(im+1,nj) = 0.
    q1_tl(im+2,nj) = 0.d0
    q1(im+2,nj) = 0.
  endif
end do
if (nj .ne. 0) then
  help_h = im+2
  help_i = -1
  call rfftmlt( q1_tl,q2,trigs,ifax,1,help_h,im,nj,help_i )
  call rfftmlt( q1,q2,trigs,ifax,1,help_h,im,nj,help_i )
  do n = 1, nj
    do i = 5, im+2
      q1_tl(i,n) = q1_tl(i,n)*damp(i-2,jf(n))
      q1(i,n) = q1(i,n)*damp(i-2,jf(n))
    end do
  end do
  help_j = im+2
  call rfftmlt( q1_tl,q2,trigs,ifax,1,help_j,im,nj,1 )
  call rfftmlt( q1,q2,trigs,ifax,1,help_j,im,nj,1 )
  do n = 1, nj
    do i = 1, im
      p_tl(i,jf(n)) = q1_tl(i,n)
      p(i,jf(n)) = q1(i,n)
    end do
  end do
endif

end subroutine pft2d_tl


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine pft2d_tl( p, p_tl, s, damp, im, jp, ifax, trigs, q1, q1_tl, q2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: jp
real(kind=r8) :: damp(im,jp)
integer :: ifax(13)
real(kind=r8) :: p(im,jp)
real(kind=r8) :: p_tl(im,jp)
real(kind=r8) :: q1(im+2,*)
real(kind=r8) :: q1_tl(im+2,*)
real(kind=r8) :: q2(*)
real(kind=r8) :: s(jp)
real(kind=r8) :: trigs(3*im/2+1)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: bt
integer :: help_h
integer :: help_i
integer :: help_j
integer :: i
integer :: j
integer :: jf(jp)
integer :: n
integer :: nj
real(kind=r8) :: ptmp(0:im+1)
real(kind=r8) :: ptmp_tl(0:im+1)
real(kind=r8) :: rsc

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
nj = 0
do j = 1, jp
  if (s(j) .gt. 1.01 .and. s(j) .le. 4.) then
    rsc = 1./s(j)
    bt = 0.5*(s(j)-1.)
    do i = 1, im
      ptmp_tl(i) = p_tl(i,j)
      ptmp(i) = p(i,j)
    end do
    ptmp_tl(im+1) = p_tl(1,j)
    ptmp(im+1) = p(1,j)
    ptmp_tl(0) = p_tl(im,j)
    ptmp(0) = p(im,j)
    do i = 1, im
      p_tl(i,j) = (ptmp_tl(i-1)+ptmp_tl(i+1))*rsc*bt+ptmp_tl(i)*rsc
      p(i,j) = rsc*(ptmp(i)+bt*(ptmp(i-1)+ptmp(i+1)))
    end do
  else if (s(j) .gt. 4.) then
    nj = nj+1
    jf(nj) = j
    do i = 1, im
      q1_tl(i,nj) = p_tl(i,j)
      q1(i,nj) = p(i,j)
    end do
    q1_tl(im+1,nj) = 0.d0
    q1(im+1,nj) = 0.
    q1_tl(im+2,nj) = 0.d0
    q1(im+2,nj) = 0.
  endif
end do
if (nj .ne. 0) then
  help_h = im+2
  help_i = -1
  call rfftmlt( q1_tl,q2,trigs,ifax,1,help_h,im,nj,help_i )
  call rfftmlt( q1,q2,trigs,ifax,1,help_h,im,nj,help_i )
  do n = 1, nj
    do i = 5, im+2
      q1_tl(i,n) = q1_tl(i,n)*damp(i-2,jf(n))
      q1(i,n) = q1(i,n)*damp(i-2,jf(n))
    end do
  end do
  help_j = im+2
  call rfftmlt( q1_tl,q2,trigs,ifax,1,help_j,im,nj,1 )
  call rfftmlt( q1,q2,trigs,ifax,1,help_j,im,nj,1 )
  do n = 1, nj
    do i = 1, im
      p_tl(i,jf(n)) = q1_tl(i,n)
      p(i,jf(n)) = q1(i,n)
    end do
  end do
endif

end subroutine pft2d_tl


#endif /* SPMD */
