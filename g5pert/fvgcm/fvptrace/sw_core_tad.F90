#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     c_sw_tad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real(kind=8), allocatable :: c_sw_tape1_a6_5h(:,:)
integer :: c_sw_tape1_c_sw
real(kind=8), allocatable :: c_sw_tape1_crx_9h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_tm2_7h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_v2_6h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_xfx_1h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_yfx_2h(:,:,:)
real(kind=8), allocatable :: c_sw_tape2_a6_1h(:,:)
integer :: c_sw_tape2_c_sw
real(kind=8), allocatable :: c_sw_tape2_slope_2h(:,:)

end module     c_sw_tad_store


module     d_sw_tad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: d_sw_tape1_d_sw
real(kind=8), allocatable :: d_sw_tape1_delpf_1h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_uc_7h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_xfx_2h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_yfx_3h(:,:,:)
real(kind=8), allocatable :: d_sw_tapej_a6_1h(:,:)
integer :: d_sw_tapej_d_sw
real(kind=8), allocatable :: d_sw_tapej_slope_2h(:,:)

end module     d_sw_tad_store


module     sw_core_tad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sw_core

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine c_sw_tad( u, v, pt, uc, vc, delpf, cosp, acosp, cose, coslon, sinlon, dtdx2, dtdx4, dtdy5, zt_c, tiny, rcap, im, jm, &
&jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_tad
use c_sw_tad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_tm2_7h,c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,&
&c_sw_tape1_yfx_2h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
integer, intent(in) :: iord
integer, intent(in) :: jn1gc
integer, intent(in) :: jn2g0
integer, intent(in) :: jord
integer, intent(in) :: js2g0
integer, intent(in) :: js2gc
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6h_tad(1+im+2*(im/3))
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
real(kind=r8) :: delpfh_tad(im,jfirst-ng_d:jlast+ng_d)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxjh_tad(im)
real(kind=r8) :: fyh_tad(im,jfirst-1:jlast+1)
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1dh_tad(im)
real(kind=r8) :: pth_tad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: ptkh_tad(im,1+jlast-jfirst)
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_tad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_tad(1+im+2*(im/3))
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: tm2h_tad(im,1+jlast-jfirst)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: us
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vs
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfxh_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6h_tad(:) = 0.d0
delpfh_tad(:,:) = 0.
fxh_tad(:,:) = 0.d0
fxjh_tad(:) = 0.d0
fyh_tad(:,:) = 0.d0
p1dh_tad(:) = 0.d0
pth_tad(:,:) = 0.
ptkh_tad(:,:) = 0.
qtmph_tad(:) = 0.d0
slopeh_tad(:) = 0.d0
tm2h_tad(:,:) = 0.d0
xfxh_tad(:,:) = 0.d0
yfxh_tad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
im2 = im/2
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
xfx = c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1)
yfx = c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
a6 = c_sw_tape1_a6_5h(:,c_sw_tape_rec+1)
v2 = c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1)
tm2 = c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1)
crx = c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1)
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tpcc_tad( tm2,v2(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),im,jm,ng_d,iord,jord,fx,ffsl,cose,jfirst,jlast,slope,qtmp,al,ar,a6 )
do j = jn2g0, js2g1, -1
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  a6 = c_sw_tape2_a6_1h(:,irec)
  slope = c_sw_tape2_slope_2h(:,irec)
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  call xtp_tad( im,sld,fxj,fxjh_tad,p1d,p1dh_tad,cx1,iord,cx1,cosp(j),0,slope,slopeh_tad,qtmp,qtmph_tad,al,ar,a6,a6h_tad )
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_tad( tm2h_tad,va(1,jfirst),pt(1,jfirst-ng_c),pth_tad,crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,fx,fxh_tad,&
&fyh_tad,ffsl,rcap,acosp,xfx,yfx,cosp,1,jfirst,jlast )
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_tad( ptkh_tad,va(1,jfirst),delpf(1,jfirst-ng_c),delpfh_tad,crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,xfx,&
&xfxh_tad,yfxh_tad,ffsl,rcap,acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )

end subroutine c_sw_tad


subroutine c_swmd( u, v, pt, delp, uc, vc, ptc, delpf, ptk, cosp, acosp, cose, coslon, sinlon, dxdt, dxe, dtdx2, dtdx4, dtxe5, &
&rdxe, dycp, dydt, dtdy5, cye, fc, ifax, trigs, dc, sc, zt_c, tiny, rcap, im, jm, jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, &
&js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_tad, only : tpccmd
use c_sw_tad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_tm2_7h,c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,&
&c_sw_tape1_yfx_2h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
real(kind=r8) :: cye(jm)
integer, intent(in) :: jn2g0
integer, intent(in) :: js2g0
real(kind=r8) :: dc(im,js2g0:jn2g0)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real(kind=r8) :: delp(im,jfirst:jlast)
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
real(kind=r8) :: dtxe5(jm)
real(kind=r8) :: dxdt(jm)
real(kind=r8) :: dxe(jm)
real(kind=r8) :: dycp(jm)
real(kind=r8) :: dydt
integer, intent(in) :: jn1gc
integer, intent(in) :: js2gc
real(kind=r8) :: fc(js2gc:jn1gc)
integer :: ifax(13)
integer, intent(in) :: iord
integer, intent(in) :: jord
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: ptc(im,jfirst:jlast)
real(kind=r8) :: ptk(im,jfirst:jlast)
real(kind=r8), intent(in) :: rcap
real(kind=r8) :: rdxe(jm)
real(kind=r8) :: sc(js2g0:jn2g0)
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8) :: trigs(3*im/2+1)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: help_h
integer :: help_i
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js1g1
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1ke
real(kind=r8) :: p2ke
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: us
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vs
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
im2 = im/2
js1g1 = max(1,jfirst-1)
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
  p1ke = 0.125*(u2(1,1)**2+v2(1,1)**2)
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
  p2ke = 0.125*(u2(1,jm)**2+v2(1,jm)**2)
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c( ptk,va(1,jfirst),delpf(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,xfx,yfx,ffsl,rcap,acosp,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(c_sw_tape1_xfx_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_xfx_1h)) then
    allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1) = xfx
if ( .not. allocated(c_sw_tape1_yfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_yfx_2h)) then
    allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1) = yfx
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
call tp2c( tm2,va(1,jfirst),pt(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,fx,fy(1,jfirst),ffsl,rcap,&
&acosp,xfx,yfx,cosp,1,jfirst,jlast )
help_h = jn2g0-js2g0+1
call pft2d( ptk(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,v2,crx )
help_i = jn2g0-js2g0+1
call pft2d( tm2(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,v2,crx )
do j = jfirst, jlast
  do i = 1, im
    ptk(i,j) = delp(i,j)+ptk(i,j)
    ptc(i,j) = (pt(i,j)*delp(i,j)+tm2(i,j))/ptk(i,j)
  end do
end do
call ycc( im,jm,fy,vc(1,jfirst-2),va(1,jfirst-1),va(1,jfirst-1),jord,1,jfirst,jlast )
do j = js2g1, jn2g0
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  if ( .not. allocated(c_sw_tape2_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_a6_1h)) then
      allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_a6_1h(:,irec) = a6
  if ( .not. allocated(c_sw_tape2_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_slope_2h)) then
      allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_slope_2h(:,irec) = slope
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  call xtp( im,sld,fxj,p1d,cx1,iord,cx1,cosp(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = dxdt(j)*fxj(i)+dydt*fy(i,j)
  end do
end do
if ( .not. allocated(c_sw_tape1_a6_5h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_a6_5h)) then
    allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_a6_5h(:,c_sw_tape_rec+1) = a6
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,1) = p1ke
  end do
endif
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = p2ke
  end do
endif
do j = js2gc1, jn1gc
  crx(1,j) = dtxe5(j)*u(im,j)
  do i = 2, im
    crx(i,j) = dtxe5(j)*u(i-1,j)
  end do
end do
do j = js1g1, jlast
  do i = 1, im
    cry(i,j) = dtdy5*v(i,j)
  end do
end do
do j = jfirst, jlast
  do i = 1, im
    ymass(i,j) = cry(i,j)*cosp(j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im
    tm2(i,j) = 0.5*(cry(i,j)+cry(i,j-1))
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    u2(i,1) = 0.
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = uc(i,j)*cosp(j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    u2(i,jm) = 0.
  end do
endif
do j = js2gc1, jn1gc
  v2(1,j) = fc(j)+(u2(1,j-1)-u2(1,j))*cye(j)+(vc(1,j)-vc(im,j))*rdxe(j)
  do i = 2, im
    v2(i,j) = fc(j)+(u2(i,j-1)-u2(i,j))*cye(j)+(vc(i,j)-vc(i-1,j))*rdxe(j)
  end do
end do
if ( .not. allocated(c_sw_tape1_v2_6h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_v2_6h)) then
    allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1) = v2
if ( .not. allocated(c_sw_tape1_tm2_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_tm2_7h)) then
    allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1) = tm2
if ( .not. allocated(c_sw_tape1_crx_9h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_crx_9h)) then
    allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1) = crx
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tpccmd( tm2,ymass,v2(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),cry(1:im,jfirst:jlast),im,jm,ng_d,iord,jord,fx,fy(1:im,jfirst:&
&jlast),ffsl,cose,jfirst,jlast,slope,qtmp,al,ar,a6 )
do j = js2g0, jn2g0
  uc(1,j) = uc(1,j)+dtdx2(j)*(wk1(im,j)-wk1(1,j))+dycp(j)*fy(1,j)
  do i = 2, im
    uc(i,j) = uc(i,j)+dtdx2(j)*(wk1(i-1,j)-wk1(i,j))+dycp(j)*fy(i,j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im-1
    vc(i,j) = vc(i,j)+dtdy5*(wk1(i,j-1)-wk1(i,j))-dxe(j)*fx(i+1,j)
  end do
  vc(im,j) = vc(im,j)+dtdy5*(wk1(im,j-1)-wk1(im,j))-dxe(j)*fx(1,j)
end do
end subroutine c_swmd


subroutine d_sw_tad( u, v, uc, vc, pt, delpf, dtdx, dtxe5, js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, iord, jord, zt_d, rcap,&
& tiny, dtdy, dtdy5, cosp, acosp, cose, coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_tad
use d_sw_tad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delpf_1h,d_sw_tape1_uc_7h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,&
&d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer :: d_sw_tape_rec
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
integer, intent(in) :: iord
integer, intent(in) :: jn1g1
integer, intent(in) :: jord
integer, intent(in) :: js2g0
integer, intent(in) :: ng_s
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6h_tad(1+im+2*(im/3))
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: delpfh_tad(im,jfirst-ng_d:jlast+ng_d)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: fxi_tad(im,1+jlast-jfirst)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxjh_tad(im)
real(kind=r8) :: fyh_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: fyi_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: fyj_tad(im,1+1+jlast-jfirst)
integer :: i
integer :: j
integer :: jn2g0
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: pth_tad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_tad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_tad(1+im+2*(im/3))
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: ubh_tad(im,jfirst:jlast+1)
real(kind=r8) :: ubi_tad(im,jfirst:jlast+1)
real(kind=r8) :: uch_tad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: uh_tad(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vh_tad(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfxh_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6h_tad(:) = 0.d0
delpfh_tad(:,:) = 0.
fxh_tad(:,:) = 0.d0
fxi_tad(:,:) = 0.d0
fxjh_tad(:) = 0.d0
fyh_tad(:,:) = 0.d0
fyi_tad(:,:) = 0.d0
fyj_tad(:,:) = 0.d0
pth_tad(:,:) = 0.
qtmph_tad(:) = 0.d0
slopeh_tad(:) = 0.d0
ubh_tad(:,:) = 0.d0
ubi_tad(:,:) = 0.d0
uch_tad(:,:) = 0.
uh_tad(:,:) = 0.
vh_tad(:,:) = 0.
xfxh_tad(:,:) = 0.d0
yfxh_tad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
jn2g0 = min(jm-1,jlast)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
delpf = d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1)
xfx = d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1)
yfx = d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
uc = d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1)
call tp2d_tad( va(1,jfirst),uc(1,jfirst-ng_d),uch_tad,crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fxh_tad,fyh_tad,&
&ffsl,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
do j = jn1g1, js2g0, -1
  a6 = d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  slope = d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  call xtp_tad( im,sld,fxj,fxjh_tad,u(1,j),uh_tad,ub(1,j),iord,ub(1,j),cose(j),0,slope,slopeh_tad,qtmp,qtmph_tad,al,ar,a6,a6h_tad )
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp_tad( im,jm,fyi_tad,v(1,jfirst-ng_d),vh_tad,ub(1,jfirst),ub(1,jfirst),ng_d,jord,1,jfirst,jlast )
call tp2c_tad( ubh_tad,va(1,jfirst),pt(1,jfirst-ng_d),pth_tad,crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fxi_tad,&
&fyj_tad,ffsl,rcap,acosp,xfx,yfx(1,jfirst),cosp,1,jfirst,jlast )
call tp2c_tad( ubi_tad,va(1,jfirst),delpf(1,jfirst-ng_d),delpfh_tad,crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,xfx,&
&xfxh_tad,yfxh_tad,ffsl,rcap,acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )

end subroutine d_sw_tad


subroutine d_swmd( u, v, uc, vc, pt, delp, delpf, cx3, cy3, mfx, mfy, cdx, cdy, dtdx, dtdxe, dtxe5, txe5, dyce, rdx, cy, dx, f0, &
&js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, nq, iord, jord, zt_d, rcap, tiny, dtdy, dtdy5, tdy5, rdy, cosp, acosp, cose, &
&coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use d_sw_tad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delpf_1h,d_sw_tape1_uc_7h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,&
&d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer, intent(in) :: jn1g1
integer, intent(in) :: js2g0
real(kind=r8) :: cdx(js2g0:jn1g1)
real(kind=r8) :: cdy(js2g0:jn1g1)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8) :: cx3(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cy(jm)
real(kind=r8) :: cy3(im,jfirst:jlast+1)
integer :: d_sw_tape_rec
real(kind=r8) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8) :: dtdxe(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8) :: dx(jm)
real(kind=r8) :: dyce(jm)
real(kind=r8) :: f0(jfirst-ng_d:jlast+ng_d)
integer, intent(in) :: iord
integer, intent(in) :: jord
real(kind=r8) :: mfx(im,jfirst:jlast)
real(kind=r8) :: mfy(im,jfirst:jlast+1)
integer, intent(in) :: ng_s
integer :: nq
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8) :: rdx(jm)
real(kind=r8) :: rdy
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8) :: tdy5
real(kind=r8), intent(in) :: tiny
real(kind=r8) :: txe5(jm)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: c1
real(kind=r8) :: c2
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: i
integer :: j
integer :: jn1gd
integer :: jn2g0
integer :: jn2g1
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
jn2g0 = min(jm-1,jlast)
jn2g1 = min(jm-1,jlast+1)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
jn1gd = min(jm,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
if ( .not. allocated(d_sw_tape1_delpf_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_delpf_1h)) then
    allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1) = delpf
call tp2c( ub(1,jfirst),va(1,jfirst),delpf(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,xfx,yfx,ffsl,rcap,&
&acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(d_sw_tape1_xfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_xfx_2h)) then
    allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1) = xfx
if ( .not. allocated(d_sw_tape1_yfx_3h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_yfx_3h)) then
    allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1) = yfx
if (nq .gt. 0) then
  do j = js2g0, jn2g0
    do i = 1, im
      cx3(i,j) = cx3(i,j)+crx(i,j)
      mfx(i,j) = mfx(i,j)+xfx(i,j)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      cy3(i,j) = cy3(i,j)+cry(i,j)
      mfy(i,j) = mfy(i,j)+yfx(i,j)
    end do
  end do
endif
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = jfirst, jlast
  do i = 1, im
    wk1(i,j) = delp(i,j)
    delp(i,j) = wk1(i,j)+ub(i,j)
  end do
end do
call tp2c( ub(1,jfirst),va(1,jfirst),pt(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:&
&jlast+1),ffsl,rcap,acosp,xfx,yfx(1,jfirst),cosp,1,jfirst,jlast )
do j = jfirst, jlast
  do i = 1, im
    pt(i,j) = (pt(i,j)*wk1(i,j)+ub(i,j))/delp(i,j)
  end do
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp( im,jm,fy(1:im,jfirst:jlast+1),v(1,jfirst-ng_d),ub(1,jfirst),ub(1,jfirst),ng_d,jord,1,jfirst,jlast )
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
do j = js2g0, jn1g1
  if ( .not. allocated(d_sw_tapej_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_a6_1h)) then
      allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = a6
  if ( .not. allocated(d_sw_tapej_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_slope_2h)) then
      allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = slope
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  call xtp( im,sld,fxj,u(1,j),ub(1,j),iord,ub(1,j),cose(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = txe5(j)*fxj(i)+tdy5*fy(i,j)
  end do
end do
do j = max(2,jfirst-1), jn2g1
  do i = 1, im
    fy(i,j) = v(i,j)*cosp(j)
  end do
end do
do j = js2g0, jn1g1
  uc(1,j) = u(im,j)-u(1,j)
  do i = 2, im
    uc(i,j) = u(i-1,j)-u(i,j)
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,2) = wk1(i,2)-cdy(2)*fy(i,2)+cdx(2)*uc(i,2)
  end do
endif
do j = max(3,jfirst), jn2g1
  do i = 1, im
    wk1(i,j) = wk1(i,j)+cdy(j)*(fy(i,j-1)-fy(i,j))+cdx(j)*uc(i,j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = wk1(i,jm)+cdy(jm)*fy(i,jm-1)+cdx(jm)*uc(i,jm)
  end do
endif
do j = js2gd, jn1gd
  do i = 1, im
    delpf(i,j) = u(i,j)*cose(j)
  end do
end do
if (jfirst .eq. 1) then
  c1 = 0.
  do i = 1, im
    c1 = c1+delpf(i,2)
  end do
  c1 = -(c1*rdy*rcap)
  do i = 1, im
    uc(i,1) = c1
  end do
endif
if (jlast .eq. jm) then
  c2 = 0.
  do i = 1, im
    c2 = c2+delpf(i,jm)
  end do
  c2 = c2*rdy*rcap
  do i = 1, im
    uc(i,jm) = c2
  end do
else
  do i = 1, im
    uc(i,jn2gd) = 1.e+30
  end do
endif
do j = js2gd, min(jm-1,jlast+ng_d-1)
  do i = 1, im-1
    uc(i,j) = (delpf(i,j)-delpf(i,j+1))*cy(j)+(v(i+1,j)-v(i,j))*rdx(j)
  end do
  uc(im,j) = (delpf(im,j)-delpf(im,j+1))*cy(j)+(v(1,j)-v(im,j))*rdx(j)
end do
do j = max(1,jfirst-ng_d), jn1gd
  do i = 1, im
    uc(i,j) = uc(i,j)+f0(j)
  end do
end do
if ( .not. allocated(d_sw_tape1_uc_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_uc_7h)) then
    allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1) = uc
call tp2d( va(1,jfirst),uc(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:jlast+1),ffsl,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
do j = js2g0, jlast
  do i = 1, im-1
    uc(i,j) = dtdxe(j)*(wk1(i,j)-wk1(i+1,j))+dyce(j)*fy(i,j)
  end do
  uc(im,j) = dtdxe(j)*(wk1(im,j)-wk1(1,j))+dyce(j)*fy(im,j)
end do
do j = js2g0, jn2g0
  do i = 1, im
    vc(i,j) = dtdy*(wk1(i,j)-wk1(i,j+1))-dx(j)*fx(i,j)
  end do
end do
end subroutine d_swmd


end module     sw_core_tad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     c_sw_tad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
real(kind=8), allocatable :: c_sw_tape1_a6_5h(:,:)
integer :: c_sw_tape1_c_sw
real(kind=8), allocatable :: c_sw_tape1_crx_9h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_tm2_7h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_v2_6h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_xfx_1h(:,:,:)
real(kind=8), allocatable :: c_sw_tape1_yfx_2h(:,:,:)
real(kind=8), allocatable :: c_sw_tape2_a6_1h(:,:)
integer :: c_sw_tape2_c_sw
real(kind=8), allocatable :: c_sw_tape2_slope_2h(:,:)

end module     c_sw_tad_store


module     d_sw_tad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: d_sw_tape1_d_sw
real(kind=8), allocatable :: d_sw_tape1_delpf_1h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_uc_7h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_xfx_2h(:,:,:)
real(kind=8), allocatable :: d_sw_tape1_yfx_3h(:,:,:)
real(kind=8), allocatable :: d_sw_tapej_a6_1h(:,:)
integer :: d_sw_tapej_d_sw
real(kind=8), allocatable :: d_sw_tapej_slope_2h(:,:)

end module     d_sw_tad_store


module     sw_core_tad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sw_core

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine c_sw_tad( u, v, pt, uc, vc, delpf, cosp, acosp, cose, coslon, sinlon, dtdx2, dtdx4, dtdy5, zt_c, tiny, rcap, im, jm, &
&jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_tad
use c_sw_tad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_tm2_7h,c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,&
&c_sw_tape1_yfx_2h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
integer, intent(in) :: iord
integer, intent(in) :: jn1gc
integer, intent(in) :: jn2g0
integer, intent(in) :: jord
integer, intent(in) :: js2g0
integer, intent(in) :: js2gc
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6h_tad(1+im+2*(im/3))
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
real(kind=r8) :: delpfh_tad(im,jfirst-ng_d:jlast+ng_d)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxjh_tad(im)
real(kind=r8) :: fyh_tad(im,jfirst-1:jlast+1)
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1dh_tad(im)
real(kind=r8) :: pth_tad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: ptkh_tad(im,1+jlast-jfirst)
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_tad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_tad(1+im+2*(im/3))
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: tm2h_tad(im,1+jlast-jfirst)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: us
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vs
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfxh_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6h_tad(:) = 0.d0
delpfh_tad(:,:) = 0.
fxh_tad(:,:) = 0.d0
fxjh_tad(:) = 0.d0
fyh_tad(:,:) = 0.d0
p1dh_tad(:) = 0.d0
pth_tad(:,:) = 0.
ptkh_tad(:,:) = 0.
qtmph_tad(:) = 0.d0
slopeh_tad(:) = 0.d0
tm2h_tad(:,:) = 0.d0
xfxh_tad(:,:) = 0.d0
yfxh_tad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
im2 = im/2
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
xfx = c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1)
yfx = c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
a6 = c_sw_tape1_a6_5h(:,c_sw_tape_rec+1)
v2 = c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1)
tm2 = c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1)
crx = c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1)
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tpcc_tad( tm2,v2(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),im,jm,ng_d,iord,jord,fx,ffsl,cose,jfirst,jlast,slope,qtmp,al,ar,a6 )
do j = jn2g0, js2g1, -1
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  a6 = c_sw_tape2_a6_1h(:,irec)
  slope = c_sw_tape2_slope_2h(:,irec)
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  call xtp_tad( im,sld,fxj,fxjh_tad,p1d,p1dh_tad,cx1,iord,cx1,cosp(j),0,slope,slopeh_tad,qtmp,qtmph_tad,al,ar,a6,a6h_tad )
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_tad( tm2h_tad,va(1,jfirst),pt(1,jfirst-ng_c),pth_tad,crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,fx,fxh_tad,&
&fyh_tad,ffsl,rcap,acosp,xfx,yfx,cosp,1,jfirst,jlast )
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c_tad( ptkh_tad,va(1,jfirst),delpf(1,jfirst-ng_c),delpfh_tad,crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,xfx,&
&xfxh_tad,yfxh_tad,ffsl,rcap,acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )

end subroutine c_sw_tad


subroutine c_swmd( u, v, pt, delp, uc, vc, ptc, delpf, ptk, cosp, acosp, cose, coslon, sinlon, dxdt, dxe, dtdx2, dtdx4, dtxe5, &
&rdxe, dycp, dydt, dtdy5, cye, fc, ifax, trigs, dc, sc, zt_c, tiny, rcap, im, jm, jfirst, jlast, ng_c, ng_d, ng_s, js2g0, jn2g0, &
&js2gc, jn1gc, iord, jord, cosl5, sinl5, c_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_tad, only : tpccmd
use c_sw_tad_store, only : c_sw_tape1_a6_5h,c_sw_tape1_c_sw,c_sw_tape1_crx_9h,c_sw_tape1_tm2_7h,c_sw_tape1_v2_6h,c_sw_tape1_xfx_1h,&
&c_sw_tape1_yfx_2h,c_sw_tape2_a6_1h,c_sw_tape2_c_sw,c_sw_tape2_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer :: c_sw_tape_rec
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
real(kind=r8) :: cye(jm)
integer, intent(in) :: jn2g0
integer, intent(in) :: js2g0
real(kind=r8) :: dc(im,js2g0:jn2g0)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
real(kind=r8) :: delp(im,jfirst:jlast)
integer, intent(in) :: ng_d
real(kind=r8), intent(in) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx2(jm)
real(kind=r8), intent(in) :: dtdx4(jm)
real(kind=r8), intent(in) :: dtdy5
real(kind=r8) :: dtxe5(jm)
real(kind=r8) :: dxdt(jm)
real(kind=r8) :: dxe(jm)
real(kind=r8) :: dycp(jm)
real(kind=r8) :: dydt
integer, intent(in) :: jn1gc
integer, intent(in) :: js2gc
real(kind=r8) :: fc(js2gc:jn1gc)
integer :: ifax(13)
integer, intent(in) :: iord
integer, intent(in) :: jord
integer, intent(in) :: ng_c
integer, intent(in) :: ng_s
real(kind=r8), intent(in) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: ptc(im,jfirst:jlast)
real(kind=r8) :: ptk(im,jfirst:jlast)
real(kind=r8), intent(in) :: rcap
real(kind=r8) :: rdxe(jm)
real(kind=r8) :: sc(js2g0:jn2g0)
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8) :: trigs(3*im/2+1)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(out) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(out) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_c

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-max(1,ng_c):jlast+max(2,ng_c))
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: cx1(im)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: help_h
integer :: help_i
integer :: i
integer :: im2
integer :: irec
integer :: j
integer :: jn1g1
integer :: jn2gc
integer :: js1g1
integer :: js2g1
integer :: js2gc1
integer :: js2gcp1
real(kind=r8) :: p1d(im)
real(kind=r8) :: p1ke
real(kind=r8) :: p2ke
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: tm2(im,jfirst:jlast)
real(kind=r8) :: u2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: un
real(kind=r8) :: us
real(kind=r8) :: v2(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vn
real(kind=r8) :: vs
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
im2 = im/2
js1g1 = max(1,jfirst-1)
js2g1 = max(2,jfirst-1)
js2gcp1 = max(2,jfirst-ng_c-1)
jn1g1 = min(jm,jlast+1)
jn2gc = min(jm-1,jlast+ng_c)
tpcc_tape_rec = c_sw_tape_rec
if (ng_c .eq. 1 .and. ng_d .gt. 1) then
  js2gc1 = js2gc
else
  js2gc1 = max(2,jfirst-ng_c+1)
endif
call vpol5( u(1,jfirst),v(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gcp1, jn2gc
  do i = 1, im-1
    v2(i,j) = v(i,j)+v(i+1,j)
  end do
  v2(im,j) = v(im,j)+v(1,j)
end do
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = u(i,j)+u(i,j+1)
  end do
end do
if (jfirst .eq. 1) then
  us = 0.
  vs = 0.
  do i = 1, im2
    us = us+(u2(i+im2,2)-u2(i,2))*sinlon(i)+(v2(i,2)-v2(i+im2,2))*coslon(i)
    vs = vs+(u2(i+im2,2)-u2(i,2))*coslon(i)+(v2(i+im2,2)-v2(i,2))*sinlon(i)
  end do
  us = us/im
  vs = vs/im
  do i = 1, im2
    u2(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    v2(i,1) = us*coslon(i)-vs*sinlon(i)
    u2(i+im2,1) = -u2(i,1)
    v2(i+im2,1) = -v2(i,1)
  end do
  p1ke = 0.125*(u2(1,1)**2+v2(1,1)**2)
endif
if (jlast .eq. jm) then
  un = 0.
  vn = 0.
  j = jm-1
  do i = 1, im2
    un = un+(u2(i+im2,j)-u2(i,j))*sinlon(i)+(v2(i+im2,j)-v2(i,j))*coslon(i)
    vn = vn+(u2(i,j)-u2(i+im2,j))*coslon(i)+(v2(i+im2,j)-v2(i,j))*sinlon(i)
  end do
  un = un/im
  vn = vn/im
  do i = 1, im2
    u2(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    v2(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    u2(i+im2,jm) = -u2(i,jm)
    v2(i+im2,jm) = -v2(i,jm)
  end do
  p2ke = 0.125*(u2(1,jm)**2+v2(1,jm)**2)
endif
do j = js2gc, jn2gc
  uc(1,j) = 0.25*(u2(1,j)+u2(im,j))
  do i = 2, im
    uc(i,j) = 0.25*(u2(i,j)+u2(i-1,j))
  end do
end do
do i = 1, im
  vc(i,jfirst-2) = 0.
  vc(i,jfirst-1) = 0.
  vc(i,jfirst) = 0.
  vc(i,jlast+1) = 0.
  vc(i,jlast+2) = 0.
end do
do j = js2gc, jn1gc
  do i = 1, im
    vc(i,j) = 0.25*(v2(i,j)+v2(i,j-1))
  end do
end do
do j = js2g1, jn1g1
  do i = 1, im
    cry(i,j) = dtdy5*vc(i,j)
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g1, jn2g0
  do i = 1, im
    va(i,j) = 0.5*(cry(i,j)+cry(i,j+1))
  end do
end do
do j = jfirst-1, jlast
  do i = 1, im
    crx(i,j) = 0.
  end do
end do
do j = js2gc, jn2gc
  do i = 1, im
    crx(i,j) = uc(i,j)*dtdx2(j)
  end do
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tp2c( ptk,va(1,jfirst),delpf(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,xfx,yfx,ffsl,rcap,acosp,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(c_sw_tape1_xfx_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_xfx_1h)) then
    allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_xfx_1h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_xfx_1h(:,:,c_sw_tape_rec+1) = xfx
if ( .not. allocated(c_sw_tape1_yfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_yfx_2h)) then
    allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_yfx_2h(1:im,1:1+1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_yfx_2h(:,:,c_sw_tape_rec+1) = yfx
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
call tp2c( tm2,va(1,jfirst),pt(1,jfirst-ng_c),crx(1,jfirst-ng_c),cry(1,jfirst),im,jm,iord,jord,ng_c,fx,fy(1,jfirst),ffsl,rcap,&
&acosp,xfx,yfx,cosp,1,jfirst,jlast )
help_h = jn2g0-js2g0+1
call pft2d( ptk(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_h,ifax,trigs,v2,crx )
help_i = jn2g0-js2g0+1
call pft2d( tm2(1,js2g0),sc(js2g0),dc(1,js2g0),im,help_i,ifax,trigs,v2,crx )
do j = jfirst, jlast
  do i = 1, im
    ptk(i,j) = delp(i,j)+ptk(i,j)
    ptc(i,j) = (pt(i,j)*delp(i,j)+tm2(i,j))/ptk(i,j)
  end do
end do
call ycc( im,jm,fy,vc(1,jfirst-2),va(1,jfirst-1),va(1,jfirst-1),jord,1,jfirst,jlast )
do j = js2g1, jn2g0
  irec = 1+j-js2g1+c_sw_tape_rec*(jn2g0-js2g1+1)
  if ( .not. allocated(c_sw_tape2_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_a6_1h)) then
      allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_a6_1h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_a6_1h(:,irec) = a6
  if ( .not. allocated(c_sw_tape2_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(c_sw_tape2_slope_2h)) then
      allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( c_sw_tape2_slope_2h(1:1+im+2*(im/3),c_sw_tape2_c_sw) )
#endif /* USE_OPENMP */
  endif
  c_sw_tape2_slope_2h(:,irec) = slope
  do i = 1, im
    cx1(i) = dtdx4(j)*u2(i,j)
  end do
  sld =  .false. 
  if (cosp(j) .lt. zt_c) then
    do i = 1, im
      if (abs(cx1(i)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  p1d(im) = uc(1,j)
  do i = 1, im-1
    p1d(i) = uc(i+1,j)
  end do
  call xtp( im,sld,fxj,p1d,cx1,iord,cx1,cosp(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = dxdt(j)*fxj(i)+dydt*fy(i,j)
  end do
end do
if ( .not. allocated(c_sw_tape1_a6_5h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_a6_5h)) then
    allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_a6_5h(1:1+im+2*(im/3),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_a6_5h(:,c_sw_tape_rec+1) = a6
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,1) = p1ke
  end do
endif
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = p2ke
  end do
endif
do j = js2gc1, jn1gc
  crx(1,j) = dtxe5(j)*u(im,j)
  do i = 2, im
    crx(i,j) = dtxe5(j)*u(i-1,j)
  end do
end do
do j = js1g1, jlast
  do i = 1, im
    cry(i,j) = dtdy5*v(i,j)
  end do
end do
do j = jfirst, jlast
  do i = 1, im
    ymass(i,j) = cry(i,j)*cosp(j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im
    tm2(i,j) = 0.5*(cry(i,j)+cry(i,j-1))
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    u2(i,1) = 0.
  end do
endif
do j = js2gc, jn2gc
  do i = 1, im
    u2(i,j) = uc(i,j)*cosp(j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    u2(i,jm) = 0.
  end do
endif
do j = js2gc1, jn1gc
  v2(1,j) = fc(j)+(u2(1,j-1)-u2(1,j))*cye(j)+(vc(1,j)-vc(im,j))*rdxe(j)
  do i = 2, im
    v2(i,j) = fc(j)+(u2(i,j-1)-u2(i,j))*cye(j)+(vc(i,j)-vc(i-1,j))*rdxe(j)
  end do
end do
if ( .not. allocated(c_sw_tape1_v2_6h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_v2_6h)) then
    allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_v2_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_v2_6h(:,:,c_sw_tape_rec+1) = v2
if ( .not. allocated(c_sw_tape1_tm2_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_tm2_7h)) then
    allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_tm2_7h(1:im,1:1+jlast-jfirst,c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_tm2_7h(:,:,c_sw_tape_rec+1) = tm2
if ( .not. allocated(c_sw_tape1_crx_9h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(c_sw_tape1_crx_9h)) then
    allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( c_sw_tape1_crx_9h(1:im,1:1+jlast+max(2,ng_c)-(jfirst-max(1,ng_c)),c_sw_tape1_c_sw) )
#endif /* USE_OPENMP */
endif
c_sw_tape1_crx_9h(:,:,c_sw_tape_rec+1) = crx
do j = js2gc1, jn1gc
  ffsl(j) =  .false. 
  if (cose(j) .lt. zt_c) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
call tpccmd( tm2,ymass,v2(1,jfirst-ng_d),crx(1:im,jfirst-1:jlast+2),cry(1:im,jfirst:jlast),im,jm,ng_d,iord,jord,fx,fy(1:im,jfirst:&
&jlast),ffsl,cose,jfirst,jlast,slope,qtmp,al,ar,a6 )
do j = js2g0, jn2g0
  uc(1,j) = uc(1,j)+dtdx2(j)*(wk1(im,j)-wk1(1,j))+dycp(j)*fy(1,j)
  do i = 2, im
    uc(i,j) = uc(i,j)+dtdx2(j)*(wk1(i-1,j)-wk1(i,j))+dycp(j)*fy(i,j)
  end do
end do
do j = js2g0, jlast
  do i = 1, im-1
    vc(i,j) = vc(i,j)+dtdy5*(wk1(i,j-1)-wk1(i,j))-dxe(j)*fx(i+1,j)
  end do
  vc(im,j) = vc(im,j)+dtdy5*(wk1(im,j-1)-wk1(im,j))-dxe(j)*fx(1,j)
end do
end subroutine c_swmd


subroutine d_sw_tad( u, v, uc, vc, pt, delpf, dtdx, dtxe5, js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, iord, jord, zt_d, rcap,&
& tiny, dtdy, dtdy5, cosp, acosp, cose, coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use tp_core_tad
use d_sw_tad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delpf_1h,d_sw_tape1_uc_7h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,&
&d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer :: d_sw_tape_rec
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
integer, intent(in) :: iord
integer, intent(in) :: jn1g1
integer, intent(in) :: jord
integer, intent(in) :: js2g0
integer, intent(in) :: ng_s
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8), intent(in) :: tiny
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: a6h_tad(1+im+2*(im/3))
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
real(kind=r8) :: delpfh_tad(im,jfirst-ng_d:jlast+ng_d)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: fxi_tad(im,1+jlast-jfirst)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fxjh_tad(im)
real(kind=r8) :: fyh_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: fyi_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: fyj_tad(im,1+1+jlast-jfirst)
integer :: i
integer :: j
integer :: jn2g0
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: pth_tad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: qtmp(-(im/3):im+im/3)
real(kind=r8) :: qtmph_tad(1+im+2*(im/3))
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: slopeh_tad(1+im+2*(im/3))
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: ubh_tad(im,jfirst:jlast+1)
real(kind=r8) :: ubi_tad(im,jfirst:jlast+1)
real(kind=r8) :: uch_tad(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: uh_tad(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: vh_tad(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: xfxh_tad(im,1+jlast-jfirst)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: yfxh_tad(im,1+1+jlast-jfirst)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a6h_tad(:) = 0.d0
delpfh_tad(:,:) = 0.
fxh_tad(:,:) = 0.d0
fxi_tad(:,:) = 0.d0
fxjh_tad(:) = 0.d0
fyh_tad(:,:) = 0.d0
fyi_tad(:,:) = 0.d0
fyj_tad(:,:) = 0.d0
pth_tad(:,:) = 0.
qtmph_tad(:) = 0.d0
slopeh_tad(:) = 0.d0
ubh_tad(:,:) = 0.d0
ubi_tad(:,:) = 0.d0
uch_tad(:,:) = 0.
uh_tad(:,:) = 0.
vh_tad(:,:) = 0.
xfxh_tad(:,:) = 0.d0
yfxh_tad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
jn2g0 = min(jm-1,jlast)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
delpf = d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1)
xfx = d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1)
yfx = d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1)
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
uc = d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1)
call tp2d_tad( va(1,jfirst),uc(1,jfirst-ng_d),uch_tad,crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fxh_tad,fyh_tad,&
&ffsl,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
do j = jn1g1, js2g0, -1
  a6 = d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  slope = d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1))
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  call xtp_tad( im,sld,fxj,fxjh_tad,u(1,j),uh_tad,ub(1,j),iord,ub(1,j),cose(j),0,slope,slopeh_tad,qtmp,qtmph_tad,al,ar,a6,a6h_tad )
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp_tad( im,jm,fyi_tad,v(1,jfirst-ng_d),vh_tad,ub(1,jfirst),ub(1,jfirst),ng_d,jord,1,jfirst,jlast )
call tp2c_tad( ubh_tad,va(1,jfirst),pt(1,jfirst-ng_d),pth_tad,crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fxi_tad,&
&fyj_tad,ffsl,rcap,acosp,xfx,yfx(1,jfirst),cosp,1,jfirst,jlast )
call tp2c_tad( ubi_tad,va(1,jfirst),delpf(1,jfirst-ng_d),delpfh_tad,crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,xfx,&
&xfxh_tad,yfxh_tad,ffsl,rcap,acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )

end subroutine d_sw_tad


subroutine d_swmd( u, v, uc, vc, pt, delp, delpf, cx3, cy3, mfx, mfy, cdx, cdy, dtdx, dtdxe, dtxe5, txe5, dyce, rdx, cy, dx, f0, &
&js2g0, jn1g1, im, jm, jfirst, jlast, ng_d, ng_s, nq, iord, jord, zt_d, rcap, tiny, dtdy, dtdy5, tdy5, rdy, cosp, acosp, cose, &
&coslon, sinlon, cosl5, sinl5, d_sw_tape_rec )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use tp_core
use d_sw_tad_store, only : d_sw_tape1_d_sw,d_sw_tape1_delpf_1h,d_sw_tape1_uc_7h,d_sw_tape1_xfx_2h,d_sw_tape1_yfx_3h,&
&d_sw_tapej_a6_1h,d_sw_tapej_d_sw,d_sw_tapej_slope_2h

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: jm
real(kind=r8), intent(in) :: acosp(jm)
integer, intent(in) :: jn1g1
integer, intent(in) :: js2g0
real(kind=r8) :: cdx(js2g0:jn1g1)
real(kind=r8) :: cdy(js2g0:jn1g1)
real(kind=r8), intent(in) :: cose(jm)
integer, intent(in) :: im
real(kind=r8), intent(in) :: cosl5(im)
real(kind=r8), intent(in) :: coslon(im)
real(kind=r8), intent(in) :: cosp(jm)
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: ng_d
real(kind=r8) :: cx3(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cy(jm)
real(kind=r8) :: cy3(im,jfirst:jlast+1)
integer :: d_sw_tape_rec
real(kind=r8) :: delp(im,jfirst:jlast)
real(kind=r8), intent(inout) :: delpf(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: dtdx(jm)
real(kind=r8) :: dtdxe(jm)
real(kind=r8), intent(in) :: dtdy
real(kind=r8), intent(in) :: dtdy5
real(kind=r8), intent(in) :: dtxe5(jm)
real(kind=r8) :: dx(jm)
real(kind=r8) :: dyce(jm)
real(kind=r8) :: f0(jfirst-ng_d:jlast+ng_d)
integer, intent(in) :: iord
integer, intent(in) :: jord
real(kind=r8) :: mfx(im,jfirst:jlast)
real(kind=r8) :: mfy(im,jfirst:jlast+1)
integer, intent(in) :: ng_s
integer :: nq
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: rcap
real(kind=r8) :: rdx(jm)
real(kind=r8) :: rdy
real(kind=r8), intent(in) :: sinl5(im)
real(kind=r8), intent(in) :: sinlon(im)
real(kind=r8) :: tdy5
real(kind=r8), intent(in) :: tiny
real(kind=r8) :: txe5(jm)
real(kind=r8), intent(in) :: u(im,jfirst-ng_d:jlast+ng_s)
real(kind=r8), intent(inout) :: uc(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8), intent(in) :: v(im,jfirst-ng_s:jlast+ng_d)
real(kind=r8), intent(inout) :: vc(im,jfirst-2:jlast+2)
real(kind=r8), intent(in) :: zt_d

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: a6(-(im/3):im+im/3)
real(kind=r8) :: al(-(im/3):im+im/3)
real(kind=r8) :: ar(-(im/3):im+im/3)
real(kind=r8) :: c1
real(kind=r8) :: c2
real(kind=r8) :: crx(im,jfirst-ng_d:jlast+ng_d)
real(kind=r8) :: cry(im,jfirst-1:jlast+1)
logical :: ffsl(jm)
real(kind=r8) :: fx(im,jfirst:jlast)
real(kind=r8) :: fxj(im)
real(kind=r8) :: fy(im,jfirst-1:jlast+1)
integer :: i
integer :: j
integer :: jn1gd
integer :: jn2g0
integer :: jn2g1
integer :: jn2gd
integer :: js2gd
real(kind=r8) :: qtmp(-(im/3):im+im/3)
logical :: sld
real(kind=r8) :: slope(-(im/3):im+im/3)
real(kind=r8) :: ub(im,jfirst:jlast+1)
real(kind=r8) :: va(im,jfirst-1:jlast)
real(kind=r8) :: wk1(im,jfirst-1:jlast+1)
real(kind=r8) :: xfx(im,jfirst:jlast)
real(kind=r8) :: yfx(im,jfirst:jlast+1)
real(kind=r8) :: ymass(im,jfirst:jlast+1)

!**********************************************
! executable statements of routine
!**********************************************
jn2g0 = min(jm-1,jlast)
jn2g1 = min(jm-1,jlast+1)
js2gd = max(2,jfirst-ng_d)
jn2gd = min(jm-1,jlast+ng_d)
jn1gd = min(jm,jlast+ng_d)
call upol5( uc(1,jfirst),vc(1,jfirst),im,jm,coslon,sinlon,cosl5,sinl5,jfirst,jlast )
do j = js2gd, jn2gd
  do i = 1, im
    crx(i,j) = dtdx(j)*uc(i,j)
  end do
end do
do j = js2gd, jn2gd
  ffsl(j) =  .false. 
  if (cosp(j) .lt. zt_d) then
    do i = 1, im
      if (abs(crx(i,j)) .gt. 1.) then
        ffsl(j) =  .true. 
        exit
      endif
    end do
  endif
end do
do j = js2g0, jn1g1
  do i = 1, im
    cry(i,j) = dtdy*vc(i,j)
    ymass(i,j) = cry(i,j)*cose(j)
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im
    if (cry(i,j)*cry(i,j+1) .gt. 0.) then
      if (cry(i,j) .gt. 0.) then
        va(i,j) = cry(i,j)
      else
        va(i,j) = cry(i,j+1)
      endif
    else
      va(i,j) = 0.
    endif
  end do
end do
if ( .not. allocated(d_sw_tape1_delpf_1h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_delpf_1h)) then
    allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_delpf_1h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_delpf_1h(:,:,d_sw_tape_rec+1) = delpf
call tp2c( ub(1,jfirst),va(1,jfirst),delpf(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,xfx,yfx,ffsl,rcap,&
&acosp,crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
if ( .not. allocated(d_sw_tape1_xfx_2h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_xfx_2h)) then
    allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_xfx_2h(1:im,1:1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_xfx_2h(:,:,d_sw_tape_rec+1) = xfx
if ( .not. allocated(d_sw_tape1_yfx_3h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_yfx_3h)) then
    allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_yfx_3h(1:im,1:1+1+jlast-jfirst,d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_yfx_3h(:,:,d_sw_tape_rec+1) = yfx
if (nq .gt. 0) then
  do j = js2g0, jn2g0
    do i = 1, im
      cx3(i,j) = cx3(i,j)+crx(i,j)
      mfx(i,j) = mfx(i,j)+xfx(i,j)
    end do
  end do
  do j = js2g0, jlast
    do i = 1, im
      cy3(i,j) = cy3(i,j)+cry(i,j)
      mfy(i,j) = mfy(i,j)+yfx(i,j)
    end do
  end do
endif
do j = js2g0, jn2g0
  if (ffsl(j)) then
    do i = 1, im
      xfx(i,j) = xfx(i,j)/sign(max(abs(crx(i,j)),tiny),crx(i,j))
    end do
  endif
end do
do j = jfirst, jlast
  do i = 1, im
    wk1(i,j) = delp(i,j)
    delp(i,j) = wk1(i,j)+ub(i,j)
  end do
end do
call tp2c( ub(1,jfirst),va(1,jfirst),pt(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:&
&jlast+1),ffsl,rcap,acosp,xfx,yfx(1,jfirst),cosp,1,jfirst,jlast )
do j = jfirst, jlast
  do i = 1, im
    pt(i,j) = (pt(i,j)*wk1(i,j)+ub(i,j))/delp(i,j)
  end do
end do
do j = js2g0, jn1g1
  ub(1,j) = dtdy5*(vc(1,j)+vc(im,j))
  do i = 2, im
    ub(i,j) = dtdy5*(vc(i,j)+vc(i-1,j))
  end do
end do
call ytp( im,jm,fy(1:im,jfirst:jlast+1),v(1,jfirst-ng_d),ub(1,jfirst),ub(1,jfirst),ng_d,jord,1,jfirst,jlast )
do j = js2g0, jn1g1
  do i = 1, im
    ub(i,j) = dtxe5(j)*(uc(i,j)+uc(i,j-1))
  end do
end do
do j = js2g0, jn1g1
  if ( .not. allocated(d_sw_tapej_a6_1h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_a6_1h)) then
      allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_a6_1h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_a6_1h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = a6
  if ( .not. allocated(d_sw_tapej_slope_2h)) then
#ifdef USE_OPENMP
    !$omp critical  (store)
    if ( .not. allocated(d_sw_tapej_slope_2h)) then
      allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
    endif
    !$omp end critical (store)
#else /* USE_OPENMP */
    allocate( d_sw_tapej_slope_2h(1:1+im+2*(im/3),d_sw_tapej_d_sw) )
#endif /* USE_OPENMP */
  endif
  d_sw_tapej_slope_2h(:,1+j-js2g0+d_sw_tape_rec*(jn1g1-js2g0+1)) = slope
  sld =  .false. 
  if (cose(j) .lt. zt_d) then
    do i = 1, im
      if (abs(ub(i,j)) .gt. 1.) then
        sld =  .true. 
        exit
      endif
    end do
  endif
  call xtp( im,sld,fxj,u(1,j),ub(1,j),iord,ub(1,j),cose(j),0,slope,qtmp,al,ar,a6 )
  do i = 1, im
    wk1(i,j) = txe5(j)*fxj(i)+tdy5*fy(i,j)
  end do
end do
do j = max(2,jfirst-1), jn2g1
  do i = 1, im
    fy(i,j) = v(i,j)*cosp(j)
  end do
end do
do j = js2g0, jn1g1
  uc(1,j) = u(im,j)-u(1,j)
  do i = 2, im
    uc(i,j) = u(i-1,j)-u(i,j)
  end do
end do
if (jfirst .eq. 1) then
  do i = 1, im
    wk1(i,2) = wk1(i,2)-cdy(2)*fy(i,2)+cdx(2)*uc(i,2)
  end do
endif
do j = max(3,jfirst), jn2g1
  do i = 1, im
    wk1(i,j) = wk1(i,j)+cdy(j)*(fy(i,j-1)-fy(i,j))+cdx(j)*uc(i,j)
  end do
end do
if (jlast .eq. jm) then
  do i = 1, im
    wk1(i,jm) = wk1(i,jm)+cdy(jm)*fy(i,jm-1)+cdx(jm)*uc(i,jm)
  end do
endif
do j = js2gd, jn1gd
  do i = 1, im
    delpf(i,j) = u(i,j)*cose(j)
  end do
end do
if (jfirst .eq. 1) then
  c1 = 0.
  do i = 1, im
    c1 = c1+delpf(i,2)
  end do
  c1 = -(c1*rdy*rcap)
  do i = 1, im
    uc(i,1) = c1
  end do
endif
if (jlast .eq. jm) then
  c2 = 0.
  do i = 1, im
    c2 = c2+delpf(i,jm)
  end do
  c2 = c2*rdy*rcap
  do i = 1, im
    uc(i,jm) = c2
  end do
else
  do i = 1, im
    uc(i,jn2gd) = 1.e+30
  end do
endif
do j = js2gd, min(jm-1,jlast+ng_d-1)
  do i = 1, im-1
    uc(i,j) = (delpf(i,j)-delpf(i,j+1))*cy(j)+(v(i+1,j)-v(i,j))*rdx(j)
  end do
  uc(im,j) = (delpf(im,j)-delpf(im,j+1))*cy(j)+(v(1,j)-v(im,j))*rdx(j)
end do
do j = max(1,jfirst-ng_d), jn1gd
  do i = 1, im
    uc(i,j) = uc(i,j)+f0(j)
  end do
end do
if ( .not. allocated(d_sw_tape1_uc_7h)) then
#ifdef USE_OPENMP
  !$omp critical  (store)
  if ( .not. allocated(d_sw_tape1_uc_7h)) then
    allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
  endif
  !$omp end critical (store)
#else /* USE_OPENMP */
  allocate( d_sw_tape1_uc_7h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),d_sw_tape1_d_sw) )
#endif /* USE_OPENMP */
endif
d_sw_tape1_uc_7h(:,:,d_sw_tape_rec+1) = uc
call tp2d( va(1,jfirst),uc(1,jfirst-ng_d),crx(1,jfirst-ng_d),cry(1,jfirst),im,jm,iord,jord,ng_d,fx,fy(1:im,jfirst:jlast+1),ffsl,&
&crx(1,jfirst),ymass,cosp,0,jfirst,jlast )
do j = js2g0, jlast
  do i = 1, im-1
    uc(i,j) = dtdxe(j)*(wk1(i,j)-wk1(i+1,j))+dyce(j)*fy(i,j)
  end do
  uc(im,j) = dtdxe(j)*(wk1(im,j)-wk1(1,j))+dyce(j)*fy(im,j)
end do
do j = js2g0, jn2g0
  do i = 1, im
    vc(i,j) = dtdy*(wk1(i,j)-wk1(i,j+1))-dx(j)*fx(i,j)
  end do
end do
end subroutine d_swmd


end module     sw_core_tad


#endif /* SPMD */
