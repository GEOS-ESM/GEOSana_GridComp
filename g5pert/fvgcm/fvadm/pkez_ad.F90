#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine pkez_ad( nx, im, km, jfirst, jlast, pe, pe_ae, pk, pk_ae, akap, ks, peln, peln_ad, pkz_ae, eta )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: akap
logical :: eta
integer :: im
integer :: jfirst
integer :: jlast
integer :: km
integer :: ks
integer :: nx
real(kind=r8) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8) :: peln(im,km+1,jfirst:jlast)
real(kind=r8) :: peln_ad(im,km+1,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8) :: pkz_ae(im,jfirst:jlast,km)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: i1
integer :: i2
integer :: it
integer :: ixj
integer :: j
integer :: jp
integer :: k
real(kind=r8) :: lnp
real(kind=r8) :: lnp_ad
#ifdef USE_OPENMP
real(kind=r8) :: pe_aeh(im,km+1,jfirst:jlast)
#endif /* ! USE_OPENMP */
real(kind=r8) :: pek
real(kind=r8) :: pek_ad
real(kind=r8) :: pk2(im,km+1)
real(kind=r8) :: pk2_ad(im,km+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
lnp_ad = 0.d0
pek_ad = 0.d0
pk2_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
it = im/nx
jp = nx*(jlast-jfirst+1)
#ifdef USE_OPENMP
!!oloso pe_aeh(:,:,:) = pe_ae(:,:,:)
!$omp parallel do shared(akap,eta,it,jfirst,jp,km,ks,nx,pe,pe_ae,peln,peln_ad,pk,pk_ae,pkz_ae) private(i,i1,i2,ixj,j,k,lnp,lnp_ad,&
!$omp& pek,pek_ad,pk2,pk2_ad)
#endif /* ! USE_OPENMP */
do ixj = 1, jp
  lnp_ad = 0.d0
  pek_ad = 0.d0
  j = jfirst+(ixj-1)/nx
  i1 = 1+it*mod(ixj-1,nx)
  i2 = i1+it-1
#ifdef USE_OPENMP
!!oloso   pe_ae(i1:i2,:,j) = 0.d0
#endif /* ! USE_OPENMP */
  pk2_ad(i1:i2,:) = 0.d0
!  pk2_ad(:,:) = 0.d0
  if (eta) then
    pek = pk(i1,j,1)
    lnp = log(pe(i1,1,j))
    do i = i1, i2
      pk2(i,1) = pek
      peln(i,1,j) = lnp
    end do
    if (ks .ne. 0) then
      do k = 2, ks+1
        pek = pe(i1,k,j)**akap
        lnp = log(pe(i1,k,j))
        do i = i1, i2
          pk2(i,k) = pek
          peln(i,k,j) = lnp
        end do
      end do
    endif
    do k = ks+2, km
      do i = i1, i2
        pk2(i,k) = pe(i,k,j)**akap
      end do
    end do
    do i = i1, i2
      pk2(i,km+1) = pk(i,j,km+1)
    end do
    do k = ks+2, km+1
      do i = i1, i2
        peln(i,k,j) = log(pe(i,k,j))
      end do
    end do
    do k = 2, km
      do i = i1, i2
        pk2_ad(i,k) = pk2_ad(i,k)+pk_ae(i,j,k)
        pk_ae(i,j,k) = 0.d0
      end do
    end do
    do k = ks+1, km
      do i = i1, i2
        peln_ad(i,k+1,j) = peln_ad(i,k+1,j)-pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*&
&(peln(i,k+1,j)-peln(i,k,j))))
        peln_ad(i,k,j) = peln_ad(i,k,j)+pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+&
&1,j)-peln(i,k,j))))
        pk2_ad(i,k+1) = pk2_ad(i,k+1)+pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pk2_ad(i,k) = pk2_ad(i,k)-pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pkz_ae(i,j,k) = 0.d0
      end do
    end do
    do k = ks+2, km+1
      do i = i1, i2
        pe_ae(i,k,j) = pe_ae(i,k,j)+peln_ad(i,k,j)*(1./pe(i,k,j))
        peln_ad(i,k,j) = 0.d0
      end do
    end do
    do i = i1, i2
      pk_ae(i,j,km+1) = pk_ae(i,j,km+1)+pk2_ad(i,km+1)
      pk2_ad(i,km+1) = 0.d0
    end do
    do k = ks+2, km
      do i = i1, i2
        pe_ae(i,k,j) = pe_ae(i,k,j)+pk2_ad(i,k)*akap*pe(i,k,j)**(akap-1)
        pk2_ad(i,k) = 0.d0
      end do
    end do
    pek = pk(i1,j,1)
    lnp = log(pe(i1,1,j))
    do i = i1, i2
      pk2(i,1) = pek
      peln(i,1,j) = lnp
    end do
    if (ks .ne. 0) then
      do k = 2, ks+1
        pek = pe(i1,k,j)**akap
        lnp = log(pe(i1,k,j))
        do i = i1, i2
          pk2(i,k) = pek
          peln(i,k,j) = lnp
        end do
      end do
      do k = 1, ks
        pek_ad = 0.d0
        do i = i1, i2
          pek_ad = pek_ad+pkz_ae(i,j,k)
          pkz_ae(i,j,k) = 0.d0
        end do
        peln_ad(i1,k+1,j) = peln_ad(i1,k+1,j)-pek_ad*((pk2(i1,k+1)-pk2(i1,k))*akap/(akap*(peln(i1,k+1,j)-peln(i1,k,j))*akap*&
&(peln(i1,k+1,j)-peln(i1,k,j))))
        peln_ad(i1,k,j) = peln_ad(i1,k,j)+pek_ad*((pk2(i1,k+1)-pk2(i1,k))*akap/(akap*(peln(i1,k+1,j)-peln(i1,k,j))*akap*(peln(i1,k+&
&1,j)-peln(i1,k,j))))
        pk2_ad(i1,k+1) = pk2_ad(i1,k+1)+pek_ad/(akap*(peln(i1,k+1,j)-peln(i1,k,j)))
        pk2_ad(i1,k) = pk2_ad(i1,k)-pek_ad/(akap*(peln(i1,k+1,j)-peln(i1,k,j)))
        pek_ad = 0.d0
      end do
      do k = 2, ks+1
        lnp_ad = 0.d0
        pek_ad = 0.d0
        do i = i1, i2
          lnp_ad = lnp_ad+peln_ad(i,k,j)
          peln_ad(i,k,j) = 0.d0
          pek_ad = pek_ad+pk2_ad(i,k)
          pk2_ad(i,k) = 0.d0
        end do
        pe_ae(i1,k,j) = pe_ae(i1,k,j)+lnp_ad*(1./pe(i1,k,j))
        lnp_ad = 0.d0
        pe_ae(i1,k,j) = pe_ae(i1,k,j)+pek_ad*akap*pe(i1,k,j)**(akap-1)
        pek_ad = 0.d0
      end do
    endif
    do i = i1, i2
      lnp_ad = lnp_ad+peln_ad(i,1,j)
      peln_ad(i,1,j) = 0.d0
      pek_ad = pek_ad+pk2_ad(i,1)
      pk2_ad(i,1) = 0.d0
    end do
    pe_ae(i1,1,j) = pe_ae(i1,1,j)+lnp_ad*(1./pe(i1,1,j))
    lnp_ad = 0.d0
    pk_ae(i1,j,1) = pk_ae(i1,j,1)+pek_ad
    pek_ad = 0.d0
  else
    pek = pk(i1,j,1)
    lnp = log(pe(i1,1,j))
    do i = i1, i2
      pk2(i,1) = pek
      peln(i,1,j) = lnp
    end do
    do k = 2, km+1
      do i = i1, i2
        peln(i,k,j) = log(pe(i,k,j))
        pk2(i,k) = pk(i,j,k)
      end do
    end do
    do k = 1, km
      do i = i1, i2
        peln_ad(i,k+1,j) = peln_ad(i,k+1,j)-pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*&
&(peln(i,k+1,j)-peln(i,k,j))))
        peln_ad(i,k,j) = peln_ad(i,k,j)+pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+&
&1,j)-peln(i,k,j))))
        pk2_ad(i,k+1) = pk2_ad(i,k+1)+pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pk2_ad(i,k) = pk2_ad(i,k)-pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pkz_ae(i,j,k) = 0.d0
      end do
    end do
    do k = 2, km+1
      do i = i1, i2
        pk_ae(i,j,k) = pk_ae(i,j,k)+pk2_ad(i,k)
        pk2_ad(i,k) = 0.d0
        pe_ae(i,k,j) = pe_ae(i,k,j)+peln_ad(i,k,j)*(1./pe(i,k,j))
        peln_ad(i,k,j) = 0.d0
      end do
    end do
    do i = i1, i2
      lnp_ad = lnp_ad+peln_ad(i,1,j)
      peln_ad(i,1,j) = 0.d0
      pek_ad = pek_ad+pk2_ad(i,1)
      pk2_ad(i,1) = 0.d0
    end do
    pe_ae(i1,1,j) = pe_ae(i1,1,j)+lnp_ad*(1./pe(i1,1,j))
    lnp_ad = 0.d0
    pk_ae(i1,j,1) = pk_ae(i1,j,1)+pek_ad
    pek_ad = 0.d0
  endif
#ifdef USE_OPENMP
!!oloso  !$omp critical  (adtaf)
!!oloso   pe_aeh(i1:i2,:,j) = pe_aeh(i1:i2,:,j)+pe_ae(i1:i2,:,j)
!!oloso  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
!!oloso pe_ae(:,:,:) = pe_aeh(:,:,:)
#endif /* ! USE_OPENMP */

end subroutine pkez_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine pkez_ad( nx, im, km, jfirst, jlast, pe, pe_ae, pk, pk_ae, akap, ks, peln, peln_ad, pkz_ae, eta )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
#ifdef TIMING
use timingmodule, only: timing_on, timing_off
#endif

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8) :: akap
logical :: eta
integer :: im
integer :: jfirst
integer :: jlast
integer :: km
integer :: ks
integer :: nx
real(kind=r8) :: pe(im,km+1,jfirst:jlast)
real(kind=r8) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8) :: peln(im,km+1,jfirst:jlast)
real(kind=r8) :: peln_ad(im,km+1,jfirst:jlast)
real(kind=r8) :: pk(im,jfirst:jlast,km+1)
real(kind=r8) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8) :: pkz_ae(im,jfirst:jlast,km)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: i1
integer :: i2
integer :: it
integer :: ixj
integer :: j
integer :: jp
integer :: k
real(kind=r8) :: lnp
real(kind=r8) :: lnp_ad
#ifdef USE_OPENMP
real(kind=r8) :: pe_aeh(im,km+1,jfirst:jlast)
#endif /* ! USE_OPENMP */
real(kind=r8) :: pek
real(kind=r8) :: pek_ad
real(kind=r8) :: pk2(im,km+1)
real(kind=r8) :: pk2_ad(im,km+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
lnp_ad = 0.d0
pek_ad = 0.d0
pk2_ad(:,:) = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
it = im/nx
jp = nx*(jlast-jfirst+1)
#ifdef TIMING
call timing_on("pkez_ad1")
#endif
#ifdef USE_OPENMP
!!oloso pe_aeh(:,:,:) = pe_ae(:,:,:)
!$omp parallel do shared(akap,eta,it,jfirst,jp,km,ks,nx,pe,pe_ae,peln,peln_ad,pk,pk_ae,pkz_ae) private(i,i1,i2,ixj,j,k,lnp,lnp_ad,&
!$omp& pek,pek_ad,pk2,pk2_ad)
#endif /* ! USE_OPENMP */
do ixj = 1, jp
  lnp_ad = 0.d0
  pek_ad = 0.d0
  j = jfirst+(ixj-1)/nx
  i1 = 1+it*mod(ixj-1,nx)
  i2 = i1+it-1
#ifdef USE_OPENMP
!!oloso   pe_ae(i1:i2,:,j) = 0.d0
#endif /* ! USE_OPENMP */
  pk2_ad(i1:i2,:) = 0.d0
!  pk2_ad(:,:) = 0.d0
  if (eta) then
    pek = pk(i1,j,1)
    lnp = log(pe(i1,1,j))
    do i = i1, i2
      pk2(i,1) = pek
      peln(i,1,j) = lnp
    end do
    if (ks .ne. 0) then
      do k = 2, ks+1
        pek = pe(i1,k,j)**akap
        lnp = log(pe(i1,k,j))
        do i = i1, i2
          pk2(i,k) = pek
          peln(i,k,j) = lnp
        end do
      end do
    endif
    do k = ks+2, km
      do i = i1, i2
        pk2(i,k) = pe(i,k,j)**akap
      end do
    end do
    do i = i1, i2
      pk2(i,km+1) = pk(i,j,km+1)
    end do
    do k = ks+2, km+1
      do i = i1, i2
        peln(i,k,j) = log(pe(i,k,j))
      end do
    end do
    do k = 2, km
      do i = i1, i2
        pk2_ad(i,k) = pk2_ad(i,k)+pk_ae(i,j,k)
        pk_ae(i,j,k) = 0.d0
      end do
    end do
    do k = ks+1, km
      do i = i1, i2
        peln_ad(i,k+1,j) = peln_ad(i,k+1,j)-pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*&
&(peln(i,k+1,j)-peln(i,k,j))))
        peln_ad(i,k,j) = peln_ad(i,k,j)+pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+&
&1,j)-peln(i,k,j))))
        pk2_ad(i,k+1) = pk2_ad(i,k+1)+pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pk2_ad(i,k) = pk2_ad(i,k)-pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pkz_ae(i,j,k) = 0.d0
      end do
    end do
    do k = ks+2, km+1
      do i = i1, i2
        pe_ae(i,k,j) = pe_ae(i,k,j)+peln_ad(i,k,j)*(1./pe(i,k,j))
        peln_ad(i,k,j) = 0.d0
      end do
    end do
    do i = i1, i2
      pk_ae(i,j,km+1) = pk_ae(i,j,km+1)+pk2_ad(i,km+1)
      pk2_ad(i,km+1) = 0.d0
    end do
    do k = ks+2, km
      do i = i1, i2
        pe_ae(i,k,j) = pe_ae(i,k,j)+pk2_ad(i,k)*akap*pe(i,k,j)**(akap-1)
        pk2_ad(i,k) = 0.d0
      end do
    end do
    pek = pk(i1,j,1)
    lnp = log(pe(i1,1,j))
    do i = i1, i2
      pk2(i,1) = pek
      peln(i,1,j) = lnp
    end do
    if (ks .ne. 0) then
      do k = 2, ks+1
        pek = pe(i1,k,j)**akap
        lnp = log(pe(i1,k,j))
        do i = i1, i2
          pk2(i,k) = pek
          peln(i,k,j) = lnp
        end do
      end do
      do k = 1, ks
        pek_ad = 0.d0
        do i = i1, i2
          pek_ad = pek_ad+pkz_ae(i,j,k)
          pkz_ae(i,j,k) = 0.d0
        end do
        peln_ad(i1,k+1,j) = peln_ad(i1,k+1,j)-pek_ad*((pk2(i1,k+1)-pk2(i1,k))*akap/(akap*(peln(i1,k+1,j)-peln(i1,k,j))*akap*&
&(peln(i1,k+1,j)-peln(i1,k,j))))
        peln_ad(i1,k,j) = peln_ad(i1,k,j)+pek_ad*((pk2(i1,k+1)-pk2(i1,k))*akap/(akap*(peln(i1,k+1,j)-peln(i1,k,j))*akap*(peln(i1,k+&
&1,j)-peln(i1,k,j))))
        pk2_ad(i1,k+1) = pk2_ad(i1,k+1)+pek_ad/(akap*(peln(i1,k+1,j)-peln(i1,k,j)))
        pk2_ad(i1,k) = pk2_ad(i1,k)-pek_ad/(akap*(peln(i1,k+1,j)-peln(i1,k,j)))
        pek_ad = 0.d0
      end do
      do k = 2, ks+1
        lnp_ad = 0.d0
        pek_ad = 0.d0
        do i = i1, i2
          lnp_ad = lnp_ad+peln_ad(i,k,j)
          peln_ad(i,k,j) = 0.d0
          pek_ad = pek_ad+pk2_ad(i,k)
          pk2_ad(i,k) = 0.d0
        end do
        pe_ae(i1,k,j) = pe_ae(i1,k,j)+lnp_ad*(1./pe(i1,k,j))
        lnp_ad = 0.d0
        pe_ae(i1,k,j) = pe_ae(i1,k,j)+pek_ad*akap*pe(i1,k,j)**(akap-1)
        pek_ad = 0.d0
      end do
    endif
    do i = i1, i2
      lnp_ad = lnp_ad+peln_ad(i,1,j)
      peln_ad(i,1,j) = 0.d0
      pek_ad = pek_ad+pk2_ad(i,1)
      pk2_ad(i,1) = 0.d0
    end do
    pe_ae(i1,1,j) = pe_ae(i1,1,j)+lnp_ad*(1./pe(i1,1,j))
    lnp_ad = 0.d0
    pk_ae(i1,j,1) = pk_ae(i1,j,1)+pek_ad
    pek_ad = 0.d0
  else
    pek = pk(i1,j,1)
    lnp = log(pe(i1,1,j))
    do i = i1, i2
      pk2(i,1) = pek
      peln(i,1,j) = lnp
    end do
    do k = 2, km+1
      do i = i1, i2
        peln(i,k,j) = log(pe(i,k,j))
        pk2(i,k) = pk(i,j,k)
      end do
    end do
    do k = 1, km
      do i = i1, i2
        peln_ad(i,k+1,j) = peln_ad(i,k+1,j)-pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*&
&(peln(i,k+1,j)-peln(i,k,j))))
        peln_ad(i,k,j) = peln_ad(i,k,j)+pkz_ae(i,j,k)*((pk2(i,k+1)-pk2(i,k))*akap/(akap*(peln(i,k+1,j)-peln(i,k,j))*akap*(peln(i,k+&
&1,j)-peln(i,k,j))))
        pk2_ad(i,k+1) = pk2_ad(i,k+1)+pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pk2_ad(i,k) = pk2_ad(i,k)-pkz_ae(i,j,k)/(akap*(peln(i,k+1,j)-peln(i,k,j)))
        pkz_ae(i,j,k) = 0.d0
      end do
    end do
    do k = 2, km+1
      do i = i1, i2
        pk_ae(i,j,k) = pk_ae(i,j,k)+pk2_ad(i,k)
        pk2_ad(i,k) = 0.d0
        pe_ae(i,k,j) = pe_ae(i,k,j)+peln_ad(i,k,j)*(1./pe(i,k,j))
        peln_ad(i,k,j) = 0.d0
      end do
    end do
    do i = i1, i2
      lnp_ad = lnp_ad+peln_ad(i,1,j)
      peln_ad(i,1,j) = 0.d0
      pek_ad = pek_ad+pk2_ad(i,1)
      pk2_ad(i,1) = 0.d0
    end do
    pe_ae(i1,1,j) = pe_ae(i1,1,j)+lnp_ad*(1./pe(i1,1,j))
    lnp_ad = 0.d0
    pk_ae(i1,j,1) = pk_ae(i1,j,1)+pek_ad
    pek_ad = 0.d0
  endif
#ifdef USE_OPENMP
!!oloso  !$omp critical  (adtaf)
!!oloso   pe_aeh(i1:i2,:,j) = pe_aeh(i1:i2,:,j)+pe_ae(i1:i2,:,j)
!!oloso  !$omp end critical (adtaf)
#endif /* ! USE_OPENMP */
end do
#ifdef USE_OPENMP
!!oloso pe_ae(:,:,:) = pe_aeh(:,:,:)
#endif /* ! USE_OPENMP */
#ifdef TIMING
call timing_off("pkez_ad1")
#endif

end subroutine pkez_ad


#endif /* SPMD */
