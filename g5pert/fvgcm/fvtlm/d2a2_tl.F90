#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine d2a2_tl( u, u_tm, v, v_tm, ua, ua_tl, va, va_tl, im, jm, jfirst, jlast, coslon, sinlon )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
real(kind=r8) :: coslon(im)
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u(im,jfirst:jlast)
real(kind=r8) :: u_tm(im,jfirst:jlast)
real(kind=r8) :: ua(im,jfirst:jlast)
real(kind=r8) :: ua_tl(im,jfirst:jlast)
real(kind=r8) :: v(im,jfirst:jlast)
real(kind=r8) :: v_tm(im,jfirst:jlast)
real(kind=r8) :: va(im,jfirst:jlast)
real(kind=r8) :: va_tl(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: imh
integer :: j
integer :: jn2g0
integer :: js2g0
real(kind=r8) :: un
real(kind=r8) :: un_tl
real(kind=r8) :: us
real(kind=r8) :: us_tl
real(kind=r8) :: vn
real(kind=r8) :: vn_tl
real(kind=r8) :: vs
real(kind=r8) :: vs_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
imh = im/2
jn2g0 = min(jlast,jm-1)
js2g0 = max(jfirst,2)
do j = js2g0, jlast-1
  do i = 1, im
    ua_tl(i,j) = 0.5*u_tm(i,j+1)+0.5*u_tm(i,j)
    ua(i,j) = 0.5*(u(i,j)+u(i,j+1))
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im-1
    va_tl(i,j) = 0.5*v_tm(i+1,j)+0.5*v_tm(i,j)
    va(i,j) = 0.5*(v(i,j)+v(i+1,j))
  end do
  va_tl(im,j) = 0.5*v_tm(im,j)+0.5*v_tm(1,j)
  va(im,j) = 0.5*(v(im,j)+v(1,j))
end do
if (jfirst .eq. 1) then
  us_tl = 0.d0
  us = 0.
  vs_tl = 0.d0
  vs = 0.
  do i = 1, imh
    us_tl = ua_tl(i+imh,2)*sinlon(i)-ua_tl(i,2)*sinlon(i)+us_tl-va_tl(i+imh,2)*coslon(i)+va_tl(i,2)*coslon(i)
    us = us+(ua(i+imh,2)-ua(i,2))*sinlon(i)+(va(i,2)-va(i+imh,2))*coslon(i)
    vs_tl = ua_tl(i+imh,2)*coslon(i)-ua_tl(i,2)*coslon(i)+va_tl(i+imh,2)*sinlon(i)-va_tl(i,2)*sinlon(i)+vs_tl
    vs = vs+(ua(i+imh,2)-ua(i,2))*coslon(i)+(va(i+imh,2)-va(i,2))*sinlon(i)
  end do
  us_tl = us_tl/dble(im)
  us = us/im
  vs_tl = vs_tl/dble(im)
  vs = vs/im
  do i = 1, imh
    ua_tl(i,1) = (-(us_tl*sinlon(i)))-vs_tl*coslon(i)
    ua(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    va_tl(i,1) = us_tl*coslon(i)-vs_tl*sinlon(i)
    va(i,1) = us*coslon(i)-vs*sinlon(i)
    ua_tl(i+imh,1) = -ua_tl(i,1)
    ua(i+imh,1) = -ua(i,1)
    va_tl(i+imh,1) = -va_tl(i,1)
    va(i+imh,1) = -va(i,1)
  end do
endif
if (jlast .eq. jm) then
  un_tl = 0.d0
  un = 0.
  vn_tl = 0.d0
  vn = 0.
  do i = 1, imh
    un_tl = ua_tl(i+imh,jm-1)*sinlon(i)-ua_tl(i,jm-1)*sinlon(i)+un_tl+va_tl(i+imh,jm-1)*coslon(i)-va_tl(i,jm-1)*coslon(i)
    un = un+(ua(i+imh,jm-1)-ua(i,jm-1))*sinlon(i)+(va(i+imh,jm-1)-va(i,jm-1))*coslon(i)
    vn_tl = (-(ua_tl(i+imh,jm-1)*coslon(i)))+ua_tl(i,jm-1)*coslon(i)+va_tl(i+imh,jm-1)*sinlon(i)-va_tl(i,jm-1)*sinlon(i)+vn_tl
    vn = vn+(ua(i,jm-1)-ua(i+imh,jm-1))*coslon(i)+(va(i+imh,jm-1)-va(i,jm-1))*sinlon(i)
  end do
  un_tl = un_tl/dble(im)
  un = un/im
  vn_tl = vn_tl/dble(im)
  vn = vn/im
  do i = 1, imh
    ua_tl(i,jm) = (-(un_tl*sinlon(i)))+vn_tl*coslon(i)
    ua(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    va_tl(i,jm) = (-(un_tl*coslon(i)))-vn_tl*sinlon(i)
    va(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    ua_tl(i+imh,jm) = -ua_tl(i,jm)
    ua(i+imh,jm) = -ua(i,jm)
    va_tl(i+imh,jm) = -va_tl(i,jm)
    va(i+imh,jm) = -va(i,jm)
  end do
endif

end subroutine d2a2_tl


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine d2a2_tl( u, u_tm, v, v_tm, ua, ua_tl, va, va_tl, im, jm, jfirst, jlast, coslon, sinlon )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
real(kind=r8) :: coslon(im)
integer :: jfirst
integer :: jlast
integer :: jm
real(kind=r8) :: sinlon(im)
real(kind=r8) :: u(im,jfirst:jlast)
real(kind=r8) :: u_tm(im,jfirst:jlast)
real(kind=r8) :: ua(im,jfirst:jlast)
real(kind=r8) :: ua_tl(im,jfirst:jlast)
real(kind=r8) :: v(im,jfirst:jlast)
real(kind=r8) :: v_tm(im,jfirst:jlast)
real(kind=r8) :: va(im,jfirst:jlast)
real(kind=r8) :: va_tl(im,jfirst:jlast)

!==============================================
! declare local variables
!==============================================
integer :: i
integer :: imh
integer :: j
integer :: jn2g0
integer :: js2g0
real(kind=r8) :: un
real(kind=r8) :: un_tl
real(kind=r8) :: us
real(kind=r8) :: us_tl
real(kind=r8) :: vn
real(kind=r8) :: vn_tl
real(kind=r8) :: vs
real(kind=r8) :: vs_tl

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
imh = im/2
jn2g0 = min(jlast,jm-1)
js2g0 = max(jfirst,2)
do j = js2g0, jlast-1
  do i = 1, im
    ua_tl(i,j) = 0.5*u_tm(i,j+1)+0.5*u_tm(i,j)
    ua(i,j) = 0.5*(u(i,j)+u(i,j+1))
  end do
end do
do j = js2g0, jn2g0
  do i = 1, im-1
    va_tl(i,j) = 0.5*v_tm(i+1,j)+0.5*v_tm(i,j)
    va(i,j) = 0.5*(v(i,j)+v(i+1,j))
  end do
  va_tl(im,j) = 0.5*v_tm(im,j)+0.5*v_tm(1,j)
  va(im,j) = 0.5*(v(im,j)+v(1,j))
end do
if (jfirst .eq. 1) then
  us_tl = 0.d0
  us = 0.
  vs_tl = 0.d0
  vs = 0.
  do i = 1, imh
    us_tl = ua_tl(i+imh,2)*sinlon(i)-ua_tl(i,2)*sinlon(i)+us_tl-va_tl(i+imh,2)*coslon(i)+va_tl(i,2)*coslon(i)
    us = us+(ua(i+imh,2)-ua(i,2))*sinlon(i)+(va(i,2)-va(i+imh,2))*coslon(i)
    vs_tl = ua_tl(i+imh,2)*coslon(i)-ua_tl(i,2)*coslon(i)+va_tl(i+imh,2)*sinlon(i)-va_tl(i,2)*sinlon(i)+vs_tl
    vs = vs+(ua(i+imh,2)-ua(i,2))*coslon(i)+(va(i+imh,2)-va(i,2))*sinlon(i)
  end do
  us_tl = us_tl/dble(im)
  us = us/im
  vs_tl = vs_tl/dble(im)
  vs = vs/im
  do i = 1, imh
    ua_tl(i,1) = (-(us_tl*sinlon(i)))-vs_tl*coslon(i)
    ua(i,1) = (-(us*sinlon(i)))-vs*coslon(i)
    va_tl(i,1) = us_tl*coslon(i)-vs_tl*sinlon(i)
    va(i,1) = us*coslon(i)-vs*sinlon(i)
    ua_tl(i+imh,1) = -ua_tl(i,1)
    ua(i+imh,1) = -ua(i,1)
    va_tl(i+imh,1) = -va_tl(i,1)
    va(i+imh,1) = -va(i,1)
  end do
endif
if (jlast .eq. jm) then
  un_tl = 0.d0
  un = 0.
  vn_tl = 0.d0
  vn = 0.
  do i = 1, imh
    un_tl = ua_tl(i+imh,jm-1)*sinlon(i)-ua_tl(i,jm-1)*sinlon(i)+un_tl+va_tl(i+imh,jm-1)*coslon(i)-va_tl(i,jm-1)*coslon(i)
    un = un+(ua(i+imh,jm-1)-ua(i,jm-1))*sinlon(i)+(va(i+imh,jm-1)-va(i,jm-1))*coslon(i)
    vn_tl = (-(ua_tl(i+imh,jm-1)*coslon(i)))+ua_tl(i,jm-1)*coslon(i)+va_tl(i+imh,jm-1)*sinlon(i)-va_tl(i,jm-1)*sinlon(i)+vn_tl
    vn = vn+(ua(i,jm-1)-ua(i+imh,jm-1))*coslon(i)+(va(i+imh,jm-1)-va(i,jm-1))*sinlon(i)
  end do
  un_tl = un_tl/dble(im)
  un = un/im
  vn_tl = vn_tl/dble(im)
  vn = vn/im
  do i = 1, imh
    ua_tl(i,jm) = (-(un_tl*sinlon(i)))+vn_tl*coslon(i)
    ua(i,jm) = (-(un*sinlon(i)))+vn*coslon(i)
    va_tl(i,jm) = (-(un_tl*coslon(i)))-vn_tl*sinlon(i)
    va(i,jm) = (-(un*coslon(i)))-vn*sinlon(i)
    ua_tl(i+imh,jm) = -ua_tl(i,jm)
    ua(i+imh,jm) = -ua(i,jm)
    va_tl(i+imh,jm) = -va_tl(i,jm)
    va(i+imh,jm) = -va(i,jm)
  end do
endif

end subroutine d2a2_tl


#endif /* SPMD */
