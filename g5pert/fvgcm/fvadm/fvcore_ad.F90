#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fvcore_do_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision, only : r8

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: dynpkg_1_fvcore_do
real(kind=r8), allocatable :: dynpkg_1_pe_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_pk_2h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_ps_5h(:,:,:)
real(kind=r8), allocatable :: dynpkg_1_pt_6h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_q_3h(:,:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_te0_1h(:)
real(kind=r8), allocatable :: dynpkg_n2_cx_3h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_cy_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_dp0_1h(:,:,:,:)
integer :: dynpkg_n2_fvcore_do
real(kind=r8), allocatable :: dynpkg_n2_mfx_5h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_mfy_6h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_q_2h(:,:,:,:,:)

end module     fvcore_do_ad_store


module     fvcore_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use fvcore

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine fvcore_do_ad( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, ps_ae, pe, pe_ae, delp, delp_ae, u, u_ae, v, v_ae, pt, &
&pt_ae, q, q_ae, pk, pk_ae, pkz, pkz_ae, phis, ptop, om, cp, rg, ae, iord, jord, kord, umax, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
#ifdef TIMING
use timingmodule
#endif
use mapz_module_ad, only : te_map_ad
use fvcore_do_ad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_pk_2h,dynpkg_1_ps_5h,dynpkg_1_pt_6h,dynpkg_1_q_3h,&
&dynpkg_1_te0_1h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,&
&dynpkg_n2_q_2h
use cd_core_ad, only : cd_core_do_ad
use benergy_ad, only : benergy_do_ad

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical, intent(in) :: convt
real(kind=r8), intent(in) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: delp_ae(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(in) :: om
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(inout) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8), intent(out) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: pkz_ae(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: ps_ae(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(inout) :: pt_ae(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: q_ae(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(in) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(inout) :: u_ae(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8), intent(inout) :: v_ae(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cx_ad(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: cy_ad(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: delpf_ad(:,:,:)
real(kind=r8) :: delph(im,jfirst:jlast,km)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dp0_ad(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dpth_ad(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
real(kind=r8), allocatable :: dwzh_ad(:,:,:)
logical :: fill
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfx_ad(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
real(kind=r8), allocatable :: mfy_ad(:,:,:)
integer :: n
real(kind=r8) :: peh(im,km+1,jfirst:jlast)
real(kind=r8) :: pelnh_ad(im,1+km,1+jlast-jfirst)
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8), allocatable :: pkch_ad(:,:,:)
real(kind=r8) :: pkh(im,jfirst:jlast,km+1)
real(kind=r8) :: pkzh(im,jfirst:jlast,km)
real(kind=r8) :: pth(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: te0
real(kind=r8) :: te0_ad
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: uch_ad(:,:,:)
real(kind=r8) :: uh(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: vch_ad(:,:,:)
real(kind=r8) :: vh(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: workah_ad(:,:,:)
real(kind=r8), allocatable :: workai_ad(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)
real(kind=r8), allocatable :: wzh_ad(:,:,:)

!==============================================
! declare data
!==============================================
data fill/ .true. /

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
vh(:,:,:) = v(:,:,:)
uh(:,:,:) = u(:,:,:)
pth(:,:,:) = pt(:,:,:)
pkzh(:,:,:) = pkz(:,:,:)
pkh(:,:,:) = pk(:,:,:)
peh(:,:,:) = pe(:,:,:)
delph(:,:,:) = delp(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
pelnh_ad(:,:,:) = 0.
te0_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
te0 = dynpkg_1_te0_1h(fvcore_tape_rec+1)
allocate( delpf_ad(im,jfirst-ng_d:jlast+ng_d,km) )
delpf_ad = 0.
allocate( dp0_ad(im,jfirst:jlast,km) )
dp0_ad = 0.
allocate( cx_ad(im,jfirst-ng_d:jlast+ng_d,km) )
cx_ad = 0.
allocate( cy_ad(im,jfirst:jlast+1,km) )
cy_ad = 0.
allocate( mfx_ad(im,jfirst:jlast,km) )
mfx_ad = 0.
allocate( mfy_ad(im,jfirst:jlast+1,km) )
mfy_ad = 0.
if (km .gt. 1) then
  pk = dynpkg_1_pk_2h(:,:,:,fvcore_tape_rec+1)
  q = dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1)
  pe = dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1)
  ps = dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1)
  pt = dynpkg_1_pt_6h(:,:,:,fvcore_tape_rec+1)
  te_map_tape_rec = fvcore_tape_rec
#ifdef TIMING
  call adtiming_off( 'TE_MAP' )
#endif
  call te_map_ad( consv,convt,ps,ps_ae,pe,pe_ae,delp,delp_ae,pkz,pkz_ae,pk,pk_ae,im,jm,km,nx,jfirst,jlast,nq,u,u_ae,v,v_ae,pt,&
&pt_ae,q,q_ae,phis,cp,cappa,kord,peln,pelnh_ad,te0,te0_ad,ng_d,ng_s,te_map_tape_rec )
#ifdef TIMING
  call adtiming_on( 'TE_MAP' )
#endif
endif
do n = n2, 1, -1
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  if (nq .ne. 0) then
    dp0 = dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1)
    q = dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1)
    cx = dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1)
    cy = dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1)
    mfx = dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1)
    mfy = dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1)
#ifdef TIMING
    call adtiming_off( 'TRAC2D' )
#endif
    allocate( workah_ad(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    workah_ad(:,:,:) = 0.
    call trac2d_ad( dp0,dp0_ad,q,q_ae,nq,cx,cx_ad,cy,cy_ad,mfx,mfx_ad,mfy,mfy_ad,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,&
&jm,km,jfirst,jlast,pkz,pkz_ae,worka,workah_ad )
    deallocate( workah_ad )
#ifdef TIMING
    call adtiming_on( 'TRAC2D' )
#endif
  endif
  do it = nsplit, 1, -1
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
#ifdef TIMING
    call adtiming_off( 'CD_CORE' )
#endif
    allocate( wzh_ad(1:size(wz,1),1:size(wz,2),1:size(wz,3)) )
    wzh_ad(:,:,:) = 0.
    allocate( pkch_ad(1:size(pkc,1),1:size(pkc,2),1:size(pkc,3)) )
    pkch_ad(:,:,:) = 0.
    allocate( dwzh_ad(1:size(dwz,1),1:size(dwz,2),1:size(dwz,3)) )
    dwzh_ad(:,:,:) = 0.
    allocate( workai_ad(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    workai_ad(:,:,:) = 0.
    allocate( dpth_ad(1:size(dpt,1),1:size(dpt,2),1:size(dpt,3)) )
    dpth_ad(:,:,:) = 0.
    allocate( vch_ad(1:size(vc,1),1:size(vc,2),1:size(vc,3)) )
    vch_ad(:,:,:) = 0.
    allocate( uch_ad(1:size(uc,1),1:size(uc,2),1:size(uc,3)) )
    uch_ad(:,:,:) = 0.
    call cd_core_do_ad( im,jm,km,nq,nx,jfirst,jlast,u,u_ae,v,v_ae,pt,pt_ae,delp,delp_ae,pe_ae,pk_ae,ns,ptop,rcap,cp,cappa,icd,jcd,&
&iord,jord,ng_c,ng_d,ng_s,ipe,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx_ad,cy_ad,mfx_ad,mfy_ad,delpf,delpf_ad,uc,uch_ad,vc,&
&vch_ad,pkz,pkz_ae,dpt,dpth_ad,worka,workai_ad,dwz,dwzh_ad,pkc,pkch_ad,wz,wzh_ad )
    deallocate( uch_ad )
    deallocate( vch_ad )
    deallocate( dpth_ad )
    deallocate( workai_ad )
    deallocate( dwzh_ad )
    deallocate( pkch_ad )
    deallocate( wzh_ad )
#ifdef TIMING
    call adtiming_on( 'CD_CORE' )
#endif
  end do
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do shared(cx_ad,cy_ad,delp_ae,dp0_ad,im,jfirst,jlast,km,mfx_ad,mfy_ad) private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          mfy_ad(i,j,k) = 0.
          mfx_ad(i,j,k) = 0.
          cy_ad(i,j,k) = 0.
          cx_ad(i,j,k) = 0.
          delp_ae(i,j,k) = delp_ae(i,j,k)+dp0_ad(i,j,k)
          dp0_ad(i,j,k) = 0.
        end do
      end do
    end do
  endif
end do
delp(:,:,:) = delph(:,:,:)
pe(:,:,:) = peh(:,:,:)
pk(:,:,:) = pkh(:,:,:)
pkz(:,:,:) = pkzh(:,:,:)
pt(:,:,:) = pth(:,:,:)
u(:,:,:) = uh(:,:,:)
v(:,:,:) = vh(:,:,:)
if (km .gt. 1) then
  if (consv) then
#ifdef TIMING
    call adtiming_off( 'BENERGY' )
#endif
    call benergy_do_ad( im,jm,km,u,u_ae,v,v_ae,pt,pt_ae,delp,delp_ae,pe,pe_ae,pk,pk_ae,pkz,pkz_ae,phis,ng_d,ng_s,cp,te0_ad,mfx,&
&mfx_ad,dp0,dp0_ad,jfirst,jlast )
#ifdef TIMING
    call adtiming_on( 'BENERGY' )
#endif
  endif
endif
deallocate( delpf_ad )
deallocate( cy_ad )
deallocate( cx_ad )
deallocate( mfy_ad )
deallocate( mfx_ad )
deallocate( dp0_ad )

!----------------------------------------------
! DEALLOCATE STATEMENTS
!----------------------------------------------
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
deallocate( uc )
deallocate( vc )
deallocate( dpt )
deallocate( pkc )
deallocate( dwz )
deallocate( wz )
deallocate( worka )

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine fvcore_do_ad


subroutine fvcore_domd( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, pe, delp, u, v, pt, q, pk, pkz, phis, ns0, ndt, ptop, &
&om, cp, rg, ae, iord, jord, kord, umax, omga, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
#ifdef TIMING
use timingmodule
#endif
use mapz_module_ad, only : te_mapmd
use fvcore_do_ad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_pk_2h,dynpkg_1_ps_5h,dynpkg_1_pt_6h,dynpkg_1_q_3h,&
&dynpkg_1_te0_1h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,&
&dynpkg_n2_q_2h
use cd_core_ad, only : cd_core_domd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical, intent(in) :: convt
real(kind=r8), intent(in) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer :: ndt
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
integer :: ns0
real(kind=r8), intent(in) :: om
real(kind=r8) :: omga(im,km,jfirst:jlast)
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(out) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(in) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
logical :: fill
logical :: filter
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
integer :: n
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8) :: te0
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)

!==============================================
! declare data
!==============================================
data filter/ .true. /
data fill/ .true. /

!**********************************************
! executable statements of routine
!**********************************************
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
delpf = 0.
te0 = 0.
if (km .gt. 1) then
  if (consv) then
    call benergy_do( im,jm,km,u,v,pt,delp,pe,pk,pkz,phis,ng_d,ng_s,cp,te0,mfx,dp0,jfirst,jlast )
  endif
endif
if ( .not. allocated(dynpkg_1_te0_1h)) then
  allocate( dynpkg_1_te0_1h(dynpkg_1_fvcore_do) )
endif
dynpkg_1_te0_1h(fvcore_tape_rec+1) = te0
do n = 1, n2
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          dp0(i,j,k) = delp(i,j,k)
          cx(i,j,k) = 0.
          cy(i,j,k) = 0.
          mfx(i,j,k) = 0.
          mfy(i,j,k) = 0.
        end do
      end do
    end do
  endif
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  do it = 1, nsplit
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
    call cd_core_domd( im,jm,km,nq,nx,jfirst,jlast,u,v,pt,delp,pe,pk,ns,dt,ptop,umax,fill,filter,acap,ae,rcap,cp,cappa,icd,jcd,&
&iord,jord,ng_c,ng_d,ng_s,ipe,om,phis,sinp,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx,cy,mfx,mfy,delpf,uc,vc,pkz,dpt,worka,&
&dwz,pkc,wz )
  end do
  if (nq .ne. 0) then
    if ( .not. allocated(dynpkg_n2_dp0_1h)) then
      allocate( dynpkg_n2_dp0_1h(1:size(dp0,1),1:size(dp0,2),1:size(dp0,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1) = dp0
    if ( .not. allocated(dynpkg_n2_q_2h)) then
      allocate( dynpkg_n2_q_2h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1) = q
    if ( .not. allocated(dynpkg_n2_cx_3h)) then
      allocate( dynpkg_n2_cx_3h(1:size(cx,1),1:size(cx,2),1:size(cx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1) = cx
    if ( .not. allocated(dynpkg_n2_cy_4h)) then
      allocate( dynpkg_n2_cy_4h(1:size(cy,1),1:size(cy,2),1:size(cy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1) = cy
    if ( .not. allocated(dynpkg_n2_mfx_5h)) then
      allocate( dynpkg_n2_mfx_5h(1:size(mfx,1),1:size(mfx,2),1:size(mfx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1) = mfx
    if ( .not. allocated(dynpkg_n2_mfy_6h)) then
      allocate( dynpkg_n2_mfy_6h(1:size(mfy,1),1:size(mfy,2),1:size(mfy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1) = mfy
    call trac2d( dp0,q,nq,cx,cy,mfx,mfy,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,jm,km,jfirst,jlast,pkz,worka,&
&cd_tape_rec_n )
  endif
end do
if (km .gt. 1) then
  if ( .not. allocated(dynpkg_1_pk_2h)) then
    allocate( dynpkg_1_pk_2h(1:im,1:1+jlast-jfirst,1:1+km,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pk_2h(:,:,:,fvcore_tape_rec+1) = pk
  if ( .not. allocated(dynpkg_1_q_3h)) then
    allocate( dynpkg_1_q_3h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1) = q
  if ( .not. allocated(dynpkg_1_pe_4h)) then
    allocate( dynpkg_1_pe_4h(1:im,1:1+km,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1) = pe
  if ( .not. allocated(dynpkg_1_ps_5h)) then
    allocate( dynpkg_1_ps_5h(1:im,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1) = ps
  if ( .not. allocated(dynpkg_1_pt_6h)) then
    allocate( dynpkg_1_pt_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pt_6h(:,:,:,fvcore_tape_rec+1) = pt
  te_map_tape_rec = fvcore_tape_rec
  call te_mapmd( consv,convt,ps,omga,pe,delp,pkz,pk,ndt,im,jm,km,nx,jfirst,jlast,nq,u,v,pt,q,phis,cp,cappa,kord,peln,te0,ng_d,ng_s,&
&te_map_tape_rec )
endif
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
end subroutine fvcore_domd


end module     fvcore_ad


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     fvcore_do_ad_store
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision, only : r8

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare local variables
!==============================================
integer :: dynpkg_1_fvcore_do
real(kind=r8), allocatable :: dynpkg_1_pe_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_pk_2h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_ps_5h(:,:,:)
real(kind=r8), allocatable :: dynpkg_1_pt_6h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_q_3h(:,:,:,:,:)
real(kind=r8), allocatable :: dynpkg_1_te0_1h(:)
real(kind=r8), allocatable :: dynpkg_n2_cx_3h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_cy_4h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_dp0_1h(:,:,:,:)
integer :: dynpkg_n2_fvcore_do
real(kind=r8), allocatable :: dynpkg_n2_mfx_5h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_mfy_6h(:,:,:,:)
real(kind=r8), allocatable :: dynpkg_n2_q_2h(:,:,:,:,:)

end module     fvcore_do_ad_store


module     fvcore_ad
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use precision
use fvcore

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine fvcore_do_ad( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, ps_ae, pe, pe_ae, delp, delp_ae, u, u_ae, v, v_ae, pt, &
&pt_ae, q, q_ae, pk, pk_ae, pkz, pkz_ae, phis, ptop, om, cp, rg, ae, iord, jord, kord, umax, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
#ifdef TIMING
use timingmodule
#endif
use mapz_module_ad, only : te_map_ad
use fvcore_do_ad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_pk_2h,dynpkg_1_ps_5h,dynpkg_1_pt_6h,dynpkg_1_q_3h,&
&dynpkg_1_te0_1h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,&
&dynpkg_n2_q_2h
use cd_core_ad, only : cd_core_do_ad
use benergy_ad, only : benergy_do_ad

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical, intent(in) :: convt
real(kind=r8), intent(in) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: delp_ae(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
real(kind=r8), intent(in) :: om
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(inout) :: pe_ae(im,km+1,jfirst:jlast)
real(kind=r8), intent(out) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pk_ae(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: pkz_ae(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: ps_ae(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(inout) :: pt_ae(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(inout) :: q_ae(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(in) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(inout) :: u_ae(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8), intent(inout) :: v_ae(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cx_ad(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: cy_ad(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: delpf_ad(:,:,:)
real(kind=r8) :: delph(im,jfirst:jlast,km)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dp0_ad(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dpth_ad(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
real(kind=r8), allocatable :: dwzh_ad(:,:,:)
logical :: fill
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfx_ad(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
real(kind=r8), allocatable :: mfy_ad(:,:,:)
integer :: n
real(kind=r8) :: peh(im,km+1,jfirst:jlast)
real(kind=r8) :: pelnh_ad(im,1+km,1+jlast-jfirst)
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8), allocatable :: pkch_ad(:,:,:)
real(kind=r8) :: pkh(im,jfirst:jlast,km+1)
real(kind=r8) :: pkzh(im,jfirst:jlast,km)
real(kind=r8) :: pth(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8) :: te0
real(kind=r8) :: te0_ad
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: uch_ad(:,:,:)
real(kind=r8) :: uh(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: vch_ad(:,:,:)
real(kind=r8) :: vh(im,jfirst-ng_s:jlast+ng_d,km)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: workah_ad(:,:,:)
real(kind=r8), allocatable :: workai_ad(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)
real(kind=r8), allocatable :: wzh_ad(:,:,:)

!==============================================
! declare data
!==============================================
data fill/ .true. /

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
vh(:,:,:) = v(:,:,:)
uh(:,:,:) = u(:,:,:)
pth(:,:,:) = pt(:,:,:)
pkzh(:,:,:) = pkz(:,:,:)
pkh(:,:,:) = pk(:,:,:)
peh(:,:,:) = pe(:,:,:)
delph(:,:,:) = delp(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
pelnh_ad(:,:,:) = 0.
te0_ad = 0.d0

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
te0 = dynpkg_1_te0_1h(fvcore_tape_rec+1)
allocate( delpf_ad(im,jfirst-ng_d:jlast+ng_d,km) )
delpf_ad = 0.
allocate( dp0_ad(im,jfirst:jlast,km) )
dp0_ad = 0.
allocate( cx_ad(im,jfirst-ng_d:jlast+ng_d,km) )
cx_ad = 0.
allocate( cy_ad(im,jfirst:jlast+1,km) )
cy_ad = 0.
allocate( mfx_ad(im,jfirst:jlast,km) )
mfx_ad = 0.
allocate( mfy_ad(im,jfirst:jlast+1,km) )
mfy_ad = 0.
if (km .gt. 1) then
  pk = dynpkg_1_pk_2h(:,:,:,fvcore_tape_rec+1)
  q = dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1)
  pe = dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1)
  ps = dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1)
  pt = dynpkg_1_pt_6h(:,:,:,fvcore_tape_rec+1)
  te_map_tape_rec = fvcore_tape_rec
#ifdef TIMING
  call adtiming_off( 'TE_MAP' )
#endif
  call te_map_ad( consv,convt,ps,ps_ae,pe,pe_ae,delp,delp_ae,pkz,pkz_ae,pk,pk_ae,im,jm,km,nx,jfirst,jlast,nq,u,u_ae,v,v_ae,pt,&
&pt_ae,q,q_ae,phis,cp,cappa,kord,peln,pelnh_ad,te0,te0_ad,ng_d,ng_s,te_map_tape_rec )
#ifdef TIMING
  call adtiming_on( 'TE_MAP' )
#endif
endif
do n = n2, 1, -1
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  if (nq .ne. 0) then
    dp0 = dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1)
    q = dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1)
    cx = dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1)
    cy = dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1)
    mfx = dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1)
    mfy = dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1)
#ifdef TIMING
    call adtiming_off( 'TRAC2D' )
#endif
    allocate( workah_ad(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    workah_ad(:,:,:) = 0.
    call trac2d_ad( dp0,dp0_ad,q,q_ae,nq,cx,cx_ad,cy,cy_ad,mfx,mfx_ad,mfy,mfy_ad,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,&
&jm,km,jfirst,jlast,pkz,pkz_ae,worka,workah_ad )
    deallocate( workah_ad )
#ifdef TIMING
    call adtiming_on( 'TRAC2D' )
#endif
  endif
  do it = nsplit, 1, -1
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
#ifdef TIMING
    call adtiming_off( 'CD_CORE' )
#endif
    allocate( wzh_ad(1:size(wz,1),1:size(wz,2),1:size(wz,3)) )
    wzh_ad(:,:,:) = 0.
    allocate( pkch_ad(1:size(pkc,1),1:size(pkc,2),1:size(pkc,3)) )
    pkch_ad(:,:,:) = 0.
    allocate( dwzh_ad(1:size(dwz,1),1:size(dwz,2),1:size(dwz,3)) )
    dwzh_ad(:,:,:) = 0.
    allocate( workai_ad(1:size(worka,1),1:size(worka,2),1:size(worka,3)) )
    workai_ad(:,:,:) = 0.
    allocate( dpth_ad(1:size(dpt,1),1:size(dpt,2),1:size(dpt,3)) )
    dpth_ad(:,:,:) = 0.
    allocate( vch_ad(1:size(vc,1),1:size(vc,2),1:size(vc,3)) )
    vch_ad(:,:,:) = 0.
    allocate( uch_ad(1:size(uc,1),1:size(uc,2),1:size(uc,3)) )
    uch_ad(:,:,:) = 0.
    call cd_core_do_ad( im,jm,km,nq,nx,jfirst,jlast,u,u_ae,v,v_ae,pt,pt_ae,delp,delp_ae,pe_ae,pk_ae,ns,ptop,rcap,cp,cappa,icd,jcd,&
&iord,jord,ng_c,ng_d,ng_s,ipe,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx_ad,cy_ad,mfx_ad,mfy_ad,delpf,delpf_ad,uc,uch_ad,vc,&
&vch_ad,pkz,pkz_ae,dpt,dpth_ad,worka,workai_ad,dwz,dwzh_ad,pkc,pkch_ad,wz,wzh_ad )
    deallocate( uch_ad )
    deallocate( vch_ad )
    deallocate( dpth_ad )
    deallocate( workai_ad )
    deallocate( dwzh_ad )
    deallocate( pkch_ad )
    deallocate( wzh_ad )
#ifdef TIMING
    call adtiming_on( 'CD_CORE' )
#endif
  end do
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do shared(cx_ad,cy_ad,delp_ae,dp0_ad,im,jfirst,jlast,km,mfx_ad,mfy_ad) private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          mfy_ad(i,j,k) = 0.
          mfx_ad(i,j,k) = 0.
          cy_ad(i,j,k) = 0.
          cx_ad(i,j,k) = 0.
          delp_ae(i,j,k) = delp_ae(i,j,k)+dp0_ad(i,j,k)
          dp0_ad(i,j,k) = 0.
        end do
      end do
    end do
  endif
end do
delp(:,:,:) = delph(:,:,:)
pe(:,:,:) = peh(:,:,:)
pk(:,:,:) = pkh(:,:,:)
pkz(:,:,:) = pkzh(:,:,:)
pt(:,:,:) = pth(:,:,:)
u(:,:,:) = uh(:,:,:)
v(:,:,:) = vh(:,:,:)
if (km .gt. 1) then
  if (consv) then
#ifdef TIMING
    call adtiming_off( 'BENERGY' )
#endif
    call benergy_do_ad( im,jm,km,u,u_ae,v,v_ae,pt,pt_ae,delp,delp_ae,pe,pe_ae,pk,pk_ae,pkz,pkz_ae,phis,ng_d,ng_s,cp,te0_ad,mfx,&
&mfx_ad,dp0,dp0_ad,jfirst,jlast )
#ifdef TIMING
    call adtiming_on( 'BENERGY' )
#endif
  endif
endif
deallocate( delpf_ad )
deallocate( cy_ad )
deallocate( cx_ad )
deallocate( mfy_ad )
deallocate( mfx_ad )
deallocate( dp0_ad )

!----------------------------------------------
! DEALLOCATE STATEMENTS
!----------------------------------------------
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
deallocate( uc )
deallocate( vc )
deallocate( dpt )
deallocate( pkc )
deallocate( dwz )
deallocate( wz )
deallocate( worka )

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

end subroutine fvcore_do_ad


subroutine fvcore_domd( im, jm, km, nc, jfirst, jlast, ng_d, ng_s, nq, ps, pe, delp, u, v, pt, q, pk, pkz, phis, ns0, ndt, ptop, &
&om, cp, rg, ae, iord, jord, kord, umax, omga, peln, consv, convt )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use mapz_module, only : te_map
use cd_core, only : cd_core_do, cd_core_initialize
use benergy, only : benergy_do
use cd_core, only : cd_core_tape_rec
use precision
#ifdef TIMING
use timingmodule
#endif
use mapz_module_ad, only : te_mapmd
use fvcore_do_ad_store, only : dynpkg_1_fvcore_do,dynpkg_1_pe_4h,dynpkg_1_pk_2h,dynpkg_1_ps_5h,dynpkg_1_pt_6h,dynpkg_1_q_3h,&
&dynpkg_1_te0_1h,dynpkg_n2_cx_3h,dynpkg_n2_cy_4h,dynpkg_n2_dp0_1h,dynpkg_n2_fvcore_do,dynpkg_n2_mfx_5h,dynpkg_n2_mfy_6h,&
&dynpkg_n2_q_2h
use cd_core_ad, only : cd_core_domd

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real(kind=r8), intent(in) :: ae
logical, intent(in) :: consv
logical, intent(in) :: convt
real(kind=r8), intent(in) :: cp
integer, intent(in) :: im
integer, intent(in) :: jfirst
integer, intent(in) :: jlast
integer, intent(in) :: km
real(kind=r8), intent(inout) :: delp(im,jfirst:jlast,km)
integer, intent(in) :: iord
integer, intent(in) :: jm
integer, intent(in) :: jord
integer, intent(in) :: kord
integer, intent(in) :: nc
integer :: ndt
integer, intent(in) :: ng_d
integer, intent(in) :: ng_s
integer, intent(in) :: nq
integer :: ns0
real(kind=r8), intent(in) :: om
real(kind=r8) :: omga(im,km,jfirst:jlast)
real(kind=r8), intent(inout) :: pe(im,km+1,jfirst:jlast)
real(kind=r8), intent(out) :: peln(im,km+1,jfirst:jlast)
real(kind=r8), intent(in) :: phis(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pk(im,jfirst:jlast,km+1)
real(kind=r8), intent(inout) :: pkz(im,jfirst:jlast,km)
real(kind=r8), intent(inout) :: ps(im,jfirst:jlast)
real(kind=r8), intent(inout) :: pt(im,jfirst-ng_d:jlast+ng_d,km)
real(kind=r8), intent(in) :: ptop
real(kind=r8), intent(inout) :: q(im,jfirst-ng_d:jlast+ng_d,km,nc)
real(kind=r8), intent(in) :: rg
real(kind=r8), intent(inout) :: u(im,jfirst-ng_d:jlast+ng_s,km)
real(kind=r8), intent(in) :: umax
real(kind=r8), intent(inout) :: v(im,jfirst-ng_s:jlast+ng_d,km)

!==============================================
! declare local variables
!==============================================
real(kind=r8) :: cappa
integer :: cd_tape_rec_n
real(kind=r8), allocatable :: cx(:,:,:)
real(kind=r8), allocatable :: cy(:,:,:)
real(kind=r8), allocatable :: delpf(:,:,:)
real(kind=r8), allocatable :: dp0(:,:,:)
real(kind=r8), allocatable :: dpt(:,:,:)
real(kind=r8), allocatable :: dwz(:,:,:)
logical :: fill
logical :: filter
integer :: i
integer :: icd
integer :: ipe
integer :: it
integer :: j
integer :: jcd
integer :: k
real(kind=r8), allocatable :: mfx(:,:,:)
real(kind=r8), allocatable :: mfy(:,:,:)
integer :: n
real(kind=r8), allocatable :: pkc(:,:,:)
real(kind=r8) :: te0
integer :: te_map_tape_rec
real(kind=r8), allocatable :: uc(:,:,:)
real(kind=r8), allocatable :: vc(:,:,:)
real(kind=r8), allocatable :: worka(:,:,:)
real(kind=r8), allocatable :: wz(:,:,:)

!==============================================
! declare data
!==============================================
data filter/ .true. /
data fill/ .true. /

!**********************************************
! executable statements of routine
!**********************************************
cappa = rg/cp
if (iord .le. 2) then
  icd = 1
else
  icd = -2
endif
if (jord .le. 2) then
  jcd = 1
else
  jcd = -2
endif
allocate( worka(im,jfirst:jlast,km) )
allocate( dp0(im,jfirst:jlast,km) )
allocate( mfx(im,jfirst:jlast,km) )
allocate( mfy(im,jfirst:jlast+1,km) )
allocate( cx(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( cy(im,jfirst:jlast+1,km) )
allocate( delpf(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( uc(im,jfirst-ng_d:jlast+ng_d,km) )
allocate( vc(im,jfirst-2:jlast+2,km) )
allocate( dpt(im,jfirst-1:jlast+1,km) )
allocate( dwz(im,jfirst-1:jlast,km+1) )
allocate( pkc(im,jfirst-1:jlast+1,km+1) )
allocate( wz(im,jfirst-1:jlast+1,km+1) )
delpf = 0.
te0 = 0.
if (km .gt. 1) then
  if (consv) then
    call benergy_do( im,jm,km,u,v,pt,delp,pe,pk,pkz,phis,ng_d,ng_s,cp,te0,mfx,dp0,jfirst,jlast )
  endif
endif
if ( .not. allocated(dynpkg_1_te0_1h)) then
  allocate( dynpkg_1_te0_1h(dynpkg_1_fvcore_do) )
endif
dynpkg_1_te0_1h(fvcore_tape_rec+1) = te0
do n = 1, n2
  cd_tape_rec_n = n-1+fvcore_tape_rec*n2
  if (nq .gt. 0) then
#ifdef USE_OPENMP
    !$omp parallel do private(i,j,k)
#endif /* ! USE_OPENMP */
    do k = 1, km
      do j = jfirst, jlast
        do i = 1, im
          dp0(i,j,k) = delp(i,j,k)
          cx(i,j,k) = 0.
          cy(i,j,k) = 0.
          mfx(i,j,k) = 0.
          mfy(i,j,k) = 0.
        end do
      end do
    end do
  endif
  call cd_core_initialize( im,jm,km,jfirst,jlast,ng_c,ng_d,ng_s,dt,ae,om,ptop,umax,sinp,cosp,cose,acosp,cappa )
  do it = 1, nsplit
    if (it .eq. nsplit .and. n .eq. n2) then
      ipe = 1
    else if (it .eq. 1 .and. n .eq. 1) then
      ipe = -1
    else
      ipe = 0
    endif
    cd_core_tape_rec = it-1+cd_tape_rec_n*nsplit
    call cd_core_domd( im,jm,km,nq,nx,jfirst,jlast,u,v,pt,delp,pe,pk,ns,dt,ptop,umax,fill,filter,acap,ae,rcap,cp,cappa,icd,jcd,&
&iord,jord,ng_c,ng_d,ng_s,ipe,om,phis,sinp,cosp,cose,acosp,sinlon,coslon,cosl5,sinl5,cx,cy,mfx,mfy,delpf,uc,vc,pkz,dpt,worka,&
&dwz,pkc,wz )
  end do
  if (nq .ne. 0) then
    if ( .not. allocated(dynpkg_n2_dp0_1h)) then
      allocate( dynpkg_n2_dp0_1h(1:size(dp0,1),1:size(dp0,2),1:size(dp0,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_dp0_1h(:,:,:,cd_tape_rec_n+1) = dp0
    if ( .not. allocated(dynpkg_n2_q_2h)) then
      allocate( dynpkg_n2_q_2h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_q_2h(:,:,:,:,cd_tape_rec_n+1) = q
    if ( .not. allocated(dynpkg_n2_cx_3h)) then
      allocate( dynpkg_n2_cx_3h(1:size(cx,1),1:size(cx,2),1:size(cx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cx_3h(:,:,:,cd_tape_rec_n+1) = cx
    if ( .not. allocated(dynpkg_n2_cy_4h)) then
      allocate( dynpkg_n2_cy_4h(1:size(cy,1),1:size(cy,2),1:size(cy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_cy_4h(:,:,:,cd_tape_rec_n+1) = cy
    if ( .not. allocated(dynpkg_n2_mfx_5h)) then
      allocate( dynpkg_n2_mfx_5h(1:size(mfx,1),1:size(mfx,2),1:size(mfx,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfx_5h(:,:,:,cd_tape_rec_n+1) = mfx
    if ( .not. allocated(dynpkg_n2_mfy_6h)) then
      allocate( dynpkg_n2_mfy_6h(1:size(mfy,1),1:size(mfy,2),1:size(mfy,3),dynpkg_n2_fvcore_do) )
    endif
    dynpkg_n2_mfy_6h(:,:,:,cd_tape_rec_n+1) = mfy
    call trac2d( dp0,q,nq,cx,cy,mfx,mfy,iord,jord,ng_d,sine,cosp,acosp,acap,rcap,fill,im,jm,km,jfirst,jlast,pkz,worka,&
&cd_tape_rec_n )
  endif
end do
if (km .gt. 1) then
  if ( .not. allocated(dynpkg_1_pk_2h)) then
    allocate( dynpkg_1_pk_2h(1:im,1:1+jlast-jfirst,1:1+km,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pk_2h(:,:,:,fvcore_tape_rec+1) = pk
  if ( .not. allocated(dynpkg_1_q_3h)) then
    allocate( dynpkg_1_q_3h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,1:nc,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_q_3h(:,:,:,:,fvcore_tape_rec+1) = q
  if ( .not. allocated(dynpkg_1_pe_4h)) then
    allocate( dynpkg_1_pe_4h(1:im,1:1+km,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pe_4h(:,:,:,fvcore_tape_rec+1) = pe
  if ( .not. allocated(dynpkg_1_ps_5h)) then
    allocate( dynpkg_1_ps_5h(1:im,1:1+jlast-jfirst,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_ps_5h(:,:,fvcore_tape_rec+1) = ps
  if ( .not. allocated(dynpkg_1_pt_6h)) then
    allocate( dynpkg_1_pt_6h(1:im,1:1+jlast+ng_d-(jfirst-ng_d),1:km,dynpkg_1_fvcore_do) )
  endif
  dynpkg_1_pt_6h(:,:,:,fvcore_tape_rec+1) = pt
  te_map_tape_rec = fvcore_tape_rec
  call te_mapmd( consv,convt,ps,omga,pe,delp,pkz,pk,ndt,im,jm,km,nx,jfirst,jlast,nq,u,v,pt,q,phis,cp,cappa,kord,peln,te0,ng_d,ng_s,&
&te_map_tape_rec )
endif
deallocate( mfy )
deallocate( mfx )
deallocate( cy )
deallocate( cx )
deallocate( dp0 )
deallocate( delpf )
end subroutine fvcore_domd


end module     fvcore_ad


#endif /* SPMD */
