#ifdef    SPMD
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine dry_adj_tl( im, km, rdt, pt, pt_tm, fu, fu_tl, fv, fv_tl, u, u_tm, v, v_tm, dp, dp_tl )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: km
real :: dp(im,km)
real :: dp_tl(im,km)
real :: fu(im,km)
real :: fu_tl(im,km)
real :: fv(im,km)
real :: fv_tl(im,km)
real :: pt(im,km)
real :: pt_tm(im,km)
real :: rdt
real :: u(im,km)
real :: u_tm(im,km)
real :: v(im,km)
real :: v_tm(im,km)

!==============================================
! declare local variables
!==============================================
real :: dp1
real :: dp1_tl
real :: dp2
real :: dp2_tl
integer :: i
integer :: k
integer :: klow
logical :: mixm
real :: ptm
real :: ptm_tl
real :: um
real :: um_tl
real :: ut(im,km)
real :: ut_tl(im,km)
real :: vm
real :: vm_tl
real :: vt(im,km)
real :: vt_tl(im,km)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
mixm =  .true. 
klow = max(km/16,1)
do k = 1, klow+3
  do i = 1, im
    ut_tl(i,k) = u_tm(i,k)
    ut(i,k) = u(i,k)
    vt_tl(i,k) = v_tm(i,k)
    vt(i,k) = v(i,k)
  end do
end do
do k = 1, klow
  do i = 1, im
    if (pt(i,k) .lt. pt(i,k+1)) then
      dp1_tl = dp_tl(i,k+1)+dp_tl(i,k)
      dp1 = dp(i,k)+dp(i,k+1)
      ptm_tl = dp_tl(i,k+1)*(pt(i,k+1)/dp1)+dp_tl(i,k)*(pt(i,k)/dp1)-dp1_tl*((pt(i,k)*dp(i,k)+pt(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&pt_tm(i,k+1)*(dp(i,k+1)/dp1)+pt_tm(i,k)*(dp(i,k)/dp1)
      ptm = (pt(i,k)*dp(i,k)+pt(i,k+1)*dp(i,k+1))/dp1
      pt_tm(i,k) = ptm_tl
      pt(i,k) = ptm
      pt_tm(i,k+1) = ptm_tl
      pt(i,k+1) = ptm
      if (mixm) then
        um_tl = dp_tl(i,k+1)*(u(i,k+1)/dp1)+dp_tl(i,k)*(u(i,k)/dp1)-dp1_tl*((u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/(dp1*dp1))+u_tm(i,&
&k+1)*(dp(i,k+1)/dp1)+u_tm(i,k)*(dp(i,k)/dp1)
        um = (u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/dp1
        u_tm(i,k) = um_tl
        u(i,k) = um
        u_tm(i,k+1) = um_tl
        u(i,k+1) = um
        vm_tl = dp_tl(i,k+1)*(v(i,k+1)/dp1)+dp_tl(i,k)*(v(i,k)/dp1)-dp1_tl*((v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/(dp1*dp1))+v_tm(i,&
&k+1)*(dp(i,k+1)/dp1)+v_tm(i,k)*(dp(i,k)/dp1)
        vm = (v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/dp1
        v_tm(i,k) = vm_tl
        v(i,k) = vm
        v_tm(i,k+1) = vm_tl
        v(i,k+1) = vm
      endif
      if (ptm .lt. pt(i,k+2)) then
        dp2_tl = dp_tl(i,k+2)+dp1_tl
        dp2 = dp1+dp(i,k+2)
        ptm_tl = dp_tl(i,k+2)*(pt(i,k+2)/dp2)+dp1_tl*(ptm/dp2)-dp2_tl*((ptm*dp1+pt(i,k+2)*dp(i,k+2))/(dp2*dp2))+pt_tm(i,k+2)*(dp(i,&
&k+2)/dp2)+ptm_tl*(dp1/dp2)
        ptm = (ptm*dp1+pt(i,k+2)*dp(i,k+2))/dp2
        pt_tm(i,k) = ptm_tl
        pt(i,k) = ptm
        pt_tm(i,k+1) = ptm_tl
        pt(i,k+1) = ptm
        pt_tm(i,k+2) = ptm_tl
        pt(i,k+2) = ptm
        if (mixm) then
          um_tl = dp_tl(i,k+1)*(u(i,k+1)/dp1)+dp_tl(i,k)*(u(i,k)/dp1)-dp1_tl*((u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&u_tm(i,k+1)*(dp(i,k+1)/dp1)+u_tm(i,k)*(dp(i,k)/dp1)
          um = (u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/dp1
          um_tl = dp_tl(i,k+2)*(u(i,k+2)/dp2)+dp1_tl*(um/dp2)-dp2_tl*((um*dp1+u(i,k+2)*dp(i,k+2))/(dp2*dp2))+u_tm(i,k+2)*(dp(i,k+2)&
&/dp2)+um_tl*(dp1/dp2)
          um = (um*dp1+u(i,k+2)*dp(i,k+2))/dp2
          u_tm(i,k) = um_tl
          u(i,k) = um
          u_tm(i,k+1) = um_tl
          u(i,k+1) = um
          u_tm(i,k+2) = um_tl
          u(i,k+2) = um
          vm_tl = dp_tl(i,k+1)*(v(i,k+1)/dp1)+dp_tl(i,k)*(v(i,k)/dp1)-dp1_tl*((v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&v_tm(i,k+1)*(dp(i,k+1)/dp1)+v_tm(i,k)*(dp(i,k)/dp1)
          vm = (v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/dp1
          vm_tl = dp_tl(i,k+2)*(v(i,k+2)/dp2)+dp1_tl*(vm/dp2)-dp2_tl*((vm*dp1+v(i,k+2)*dp(i,k+2))/(dp2*dp2))+v_tm(i,k+2)*(dp(i,k+2)&
&/dp2)+vm_tl*(dp1/dp2)
          vm = (vm*dp1+v(i,k+2)*dp(i,k+2))/dp2
          v_tm(i,k) = vm_tl
          v(i,k) = vm
          v_tm(i,k+1) = vm_tl
          v(i,k+1) = vm
          v_tm(i,k+2) = vm_tl
          v(i,k+2) = vm
        endif
        if (ptm .lt. pt(i,k+3)) then
          ptm_tl = dp_tl(i,k+3)*(pt(i,k+3)/(dp2+dp(i,k+3))-(ptm*dp2+pt(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+dp2_tl*&
&(ptm/(dp2+dp(i,k+3))-(ptm*dp2+pt(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+pt_tm(i,k+3)*(dp(i,k+3)/(dp2+dp(i,&
&k+3)))+ptm_tl*(dp2/(dp2+dp(i,k+3)))
          ptm = (ptm*dp2+pt(i,k+3)*dp(i,k+3))/(dp2+dp(i,k+3))
          pt_tm(i,k) = ptm_tl
          pt(i,k) = ptm
          pt_tm(i,k+1) = ptm_tl
          pt(i,k+1) = ptm
          pt_tm(i,k+2) = ptm_tl
          pt(i,k+2) = ptm
          pt_tm(i,k+3) = ptm_tl
          pt(i,k+3) = ptm
          if (mixm) then
            um_tl = dp_tl(i,k+1)*(u(i,k+1)/dp1)+dp_tl(i,k)*(u(i,k)/dp1)-dp1_tl*((u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&u_tm(i,k+1)*(dp(i,k+1)/dp1)+u_tm(i,k)*(dp(i,k)/dp1)
            um = (u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/dp1
            um_tl = dp_tl(i,k+2)*(u(i,k+2)/dp2)+dp1_tl*(um/dp2)-dp2_tl*((um*dp1+u(i,k+2)*dp(i,k+2))/(dp2*dp2))+u_tm(i,k+2)*(dp(i,k+&
&2)/dp2)+um_tl*(dp1/dp2)
            um = (um*dp1+u(i,k+2)*dp(i,k+2))/dp2
            um_tl = dp_tl(i,k+3)*(u(i,k+3)/(dp2+dp(i,k+3))-(um*dp2+u(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+dp2_tl*&
&(um/(dp2+dp(i,k+3))-(um*dp2+u(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+u_tm(i,k+3)*(dp(i,k+3)/(dp2+dp(i,k+&
&3)))+um_tl*(dp2/(dp2+dp(i,k+3)))
            um = (um*dp2+u(i,k+3)*dp(i,k+3))/(dp2+dp(i,k+3))
            u_tm(i,k) = um_tl
            u(i,k) = um
            u_tm(i,k+1) = um_tl
            u(i,k+1) = um
            u_tm(i,k+2) = um_tl
            u(i,k+2) = um
            u_tm(i,k+3) = um_tl
            u(i,k+3) = um
            vm_tl = dp_tl(i,k+1)*(v(i,k+1)/dp1)+dp_tl(i,k)*(v(i,k)/dp1)-dp1_tl*((v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&v_tm(i,k+1)*(dp(i,k+1)/dp1)+v_tm(i,k)*(dp(i,k)/dp1)
            vm = (v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/dp1
            vm_tl = dp_tl(i,k+2)*(v(i,k+2)/dp2)+dp1_tl*(vm/dp2)-dp2_tl*((vm*dp1+v(i,k+2)*dp(i,k+2))/(dp2*dp2))+v_tm(i,k+2)*(dp(i,k+&
&2)/dp2)+vm_tl*(dp1/dp2)
            vm = (vm*dp1+v(i,k+2)*dp(i,k+2))/dp2
            vm_tl = dp_tl(i,k+3)*(v(i,k+3)/(dp2+dp(i,k+3))-(vm*dp2+v(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+dp2_tl*&
&(vm/(dp2+dp(i,k+3))-(vm*dp2+v(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+v_tm(i,k+3)*(dp(i,k+3)/(dp2+dp(i,k+&
&3)))+vm_tl*(dp2/(dp2+dp(i,k+3)))
            vm = (vm*dp2+v(i,k+3)*dp(i,k+3))/(dp2+dp(i,k+3))
            v_tm(i,k) = vm_tl
            v(i,k) = vm
            v_tm(i,k+1) = vm_tl
            v(i,k+1) = vm
            v_tm(i,k+2) = vm_tl
            v(i,k+2) = vm
            v_tm(i,k+3) = vm_tl
            v(i,k+3) = vm
          endif
        endif
      endif
    endif
  end do
end do
if (mixm) then
  do k = 1, klow+3
    do i = 1, im
      fu_tl(i,k) = fu_tl(i,k)+u_tm(i,k)*rdt-ut_tl(i,k)*rdt
      fu(i,k) = fu(i,k)+(u(i,k)-ut(i,k))*rdt
      fv_tl(i,k) = fv_tl(i,k)+v_tm(i,k)*rdt-vt_tl(i,k)*rdt
      fv(i,k) = fv(i,k)+(v(i,k)-vt(i,k))*rdt
    end do
  end do
endif

end subroutine dry_adj_tl


#else  /* SPMD */
!                           DISCLAIMER
!
!   This file was generated by TAF version 1.6.1
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
subroutine dry_adj_tl( im, km, rdt, pt, pt_tm, fu, fu_tl, fv, fv_tl, u, u_tm, v, v_tm, dp, dp_tl )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.6.1   **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: im
integer :: km
real :: dp(im,km)
real :: dp_tl(im,km)
real :: fu(im,km)
real :: fu_tl(im,km)
real :: fv(im,km)
real :: fv_tl(im,km)
real :: pt(im,km)
real :: pt_tm(im,km)
real :: rdt
real :: u(im,km)
real :: u_tm(im,km)
real :: v(im,km)
real :: v_tm(im,km)

!==============================================
! declare local variables
!==============================================
real :: dp1
real :: dp1_tl
real :: dp2
real :: dp2_tl
integer :: i
integer :: k
integer :: klow
logical :: mixm
real :: ptm
real :: ptm_tl
real :: um
real :: um_tl
real :: ut(im,km)
real :: ut_tl(im,km)
real :: vm
real :: vm_tl
real :: vt(im,km)
real :: vt_tl(im,km)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
mixm =  .true. 
klow = max(km/16,1)
do k = 1, klow+3
  do i = 1, im
    ut_tl(i,k) = u_tm(i,k)
    ut(i,k) = u(i,k)
    vt_tl(i,k) = v_tm(i,k)
    vt(i,k) = v(i,k)
  end do
end do
do k = 1, klow
  do i = 1, im
    if (pt(i,k) .lt. pt(i,k+1)) then
      dp1_tl = dp_tl(i,k+1)+dp_tl(i,k)
      dp1 = dp(i,k)+dp(i,k+1)
      ptm_tl = dp_tl(i,k+1)*(pt(i,k+1)/dp1)+dp_tl(i,k)*(pt(i,k)/dp1)-dp1_tl*((pt(i,k)*dp(i,k)+pt(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&pt_tm(i,k+1)*(dp(i,k+1)/dp1)+pt_tm(i,k)*(dp(i,k)/dp1)
      ptm = (pt(i,k)*dp(i,k)+pt(i,k+1)*dp(i,k+1))/dp1
      pt_tm(i,k) = ptm_tl
      pt(i,k) = ptm
      pt_tm(i,k+1) = ptm_tl
      pt(i,k+1) = ptm
      if (mixm) then
        um_tl = dp_tl(i,k+1)*(u(i,k+1)/dp1)+dp_tl(i,k)*(u(i,k)/dp1)-dp1_tl*((u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/(dp1*dp1))+u_tm(i,&
&k+1)*(dp(i,k+1)/dp1)+u_tm(i,k)*(dp(i,k)/dp1)
        um = (u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/dp1
        u_tm(i,k) = um_tl
        u(i,k) = um
        u_tm(i,k+1) = um_tl
        u(i,k+1) = um
        vm_tl = dp_tl(i,k+1)*(v(i,k+1)/dp1)+dp_tl(i,k)*(v(i,k)/dp1)-dp1_tl*((v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/(dp1*dp1))+v_tm(i,&
&k+1)*(dp(i,k+1)/dp1)+v_tm(i,k)*(dp(i,k)/dp1)
        vm = (v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/dp1
        v_tm(i,k) = vm_tl
        v(i,k) = vm
        v_tm(i,k+1) = vm_tl
        v(i,k+1) = vm
      endif
      if (ptm .lt. pt(i,k+2)) then
        dp2_tl = dp_tl(i,k+2)+dp1_tl
        dp2 = dp1+dp(i,k+2)
        ptm_tl = dp_tl(i,k+2)*(pt(i,k+2)/dp2)+dp1_tl*(ptm/dp2)-dp2_tl*((ptm*dp1+pt(i,k+2)*dp(i,k+2))/(dp2*dp2))+pt_tm(i,k+2)*(dp(i,&
&k+2)/dp2)+ptm_tl*(dp1/dp2)
        ptm = (ptm*dp1+pt(i,k+2)*dp(i,k+2))/dp2
        pt_tm(i,k) = ptm_tl
        pt(i,k) = ptm
        pt_tm(i,k+1) = ptm_tl
        pt(i,k+1) = ptm
        pt_tm(i,k+2) = ptm_tl
        pt(i,k+2) = ptm
        if (mixm) then
          um_tl = dp_tl(i,k+1)*(u(i,k+1)/dp1)+dp_tl(i,k)*(u(i,k)/dp1)-dp1_tl*((u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&u_tm(i,k+1)*(dp(i,k+1)/dp1)+u_tm(i,k)*(dp(i,k)/dp1)
          um = (u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/dp1
          um_tl = dp_tl(i,k+2)*(u(i,k+2)/dp2)+dp1_tl*(um/dp2)-dp2_tl*((um*dp1+u(i,k+2)*dp(i,k+2))/(dp2*dp2))+u_tm(i,k+2)*(dp(i,k+2)&
&/dp2)+um_tl*(dp1/dp2)
          um = (um*dp1+u(i,k+2)*dp(i,k+2))/dp2
          u_tm(i,k) = um_tl
          u(i,k) = um
          u_tm(i,k+1) = um_tl
          u(i,k+1) = um
          u_tm(i,k+2) = um_tl
          u(i,k+2) = um
          vm_tl = dp_tl(i,k+1)*(v(i,k+1)/dp1)+dp_tl(i,k)*(v(i,k)/dp1)-dp1_tl*((v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&v_tm(i,k+1)*(dp(i,k+1)/dp1)+v_tm(i,k)*(dp(i,k)/dp1)
          vm = (v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/dp1
          vm_tl = dp_tl(i,k+2)*(v(i,k+2)/dp2)+dp1_tl*(vm/dp2)-dp2_tl*((vm*dp1+v(i,k+2)*dp(i,k+2))/(dp2*dp2))+v_tm(i,k+2)*(dp(i,k+2)&
&/dp2)+vm_tl*(dp1/dp2)
          vm = (vm*dp1+v(i,k+2)*dp(i,k+2))/dp2
          v_tm(i,k) = vm_tl
          v(i,k) = vm
          v_tm(i,k+1) = vm_tl
          v(i,k+1) = vm
          v_tm(i,k+2) = vm_tl
          v(i,k+2) = vm
        endif
        if (ptm .lt. pt(i,k+3)) then
          ptm_tl = dp_tl(i,k+3)*(pt(i,k+3)/(dp2+dp(i,k+3))-(ptm*dp2+pt(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+dp2_tl*&
&(ptm/(dp2+dp(i,k+3))-(ptm*dp2+pt(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+pt_tm(i,k+3)*(dp(i,k+3)/(dp2+dp(i,&
&k+3)))+ptm_tl*(dp2/(dp2+dp(i,k+3)))
          ptm = (ptm*dp2+pt(i,k+3)*dp(i,k+3))/(dp2+dp(i,k+3))
          pt_tm(i,k) = ptm_tl
          pt(i,k) = ptm
          pt_tm(i,k+1) = ptm_tl
          pt(i,k+1) = ptm
          pt_tm(i,k+2) = ptm_tl
          pt(i,k+2) = ptm
          pt_tm(i,k+3) = ptm_tl
          pt(i,k+3) = ptm
          if (mixm) then
            um_tl = dp_tl(i,k+1)*(u(i,k+1)/dp1)+dp_tl(i,k)*(u(i,k)/dp1)-dp1_tl*((u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&u_tm(i,k+1)*(dp(i,k+1)/dp1)+u_tm(i,k)*(dp(i,k)/dp1)
            um = (u(i,k)*dp(i,k)+u(i,k+1)*dp(i,k+1))/dp1
            um_tl = dp_tl(i,k+2)*(u(i,k+2)/dp2)+dp1_tl*(um/dp2)-dp2_tl*((um*dp1+u(i,k+2)*dp(i,k+2))/(dp2*dp2))+u_tm(i,k+2)*(dp(i,k+&
&2)/dp2)+um_tl*(dp1/dp2)
            um = (um*dp1+u(i,k+2)*dp(i,k+2))/dp2
            um_tl = dp_tl(i,k+3)*(u(i,k+3)/(dp2+dp(i,k+3))-(um*dp2+u(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+dp2_tl*&
&(um/(dp2+dp(i,k+3))-(um*dp2+u(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+u_tm(i,k+3)*(dp(i,k+3)/(dp2+dp(i,k+&
&3)))+um_tl*(dp2/(dp2+dp(i,k+3)))
            um = (um*dp2+u(i,k+3)*dp(i,k+3))/(dp2+dp(i,k+3))
            u_tm(i,k) = um_tl
            u(i,k) = um
            u_tm(i,k+1) = um_tl
            u(i,k+1) = um
            u_tm(i,k+2) = um_tl
            u(i,k+2) = um
            u_tm(i,k+3) = um_tl
            u(i,k+3) = um
            vm_tl = dp_tl(i,k+1)*(v(i,k+1)/dp1)+dp_tl(i,k)*(v(i,k)/dp1)-dp1_tl*((v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/(dp1*dp1))+&
&v_tm(i,k+1)*(dp(i,k+1)/dp1)+v_tm(i,k)*(dp(i,k)/dp1)
            vm = (v(i,k)*dp(i,k)+v(i,k+1)*dp(i,k+1))/dp1
            vm_tl = dp_tl(i,k+2)*(v(i,k+2)/dp2)+dp1_tl*(vm/dp2)-dp2_tl*((vm*dp1+v(i,k+2)*dp(i,k+2))/(dp2*dp2))+v_tm(i,k+2)*(dp(i,k+&
&2)/dp2)+vm_tl*(dp1/dp2)
            vm = (vm*dp1+v(i,k+2)*dp(i,k+2))/dp2
            vm_tl = dp_tl(i,k+3)*(v(i,k+3)/(dp2+dp(i,k+3))-(vm*dp2+v(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+dp2_tl*&
&(vm/(dp2+dp(i,k+3))-(vm*dp2+v(i,k+3)*dp(i,k+3))/((dp2+dp(i,k+3))*(dp2+dp(i,k+3))))+v_tm(i,k+3)*(dp(i,k+3)/(dp2+dp(i,k+&
&3)))+vm_tl*(dp2/(dp2+dp(i,k+3)))
            vm = (vm*dp2+v(i,k+3)*dp(i,k+3))/(dp2+dp(i,k+3))
            v_tm(i,k) = vm_tl
            v(i,k) = vm
            v_tm(i,k+1) = vm_tl
            v(i,k+1) = vm
            v_tm(i,k+2) = vm_tl
            v(i,k+2) = vm
            v_tm(i,k+3) = vm_tl
            v(i,k+3) = vm
          endif
        endif
      endif
    endif
  end do
end do
if (mixm) then
  do k = 1, klow+3
    do i = 1, im
      fu_tl(i,k) = fu_tl(i,k)+u_tm(i,k)*rdt-ut_tl(i,k)*rdt
      fu(i,k) = fu(i,k)+(u(i,k)-ut(i,k))*rdt
      fv_tl(i,k) = fv_tl(i,k)+v_tm(i,k)*rdt-vt_tl(i,k)*rdt
      fv(i,k) = fv(i,k)+(v(i,k)-vt(i,k))*rdt
    end do
  end do
endif

end subroutine dry_adj_tl


#endif /* SPMD */
